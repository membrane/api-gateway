<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns="http://membrane-soa.org/proxies/1/"
	xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:beans="http://www.springframework.org/schema/beans"
	targetNamespace="http://membrane-soa.org/proxies/1/"
	elementFormDefault="qualified" attributeFormDefault="unqualified">

<!-- Automatically generated by com.predic8.membrane.annot.generator.Schemas. -->

<xsd:import namespace="http://www.springframework.org/schema/beans" schemaLocation="http://www.springframework.org/schema/beans/spring-beans-3.1.xsd" />

<xsd:simpleType name="spel_number">
    <xsd:restriction base="xsd:string">
        <xsd:pattern value="-?[0-9]+|\#\{.*\}|\$\{.*\}"></xsd:pattern>
    </xsd:restriction>
</xsd:simpleType>

<xsd:simpleType name="spel_boolean">
    <xsd:restriction base="xsd:string">
        <xsd:pattern value="[01]|true|false|\#\{.*\}|\$\{.*\}"></xsd:pattern>
    </xsd:restriction>
</xsd:simpleType>

<xsd:element name="httpClient">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
 Server using the HTTP protocol. Usually it will be globally used
 inside the transport. However, it is also possible to use it
 inside a proxy to give the proxy an individual configuration for
 its outgoing HTTP connection that is different from the global
 configuration in the transport.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element ref="httpClientConfig">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="failOverOn5XX" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Whether to retry again (possibly the next node, when load
 balancing is active) after a HTTP status code
 500&lt;=&lt;i&gt;x&lt;/i&gt;&lt;600 was received.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="adjustHostHeader" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Whether the HTTP "Host" header should be set before the response will be forwarded to its destination.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Set this to &lt;i&gt;false&lt;/i&gt;, if the incoming HTTP "Host" header should not be modified.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="jwtAuth">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element ref="headerJwtRetriever">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element ref="jwks">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="expectedAud" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Expected audience ('aud') value of the token.&lt;/p&gt;
 &lt;p&gt;Use "any!!" to allow any audience value. This is strongly discouraged.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="wsStompReassembler">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element ref="httpClient">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
 Server using the HTTP protocol. Usually it will be globally used
 inside the transport. However, it is also possible to use it
 inside a proxy to give the proxy an individual configuration for
 its outgoing HTTP connection that is different from the global
 configuration in the transport.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtAuth">
</xsd:element>
<xsd:element ref="interceptor">
</xsd:element>
<xsd:element ref="tcp">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="tokenValidator">
</xsd:element>
<xsd:element ref="beautifier">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Beautifies request and response bodies. Supported are the Formats: JSON, XML&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="static">
</xsd:element>
<xsd:element ref="jsonProtection">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="http2xml">
</xsd:element>
<xsd:element name="echo" type="com.predic8.membrane.core.config.spring.EchoParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Returns the flow of plugins and copies the content of the
 request into a new response. The response has a status code of 200.
 Useful for testing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xml2Json">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If enabled converts body content from xml to json.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Can be used for both request and response. Xml file assumed to be in UTF-8. If input is invalid it returns
 empty json object.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="authHead2Body">
</xsd:element>
<xsd:element ref="webServer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
 "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
 &lt;/p&gt;
 &lt;p&gt;
 The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
 HTTP response with the contents of a file, or a "404 Not Found." error.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="internalRouting">
</xsd:element>
<xsd:element ref="exchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
              might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="dispatching">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
 element to the list of destinations of the exchange object. It
 must be placed into the transport to make Service Proxies Work
 properly. It has to be placed after the ruleMatching
 interceptor. The ruleMatching interceptor looks up a service
 proxy for an incoming request and places it into the exchange
 object. The dispatching interceptor needs the service proxy to
 get information about the target.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shadowing">
</xsd:element>
<xsd:element ref="openapiPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;openapiPublisher&lt;/i&gt; serves OpenAPI documents
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessControl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
              requested resource.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="acmeHttpChallenge">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See the documentation of the &lt;code&gt;&lt;acme /&gt;&lt;/code&gt; element for usage details.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="transform">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transform feature applies an XSLT transformation to the content in the body of a message. After the
              transformation the body content is replaced with the result of the transformation.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Rewrites or redirects the path of incoming requests based on a mapping.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rest2Soap">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xenAuthentication">
</xsd:element>
<xsd:element ref="graphQLProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Check GraphQL-over-HTTP requests, enforcing several limits and/or restrictions. This effectively helps to reduce
 the attack surface.
 &lt;p&gt;
 GraphQL Specification "October2021" is used. (But GraphQL only covers formulation of Documents/Queries.)
 &lt;/p&gt;
 &lt;p&gt;
 GraphQL-over-HTTP, which specifies how to submit GraphQL queries via HTTP, has not been released/finalized yet. We
 therefore use Version
 &lt;a href="https://github.com/graphql/graphql-over-http/blob/a1e6d8ca248c9a19eb59a2eedd988c204909ee3f/spec/GraphQLOverHTTP.md"&gt;a1e6d8ca&lt;/a&gt;.
 &lt;/p&gt;
 &lt;p&gt;
 Only GraphQL documents conforming to the 'ExecutableDocument' of the grammar are allowed: This includes the usual
 'query', 'mutation', 'subscription' and 'fragment's.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapOperationExtractor">
</xsd:element>
<xsd:element ref="balancer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="reverseProxying">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
 as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
 hostnames and ports used to access Membrane  vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clamav">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Delegates virus checks to an external Virus Scanner.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="destination">
</xsd:element>
<xsd:element ref="requireAuth">
</xsd:element>
<xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;request&gt; Element you can limit their application to requests only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="cache">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Don't use, this does NOT implement valid HTTP caching.
              &lt;/p&gt;
              &lt;p&gt;
                  We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                  the Docker Registry for offline use.
                  The cache does not revalidate any responses, so machines querying the cache for Debian
                  package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                  This is - simply put - the only use case, where using this class makes any sense.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsJDBC">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
 database (one row per exchange).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="index">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
              To use this feature just add a serviceProxy containing the index
              element. Of course you can protect the service proxy by using
              SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;wsdlPublisher&lt;/i&gt; serves WSDL files (and attached XML Schema Documents), if your
 backend service does not already do so.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="webServiceExplorer">
</xsd:element>
<xsd:element ref="logContext">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="APIsJSON">
</xsd:element>
<xsd:element ref="flowInitiator">
</xsd:element>
<xsd:element ref="counter">
</xsd:element>
<xsd:element ref="rateLimiter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;rateLimiter&lt;/i&gt; plugin limits the number of requests of a client in a period of time.
 As a default the client requests are grouped by client-Ip address and then counted. There are lots of
 possibilities to group the requests using the keyExpression. The requests can even be counted from different
 clients together.&lt;/p&gt;
 &lt;p&gt;When the gateway is located behind a loadbalancer then
 the client-Ip address is not the one from the client but the address from the balancer. To get the real Ip-address loadbalancers,
 &lt;i&gt;Web Application Firewalls&lt;/i&gt; and reverse proxies set the ip from the original client into the &lt;i&gt;X-Forwarded-For&lt;/i&gt; HTTP
 header field. The limiter plugin can take the Ip-address from the header.&lt;/p&gt;
 &lt;p&gt;
 The X-Forwarded-For header can only be trusted when a trustworthy reverse proxy or load balancer is between the client and server. The gateway not should be
 reachable directly. Only activate this feature when you know what you are doing.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="call">
</xsd:element>
<xsd:element ref="oauth2Resource2">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
 authorization server as response.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="if">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The "if" interceptor supports conditional execution of nested plugins.
 &lt;/p&gt;
 See:
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorSpELTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorGroovyTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorJsonpathTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorXPathTest&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="template">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders the body content of a message from a template. The template can
 produce plain text, Json or XML. Variables in the template are substituted with values from the body,
 header, query parameters, etc. If the extension of a referenced template file is &lt;i&gt;.xml&lt;/i&gt; it will use
 &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_xmltemplateengine"&gt;XMLTemplateEngine&lt;/a&gt;
 otherwise &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_streamingtemplateengine"&gt;StreamingTemplateEngine&lt;/a&gt;.
 Have a look at the samples in &lt;a href="https://github.com/membrane/service-proxy/tree/master/distribution/examples"&gt;examples/template&lt;/a&gt;.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="groovyTemplate">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Uses the groovy template markup engine to produce HTML-based responses.
 &lt;code&gt;
 &lt;groovyTemplate&gt;&lt;![CDATA[
   html {
     head {
       title('Resource')
     }
     body {
       p('Hello from Membrane!')
     }
   }
 ]]&gt;&lt;/groovyTemplate&gt;
 &lt;/code&gt;
 &lt;p&gt;
 The word "spring" refers to the Spring ApplicationContext.
 The word "exc" refers to the Membrane Exchange being handled.
 The word "flow" refers to the current Membrane Flow (=REQUEST).
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessLog">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes exchange metrics into a Log4j appender&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Defaults to Apache Common Log pattern&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="prometheus">
</xsd:element>
<xsd:element ref="wadlRewriter">
</xsd:element>
<xsd:element ref="openTelemetry">
</xsd:element>
<xsd:element ref="limit">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Note that due to the streaming nature of Membrane, a request header may already have been passed on to
              the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
              aborted and the connection to the backend is simply closed.
              &lt;/p&gt;
              &lt;p&gt;
              To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
              &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="basicAuthentication">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="json2Xml">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts body payload from JSON to XML. The JSON must be an object other JSON documents e.g. arrays are not supported.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Resulting XML will be in UTF-8 encoding.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shutdown">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Shutdown interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                  Adds the ability to shutdown main router thread via an HTTP request.
                  Don't forget to setup security for this interceptor.
              &lt;/p&gt;
              &lt;p&gt;
                  Has undefined behavior when Membrane is &lt;b&gt;not&lt;/b&gt; started from command line
                  (=via the RouterCLI class, which &lt;tt&gt;service-proxy.ps1&lt;/tt&gt;/&lt;tt&gt;service-proxy.sh&lt;/tt&gt;
                  do use).
              &lt;/p&gt;
              &lt;p&gt;
                  Only actually terminates the running JVM, when used in the first
                  &lt;tt&gt;&lt;router&gt;&lt;/tt&gt; bean (which implicitly stands for
                  &lt;tt&gt;&lt;router id="router"&gt;&lt;/tt&gt;) called "router".
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="userFeature">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapStackTraceFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
              advised to test its functionality in combination with your SOAP service provider before deploying it in
              production.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="formValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiDocs">
</xsd:element>
<xsd:element ref="choose">
</xsd:element>
<xsd:element ref="testService">
</xsd:element>
<xsd:element ref="soap2Rest">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clusterNotification">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane API Gateway distribution.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setHeader">
</xsd:element>
<xsd:element ref="groovy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Groovy script. The script can access and manipulate data from the request and response.
 Use this or the Javascript plugin to extend the functions of Membrane by scripting.
 See: example/groovy for working samples&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtSign">
</xsd:element>
<xsd:element ref="statisticsProvider">
</xsd:element>
<xsd:element ref="replace">
</xsd:element>
<xsd:element ref="methodOverride">
</xsd:element>
<xsd:element ref="stompClient">
</xsd:element>
<xsd:element ref="webSocket">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
 attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="log">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages. The messages will appear either on the console or in
 a log file depending on the log configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="return">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Terminates the exchange flow. The returned response is determined in the following order:
 &lt;p&gt;
 1. If there is already a response in the exchange, that response is returned
 2. If there is no response in the exchange, the body and contentType of the request is copied into a new response.
 &lt;/p&gt;
 &lt;p&gt;
 The options statusCode and contentType will overwrite the values from the messages.
 &lt;/p&gt;
 &lt;p&gt;
 This plugin is useful together with the template plugin. See examples/template.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsCSV">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
              file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="openapiValidator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Validator for OpenAPI documents&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accountRegistration">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="kubernetesValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Kubernetes Integration is still experimental.
 &lt;p&gt;
 To create the CustomResourceDefinitions, apply kubernetes-config.yaml from
 core/target/classes/com/predic8/membrane/core/config/kubernetes/ or a part (e.g. the 'serviceproxies' CRD) of the file.
 &lt;/p&gt;
 &lt;p&gt;
 Create a key and certificate for TLS for &lt;a href="https://membrane-validator.membrane-soa.svc:444/"&gt;https://membrane-validator.membrane-soa.svc:444/&lt;/a&gt; and setup Membrane to serve
 this address. The configuration shown below configures Membrane on a fixed IP address outside of the Kubernetes cluster,
 but this is no requirement.
 &lt;/p&gt;
 &lt;p&gt;
 Embed the following serviceProxy and adjust the 'resources' attribute to a comma-separated list of CRDs that you applied.
 Note that while the CRDs have plural names, here you need to use the corresponding singular. Configure the "ssl" section
 using your key and certificate.
 &lt;/p&gt;
 &lt;code&gt;
 &gt;serviceProxy port="444"&gt;
 &gt;ssl&gt;
 &gt;key&gt;
 &gt;private&gt;
 -----BEGIN RSA PRIVATE KEY-----
 ...
 -----END RSA PRIVATE KEY-----
 &gt;/private&gt;
 &gt;certificate&gt;
 -----BEGIN CERTIFICATE-----
 ...
 -----END CERTIFICATE-----
 &gt;/certificate&gt;
 &gt;/key&gt;
 &gt;/ssl&gt;
 &gt;kubernetesValidation resources="serviceproxy" /&gt;
 &gt;/serviceProxy&gt;
 &lt;/code&gt;
 &lt;p&gt;
 Now register a Webhook to validate the new CRDs. (A note to the experts: Membrane's validation schemas are too
 complex to fit into the CRD, because they are highly nestable and self-referencing. We therefore use webhooks.)
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: admissionregistration.k8s.io/v1
 kind: ValidatingWebhookConfiguration
 metadata:
 name: membrane
 webhooks:
 - name: membrane.membrane-soa.org
 admissionReviewVersions: ["v1", "v1beta1"]
 failurePolicy: Fail
 rules:
 - operations: [ "*" ]
 apiGroups: [ "membrane-soa.org" ]
 apiVersions: [ "v1", "v1beta1" ]
 resources: [ "*" ]
 scope: "*"
 clientConfig:
 service:
 name: membrane-validator
 namespace: membrane-soa
 port: 444
 caBundle: LS0t...LQ0K        # base64 encoded, PEM-formatted CA certificate
 sideEffects: None
 ---
 apiVersion: v1
 kind: Namespace
 metadata:
 name: membrane-soa
 ---
 apiVersion: v1
 kind: Service
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 spec:
 ports:
 - port: 444
 ---
 apiVersion: v1
 kind: Endpoints
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 subsets:
 - addresses:
 - ip: 192.168.0.1   # Membrane's IP
 ports:
 - port: 444
 &lt;/code&gt;
 &lt;p&gt;
 Once this setup is complete, you can enable serviceProxies like this:
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: membrane-soa.org/v1beta1
 kind: serviceproxy
 metadata:
 name: demo
 namespace: membrane-soa
 spec:
 host: demo.predic8.de
 path:
 value: /some-path/
 interceptors:
 - response:
 interceptors:
 - groovy:
 src: |
 println "Hello!"
 target:
 host: thomas-bayer.com
 &lt;/code&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setProperty">
</xsd:element>
<xsd:element ref="javascript">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Javascript. The script can access and manipulate data from the request and response.
 Use this or the Groovy plugin to extend the functions of Membrane by scripting. See the samples in examples/javascript.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="paddingHeader">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="greaser">
</xsd:element>
<xsd:element ref="soapBody">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders a SOAP body for legacy intergration&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;response&gt; plugin you can limit their application to responses only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="throttle">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The throttle feature can slow down traffic to thwart denial of service attacks.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlContentFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
 using an XPath expression.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
 match a message at all. This can improve performance significantly, as a DOM tree does probably not have
 to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
 lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
 namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
 &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
 the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
 constructed.
 &lt;/p&gt;
 &lt;p&gt;
 If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
 XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
 modified reconstituted message.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="headerFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
 The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ntlm">
</xsd:element>
<xsd:element ref="login">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
              application.
              &lt;/p&gt;
              &lt;p&gt;
              Users firstly have to authenticate themselves against a directory server using a username and password.
              Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
              token verification, access to the web application is granted for the user's session. Single Sign On can
              easily be realized using a small source code extension or modification of a web application.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
              each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
              default implementations.)
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
              cell phone number, Single Sign On data, etc.).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
              session cookie).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
              attempts for a specified amount of time.
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
              secondary channel like text messaging).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;/ul&gt;
              &lt;p&gt;
              &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
              title="login interceptor workflow"/&gt;
              &lt;/p&gt;
              &lt;p&gt;
              (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
              possible.)
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
              valid, the workflow is as follows:
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
              &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
              &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
              used. Steps 5 and 6.)&lt;/li&gt;
              &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
              &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
              was directly requested). (Step 8.)&lt;/li&gt;
              &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="sampleSoapService">
</xsd:element>
<xsd:element ref="analyser">
</xsd:element>
<xsd:element ref="validator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlRewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="regExReplacer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="abort" type="com.predic8.membrane.core.config.spring.AbortParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Plugins are usually applied to requests and responses.
 In case of errors, the flow returns and &lt;i&gt;handleAbort()&lt;/i&gt; is called on plugins
 going back the chain.
 By nesting plugins into an &lt;abort&gt; you can limit their application to abort flows only.
 On plugins nested in &lt;abort&gt; handleResponse() is called not handleAbort() in order to
 allow normal processing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiKey">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Secures APIs by validating keys stored in either files or proxies.xml. Keys can be received from clients via HTTP headers or URL query parameters. Additional permission checks are possible through scope validation - scopes are loaded into an Exchange property and can be checked using the "hasScope()" SpEL function.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="oauth2authserver">
</xsd:element>
<xsd:element ref="adminConsole">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="urlNormalizer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Replaces "/./" in the request URI's path by "/".
              &lt;/p&gt;
              &lt;p&gt;
              Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
              links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
              root). The SOA model then combines "&lt;a href="http://foo/material/ArticleService?wsdl"&gt;http://foo/material/ArticleService?wsdl&lt;/a&gt;" and
              "./ArticleService?xsd=1" to "&lt;a href="http://foo/material/./ArticleService?xsd=1"&gt;http://foo/material/./ArticleService?xsd=1&lt;/a&gt;". This URI is sent to Membrane's
              new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
              not match.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ruleMatching">
</xsd:element>
<xsd:element ref="oauth2PermissionChecker">
</xsd:element>
<xsd:element ref="for">
</xsd:element>
</xsd:choice>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="interceptor">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element ref="httpClient">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
 Server using the HTTP protocol. Usually it will be globally used
 inside the transport. However, it is also possible to use it
 inside a proxy to give the proxy an individual configuration for
 its outgoing HTTP connection that is different from the global
 configuration in the transport.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtAuth">
</xsd:element>
<xsd:element ref="interceptor">
</xsd:element>
<xsd:element ref="tcp">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="tokenValidator">
</xsd:element>
<xsd:element ref="beautifier">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Beautifies request and response bodies. Supported are the Formats: JSON, XML&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="static">
</xsd:element>
<xsd:element ref="jsonProtection">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="http2xml">
</xsd:element>
<xsd:element name="echo" type="com.predic8.membrane.core.config.spring.EchoParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Returns the flow of plugins and copies the content of the
 request into a new response. The response has a status code of 200.
 Useful for testing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xml2Json">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If enabled converts body content from xml to json.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Can be used for both request and response. Xml file assumed to be in UTF-8. If input is invalid it returns
 empty json object.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="authHead2Body">
</xsd:element>
<xsd:element ref="webServer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
 "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
 &lt;/p&gt;
 &lt;p&gt;
 The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
 HTTP response with the contents of a file, or a "404 Not Found." error.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="internalRouting">
</xsd:element>
<xsd:element ref="exchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
              might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="dispatching">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
 element to the list of destinations of the exchange object. It
 must be placed into the transport to make Service Proxies Work
 properly. It has to be placed after the ruleMatching
 interceptor. The ruleMatching interceptor looks up a service
 proxy for an incoming request and places it into the exchange
 object. The dispatching interceptor needs the service proxy to
 get information about the target.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shadowing">
</xsd:element>
<xsd:element ref="openapiPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;openapiPublisher&lt;/i&gt; serves OpenAPI documents
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessControl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
              requested resource.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="acmeHttpChallenge">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See the documentation of the &lt;code&gt;&lt;acme /&gt;&lt;/code&gt; element for usage details.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="transform">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transform feature applies an XSLT transformation to the content in the body of a message. After the
              transformation the body content is replaced with the result of the transformation.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Rewrites or redirects the path of incoming requests based on a mapping.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rest2Soap">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xenAuthentication">
</xsd:element>
<xsd:element ref="graphQLProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Check GraphQL-over-HTTP requests, enforcing several limits and/or restrictions. This effectively helps to reduce
 the attack surface.
 &lt;p&gt;
 GraphQL Specification "October2021" is used. (But GraphQL only covers formulation of Documents/Queries.)
 &lt;/p&gt;
 &lt;p&gt;
 GraphQL-over-HTTP, which specifies how to submit GraphQL queries via HTTP, has not been released/finalized yet. We
 therefore use Version
 &lt;a href="https://github.com/graphql/graphql-over-http/blob/a1e6d8ca248c9a19eb59a2eedd988c204909ee3f/spec/GraphQLOverHTTP.md"&gt;a1e6d8ca&lt;/a&gt;.
 &lt;/p&gt;
 &lt;p&gt;
 Only GraphQL documents conforming to the 'ExecutableDocument' of the grammar are allowed: This includes the usual
 'query', 'mutation', 'subscription' and 'fragment's.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapOperationExtractor">
</xsd:element>
<xsd:element ref="balancer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="reverseProxying">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
 as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
 hostnames and ports used to access Membrane  vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clamav">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Delegates virus checks to an external Virus Scanner.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="destination">
</xsd:element>
<xsd:element ref="requireAuth">
</xsd:element>
<xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;request&gt; Element you can limit their application to requests only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="cache">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Don't use, this does NOT implement valid HTTP caching.
              &lt;/p&gt;
              &lt;p&gt;
                  We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                  the Docker Registry for offline use.
                  The cache does not revalidate any responses, so machines querying the cache for Debian
                  package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                  This is - simply put - the only use case, where using this class makes any sense.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsJDBC">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
 database (one row per exchange).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="index">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
              To use this feature just add a serviceProxy containing the index
              element. Of course you can protect the service proxy by using
              SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;wsdlPublisher&lt;/i&gt; serves WSDL files (and attached XML Schema Documents), if your
 backend service does not already do so.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="webServiceExplorer">
</xsd:element>
<xsd:element ref="logContext">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="APIsJSON">
</xsd:element>
<xsd:element ref="flowInitiator">
</xsd:element>
<xsd:element ref="counter">
</xsd:element>
<xsd:element ref="rateLimiter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;rateLimiter&lt;/i&gt; plugin limits the number of requests of a client in a period of time.
 As a default the client requests are grouped by client-Ip address and then counted. There are lots of
 possibilities to group the requests using the keyExpression. The requests can even be counted from different
 clients together.&lt;/p&gt;
 &lt;p&gt;When the gateway is located behind a loadbalancer then
 the client-Ip address is not the one from the client but the address from the balancer. To get the real Ip-address loadbalancers,
 &lt;i&gt;Web Application Firewalls&lt;/i&gt; and reverse proxies set the ip from the original client into the &lt;i&gt;X-Forwarded-For&lt;/i&gt; HTTP
 header field. The limiter plugin can take the Ip-address from the header.&lt;/p&gt;
 &lt;p&gt;
 The X-Forwarded-For header can only be trusted when a trustworthy reverse proxy or load balancer is between the client and server. The gateway not should be
 reachable directly. Only activate this feature when you know what you are doing.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="call">
</xsd:element>
<xsd:element ref="oauth2Resource2">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
 authorization server as response.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="if">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The "if" interceptor supports conditional execution of nested plugins.
 &lt;/p&gt;
 See:
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorSpELTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorGroovyTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorJsonpathTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorXPathTest&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="template">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders the body content of a message from a template. The template can
 produce plain text, Json or XML. Variables in the template are substituted with values from the body,
 header, query parameters, etc. If the extension of a referenced template file is &lt;i&gt;.xml&lt;/i&gt; it will use
 &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_xmltemplateengine"&gt;XMLTemplateEngine&lt;/a&gt;
 otherwise &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_streamingtemplateengine"&gt;StreamingTemplateEngine&lt;/a&gt;.
 Have a look at the samples in &lt;a href="https://github.com/membrane/service-proxy/tree/master/distribution/examples"&gt;examples/template&lt;/a&gt;.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="groovyTemplate">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Uses the groovy template markup engine to produce HTML-based responses.
 &lt;code&gt;
 &lt;groovyTemplate&gt;&lt;![CDATA[
   html {
     head {
       title('Resource')
     }
     body {
       p('Hello from Membrane!')
     }
   }
 ]]&gt;&lt;/groovyTemplate&gt;
 &lt;/code&gt;
 &lt;p&gt;
 The word "spring" refers to the Spring ApplicationContext.
 The word "exc" refers to the Membrane Exchange being handled.
 The word "flow" refers to the current Membrane Flow (=REQUEST).
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessLog">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes exchange metrics into a Log4j appender&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Defaults to Apache Common Log pattern&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="prometheus">
</xsd:element>
<xsd:element ref="wadlRewriter">
</xsd:element>
<xsd:element ref="openTelemetry">
</xsd:element>
<xsd:element ref="limit">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Note that due to the streaming nature of Membrane, a request header may already have been passed on to
              the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
              aborted and the connection to the backend is simply closed.
              &lt;/p&gt;
              &lt;p&gt;
              To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
              &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="basicAuthentication">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="json2Xml">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts body payload from JSON to XML. The JSON must be an object other JSON documents e.g. arrays are not supported.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Resulting XML will be in UTF-8 encoding.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shutdown">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Shutdown interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                  Adds the ability to shutdown main router thread via an HTTP request.
                  Don't forget to setup security for this interceptor.
              &lt;/p&gt;
              &lt;p&gt;
                  Has undefined behavior when Membrane is &lt;b&gt;not&lt;/b&gt; started from command line
                  (=via the RouterCLI class, which &lt;tt&gt;service-proxy.ps1&lt;/tt&gt;/&lt;tt&gt;service-proxy.sh&lt;/tt&gt;
                  do use).
              &lt;/p&gt;
              &lt;p&gt;
                  Only actually terminates the running JVM, when used in the first
                  &lt;tt&gt;&lt;router&gt;&lt;/tt&gt; bean (which implicitly stands for
                  &lt;tt&gt;&lt;router id="router"&gt;&lt;/tt&gt;) called "router".
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="userFeature">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapStackTraceFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
              advised to test its functionality in combination with your SOAP service provider before deploying it in
              production.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="formValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiDocs">
</xsd:element>
<xsd:element ref="choose">
</xsd:element>
<xsd:element ref="testService">
</xsd:element>
<xsd:element ref="soap2Rest">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clusterNotification">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane API Gateway distribution.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setHeader">
</xsd:element>
<xsd:element ref="groovy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Groovy script. The script can access and manipulate data from the request and response.
 Use this or the Javascript plugin to extend the functions of Membrane by scripting.
 See: example/groovy for working samples&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtSign">
</xsd:element>
<xsd:element ref="statisticsProvider">
</xsd:element>
<xsd:element ref="replace">
</xsd:element>
<xsd:element ref="methodOverride">
</xsd:element>
<xsd:element ref="stompClient">
</xsd:element>
<xsd:element ref="webSocket">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
 attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="log">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages. The messages will appear either on the console or in
 a log file depending on the log configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="return">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Terminates the exchange flow. The returned response is determined in the following order:
 &lt;p&gt;
 1. If there is already a response in the exchange, that response is returned
 2. If there is no response in the exchange, the body and contentType of the request is copied into a new response.
 &lt;/p&gt;
 &lt;p&gt;
 The options statusCode and contentType will overwrite the values from the messages.
 &lt;/p&gt;
 &lt;p&gt;
 This plugin is useful together with the template plugin. See examples/template.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsCSV">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
              file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="openapiValidator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Validator for OpenAPI documents&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accountRegistration">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="kubernetesValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Kubernetes Integration is still experimental.
 &lt;p&gt;
 To create the CustomResourceDefinitions, apply kubernetes-config.yaml from
 core/target/classes/com/predic8/membrane/core/config/kubernetes/ or a part (e.g. the 'serviceproxies' CRD) of the file.
 &lt;/p&gt;
 &lt;p&gt;
 Create a key and certificate for TLS for &lt;a href="https://membrane-validator.membrane-soa.svc:444/"&gt;https://membrane-validator.membrane-soa.svc:444/&lt;/a&gt; and setup Membrane to serve
 this address. The configuration shown below configures Membrane on a fixed IP address outside of the Kubernetes cluster,
 but this is no requirement.
 &lt;/p&gt;
 &lt;p&gt;
 Embed the following serviceProxy and adjust the 'resources' attribute to a comma-separated list of CRDs that you applied.
 Note that while the CRDs have plural names, here you need to use the corresponding singular. Configure the "ssl" section
 using your key and certificate.
 &lt;/p&gt;
 &lt;code&gt;
 &gt;serviceProxy port="444"&gt;
 &gt;ssl&gt;
 &gt;key&gt;
 &gt;private&gt;
 -----BEGIN RSA PRIVATE KEY-----
 ...
 -----END RSA PRIVATE KEY-----
 &gt;/private&gt;
 &gt;certificate&gt;
 -----BEGIN CERTIFICATE-----
 ...
 -----END CERTIFICATE-----
 &gt;/certificate&gt;
 &gt;/key&gt;
 &gt;/ssl&gt;
 &gt;kubernetesValidation resources="serviceproxy" /&gt;
 &gt;/serviceProxy&gt;
 &lt;/code&gt;
 &lt;p&gt;
 Now register a Webhook to validate the new CRDs. (A note to the experts: Membrane's validation schemas are too
 complex to fit into the CRD, because they are highly nestable and self-referencing. We therefore use webhooks.)
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: admissionregistration.k8s.io/v1
 kind: ValidatingWebhookConfiguration
 metadata:
 name: membrane
 webhooks:
 - name: membrane.membrane-soa.org
 admissionReviewVersions: ["v1", "v1beta1"]
 failurePolicy: Fail
 rules:
 - operations: [ "*" ]
 apiGroups: [ "membrane-soa.org" ]
 apiVersions: [ "v1", "v1beta1" ]
 resources: [ "*" ]
 scope: "*"
 clientConfig:
 service:
 name: membrane-validator
 namespace: membrane-soa
 port: 444
 caBundle: LS0t...LQ0K        # base64 encoded, PEM-formatted CA certificate
 sideEffects: None
 ---
 apiVersion: v1
 kind: Namespace
 metadata:
 name: membrane-soa
 ---
 apiVersion: v1
 kind: Service
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 spec:
 ports:
 - port: 444
 ---
 apiVersion: v1
 kind: Endpoints
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 subsets:
 - addresses:
 - ip: 192.168.0.1   # Membrane's IP
 ports:
 - port: 444
 &lt;/code&gt;
 &lt;p&gt;
 Once this setup is complete, you can enable serviceProxies like this:
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: membrane-soa.org/v1beta1
 kind: serviceproxy
 metadata:
 name: demo
 namespace: membrane-soa
 spec:
 host: demo.predic8.de
 path:
 value: /some-path/
 interceptors:
 - response:
 interceptors:
 - groovy:
 src: |
 println "Hello!"
 target:
 host: thomas-bayer.com
 &lt;/code&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setProperty">
</xsd:element>
<xsd:element ref="javascript">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Javascript. The script can access and manipulate data from the request and response.
 Use this or the Groovy plugin to extend the functions of Membrane by scripting. See the samples in examples/javascript.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="paddingHeader">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="greaser">
</xsd:element>
<xsd:element ref="soapBody">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders a SOAP body for legacy intergration&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;response&gt; plugin you can limit their application to responses only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="throttle">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The throttle feature can slow down traffic to thwart denial of service attacks.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlContentFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
 using an XPath expression.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
 match a message at all. This can improve performance significantly, as a DOM tree does probably not have
 to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
 lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
 namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
 &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
 the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
 constructed.
 &lt;/p&gt;
 &lt;p&gt;
 If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
 XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
 modified reconstituted message.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="headerFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
 The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ntlm">
</xsd:element>
<xsd:element ref="login">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
              application.
              &lt;/p&gt;
              &lt;p&gt;
              Users firstly have to authenticate themselves against a directory server using a username and password.
              Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
              token verification, access to the web application is granted for the user's session. Single Sign On can
              easily be realized using a small source code extension or modification of a web application.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
              each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
              default implementations.)
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
              cell phone number, Single Sign On data, etc.).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
              session cookie).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
              attempts for a specified amount of time.
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
              secondary channel like text messaging).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;/ul&gt;
              &lt;p&gt;
              &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
              title="login interceptor workflow"/&gt;
              &lt;/p&gt;
              &lt;p&gt;
              (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
              possible.)
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
              valid, the workflow is as follows:
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
              &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
              &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
              used. Steps 5 and 6.)&lt;/li&gt;
              &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
              &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
              was directly requested). (Step 8.)&lt;/li&gt;
              &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="sampleSoapService">
</xsd:element>
<xsd:element ref="analyser">
</xsd:element>
<xsd:element ref="validator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlRewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="regExReplacer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="abort" type="com.predic8.membrane.core.config.spring.AbortParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Plugins are usually applied to requests and responses.
 In case of errors, the flow returns and &lt;i&gt;handleAbort()&lt;/i&gt; is called on plugins
 going back the chain.
 By nesting plugins into an &lt;abort&gt; you can limit their application to abort flows only.
 On plugins nested in &lt;abort&gt; handleResponse() is called not handleAbort() in order to
 allow normal processing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiKey">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Secures APIs by validating keys stored in either files or proxies.xml. Keys can be received from clients via HTTP headers or URL query parameters. Additional permission checks are possible through scope validation - scopes are loaded into an Exchange property and can be checked using the "hasScope()" SpEL function.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="oauth2authserver">
</xsd:element>
<xsd:element ref="adminConsole">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="urlNormalizer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Replaces "/./" in the request URI's path by "/".
              &lt;/p&gt;
              &lt;p&gt;
              Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
              links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
              root). The SOA model then combines "&lt;a href="http://foo/material/ArticleService?wsdl"&gt;http://foo/material/ArticleService?wsdl&lt;/a&gt;" and
              "./ArticleService?xsd=1" to "&lt;a href="http://foo/material/./ArticleService?xsd=1"&gt;http://foo/material/./ArticleService?xsd=1&lt;/a&gt;". This URI is sent to Membrane's
              new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
              not match.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ruleMatching">
</xsd:element>
<xsd:element ref="oauth2PermissionChecker">
</xsd:element>
<xsd:element ref="for">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="refid" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Spring bean id of the referenced interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; myInterceptor&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="tcp">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="tokenValidator">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="endpoint" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the endpoint that validates the access token&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="inMemoryStore">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="beautifier">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Beautifies request and response bodies. Supported are the Formats: JSON, XML&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.StaticUserDataProvideruserParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="username" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The user's login.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="password" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The user's password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="sms" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The user's phone number (if used in combination with the {@link TelekomSMSTokenProvider}).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="secret" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The user's shared TOTP secret (if used in combination with the {@link TOTPTokenProvider}).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:anyAttribute processContents="skip">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Other user attributes. For example any attribute starting with "&lt;i&gt;header&lt;/i&gt;" will be added
              when HTTP requests are forwarded when authorized by this user.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:anyAttribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="static">
<xsd:complexType>
<xsd:complexContent mixed="true">
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/></xsd:sequence>
<xsd:attribute name="location" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="contentType" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="pretty" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.JwksjwkParser">
<xsd:complexContent mixed="true">
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/></xsd:sequence>
<xsd:attribute name="location" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See &lt;a href="https://www.membrane-soa.org/service-proxy-doc/current/configuration/location.htm"&gt;here&lt;/a&gt; for a description of the format.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="kid" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="keystore">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="location" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A file/resource containing the PKCS#12 keystore (*.p12).
 See &lt;a href="https://www.membrane-soa.org/service-proxy-doc/current/configuration/location.htm"&gt;here&lt;/a&gt; for a description of the format.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="password" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="type" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="provider" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="keyPassword" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="keyAlias" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="jsonProtection">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="reportError" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Overwrites default error reporting behaviour. If set to true, errors will provide ProblemDetails body,
 if set to false, errors will throw standard exceptions.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; null&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="maxTokens" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Maximum number of tokens a JSON document may consist of. For example, &lt;code&gt;{"a":"b"}&lt;/code&gt; counts
 as 3.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 10000&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="maxSize" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Maximum total size of the JSON document in bytes.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 52428800&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="maxDepth" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Maximum depth of nested JSON structures. For example, &lt;code&gt;{"a":{"b":{"c":"d"}}}&lt;/code&gt; has a depth
 of 3.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 50&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="maxStringLength" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Maximum string length. For example, &lt;code&gt;{"abcd": "efgh", "ijkl": [ "mnop" ], "qrst": { "uvwx":
 1}}&lt;/code&gt; has a maximum string length of 4. (In this example, all 6 strings effectively have length 4.)
 &lt;p&gt;
 The maximum string length also affects keys ("abcd", "ijkl", "qrst" and "uvwx" in the example). The keys can be
 also limited by the separate property maxKeyLength. The stricter limit applies.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 262144&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="maxKeyLength" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Maximum key length. For example, &lt;code&gt;{"abcd": "efgh123", "ijkl": [ "mnop123" ], "qrst": { "uvwx":
 1}}&lt;/code&gt; has a maximum key length of 4. (In this example, all 4 strings used as keys effectively have length
 4.)
 &lt;p&gt;
 The maximum key length also affects strings ("abcd", "ijkl", "qrst" and "uvwx" in the example). The strings can be
 also limited by the separate property maxStringLength. The stricter limit applies.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 256&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="maxObjectSize" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Maximum size of JSON objects. For example, &lt;code&gt;{"a": {"b":"c", "d": "e"}, "f": "g"}&lt;/code&gt; has a
 maximum object size of 2. (In this example, both objects effectively have a size of 2.)&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 1000&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="maxArraySize" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Maximum size of JSON objects. For example, &lt;code&gt;{"a": {"b":"c", "d": "e"}, "f": "g"}&lt;/code&gt; has a
 maximum object size of 2. (In this example, both objects effectively have a size of 2.)&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 1000&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="http2xml">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="serviceProxy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              A service proxy can be deployed on front of a Web server, Web Service or a REST resource. It conceals
              the server and offers the same interface as the target server to its clients.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If set, Membrane will only consider this rule, if the path of incoming HTTP requests matches.
 {@link Path} supports starts-with and regex matching.
 &lt;/p&gt;
 &lt;p&gt;
 If used in a {@link SOAPProxy}, this causes path rewriting of SOAP requests and in the WSDL to
 automatically be configured.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element name="path" type="com.predic8.membrane.core.config.spring.PathParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The value of the content will be taken to match the path.
              &lt;/p&gt;

              &lt;p&gt;
              If &lt;tt&gt;isRegExp="true"&lt;/tt&gt;, the whole path has to match the given regular expression. If
              &lt;tt&gt;isRegExp="false"&lt;/tt&gt;, the path has to start with the given string.
              &lt;/p&gt;

              &lt;p&gt;
              If &lt;tt&gt;&lt;path /&gt;&lt;/tt&gt; is a child element of a &lt;tt&gt;&lt;soapProxy /&gt;&lt;/tt&gt;, the &lt;tt&gt;isRegExp&lt;/tt&gt;
              attribute must not be present.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Configures the usage of inbound SSL (HTTPS).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element ref="ssl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element ref="httpClient">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
 Server using the HTTP protocol. Usually it will be globally used
 inside the transport. However, it is also possible to use it
 inside a proxy to give the proxy an individual configuration for
 its outgoing HTTP connection that is different from the global
 configuration in the transport.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtAuth">
</xsd:element>
<xsd:element ref="interceptor">
</xsd:element>
<xsd:element ref="tcp">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="tokenValidator">
</xsd:element>
<xsd:element ref="beautifier">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Beautifies request and response bodies. Supported are the Formats: JSON, XML&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="static">
</xsd:element>
<xsd:element ref="jsonProtection">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="http2xml">
</xsd:element>
<xsd:element name="echo" type="com.predic8.membrane.core.config.spring.EchoParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Returns the flow of plugins and copies the content of the
 request into a new response. The response has a status code of 200.
 Useful for testing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xml2Json">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If enabled converts body content from xml to json.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Can be used for both request and response. Xml file assumed to be in UTF-8. If input is invalid it returns
 empty json object.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="authHead2Body">
</xsd:element>
<xsd:element ref="webServer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
 "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
 &lt;/p&gt;
 &lt;p&gt;
 The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
 HTTP response with the contents of a file, or a "404 Not Found." error.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="internalRouting">
</xsd:element>
<xsd:element ref="exchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
              might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="dispatching">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
 element to the list of destinations of the exchange object. It
 must be placed into the transport to make Service Proxies Work
 properly. It has to be placed after the ruleMatching
 interceptor. The ruleMatching interceptor looks up a service
 proxy for an incoming request and places it into the exchange
 object. The dispatching interceptor needs the service proxy to
 get information about the target.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shadowing">
</xsd:element>
<xsd:element ref="openapiPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;openapiPublisher&lt;/i&gt; serves OpenAPI documents
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessControl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
              requested resource.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="acmeHttpChallenge">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See the documentation of the &lt;code&gt;&lt;acme /&gt;&lt;/code&gt; element for usage details.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="transform">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transform feature applies an XSLT transformation to the content in the body of a message. After the
              transformation the body content is replaced with the result of the transformation.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Rewrites or redirects the path of incoming requests based on a mapping.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rest2Soap">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xenAuthentication">
</xsd:element>
<xsd:element ref="graphQLProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Check GraphQL-over-HTTP requests, enforcing several limits and/or restrictions. This effectively helps to reduce
 the attack surface.
 &lt;p&gt;
 GraphQL Specification "October2021" is used. (But GraphQL only covers formulation of Documents/Queries.)
 &lt;/p&gt;
 &lt;p&gt;
 GraphQL-over-HTTP, which specifies how to submit GraphQL queries via HTTP, has not been released/finalized yet. We
 therefore use Version
 &lt;a href="https://github.com/graphql/graphql-over-http/blob/a1e6d8ca248c9a19eb59a2eedd988c204909ee3f/spec/GraphQLOverHTTP.md"&gt;a1e6d8ca&lt;/a&gt;.
 &lt;/p&gt;
 &lt;p&gt;
 Only GraphQL documents conforming to the 'ExecutableDocument' of the grammar are allowed: This includes the usual
 'query', 'mutation', 'subscription' and 'fragment's.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapOperationExtractor">
</xsd:element>
<xsd:element ref="balancer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="reverseProxying">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
 as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
 hostnames and ports used to access Membrane  vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clamav">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Delegates virus checks to an external Virus Scanner.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="destination">
</xsd:element>
<xsd:element ref="requireAuth">
</xsd:element>
<xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;request&gt; Element you can limit their application to requests only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="cache">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Don't use, this does NOT implement valid HTTP caching.
              &lt;/p&gt;
              &lt;p&gt;
                  We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                  the Docker Registry for offline use.
                  The cache does not revalidate any responses, so machines querying the cache for Debian
                  package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                  This is - simply put - the only use case, where using this class makes any sense.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsJDBC">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
 database (one row per exchange).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="index">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
              To use this feature just add a serviceProxy containing the index
              element. Of course you can protect the service proxy by using
              SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;wsdlPublisher&lt;/i&gt; serves WSDL files (and attached XML Schema Documents), if your
 backend service does not already do so.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="webServiceExplorer">
</xsd:element>
<xsd:element ref="logContext">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="APIsJSON">
</xsd:element>
<xsd:element ref="flowInitiator">
</xsd:element>
<xsd:element ref="counter">
</xsd:element>
<xsd:element ref="rateLimiter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;rateLimiter&lt;/i&gt; plugin limits the number of requests of a client in a period of time.
 As a default the client requests are grouped by client-Ip address and then counted. There are lots of
 possibilities to group the requests using the keyExpression. The requests can even be counted from different
 clients together.&lt;/p&gt;
 &lt;p&gt;When the gateway is located behind a loadbalancer then
 the client-Ip address is not the one from the client but the address from the balancer. To get the real Ip-address loadbalancers,
 &lt;i&gt;Web Application Firewalls&lt;/i&gt; and reverse proxies set the ip from the original client into the &lt;i&gt;X-Forwarded-For&lt;/i&gt; HTTP
 header field. The limiter plugin can take the Ip-address from the header.&lt;/p&gt;
 &lt;p&gt;
 The X-Forwarded-For header can only be trusted when a trustworthy reverse proxy or load balancer is between the client and server. The gateway not should be
 reachable directly. Only activate this feature when you know what you are doing.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="call">
</xsd:element>
<xsd:element ref="oauth2Resource2">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
 authorization server as response.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="if">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The "if" interceptor supports conditional execution of nested plugins.
 &lt;/p&gt;
 See:
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorSpELTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorGroovyTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorJsonpathTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorXPathTest&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="template">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders the body content of a message from a template. The template can
 produce plain text, Json or XML. Variables in the template are substituted with values from the body,
 header, query parameters, etc. If the extension of a referenced template file is &lt;i&gt;.xml&lt;/i&gt; it will use
 &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_xmltemplateengine"&gt;XMLTemplateEngine&lt;/a&gt;
 otherwise &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_streamingtemplateengine"&gt;StreamingTemplateEngine&lt;/a&gt;.
 Have a look at the samples in &lt;a href="https://github.com/membrane/service-proxy/tree/master/distribution/examples"&gt;examples/template&lt;/a&gt;.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="groovyTemplate">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Uses the groovy template markup engine to produce HTML-based responses.
 &lt;code&gt;
 &lt;groovyTemplate&gt;&lt;![CDATA[
   html {
     head {
       title('Resource')
     }
     body {
       p('Hello from Membrane!')
     }
   }
 ]]&gt;&lt;/groovyTemplate&gt;
 &lt;/code&gt;
 &lt;p&gt;
 The word "spring" refers to the Spring ApplicationContext.
 The word "exc" refers to the Membrane Exchange being handled.
 The word "flow" refers to the current Membrane Flow (=REQUEST).
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessLog">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes exchange metrics into a Log4j appender&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Defaults to Apache Common Log pattern&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="prometheus">
</xsd:element>
<xsd:element ref="wadlRewriter">
</xsd:element>
<xsd:element ref="openTelemetry">
</xsd:element>
<xsd:element ref="limit">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Note that due to the streaming nature of Membrane, a request header may already have been passed on to
              the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
              aborted and the connection to the backend is simply closed.
              &lt;/p&gt;
              &lt;p&gt;
              To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
              &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="basicAuthentication">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="json2Xml">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts body payload from JSON to XML. The JSON must be an object other JSON documents e.g. arrays are not supported.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Resulting XML will be in UTF-8 encoding.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shutdown">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Shutdown interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                  Adds the ability to shutdown main router thread via an HTTP request.
                  Don't forget to setup security for this interceptor.
              &lt;/p&gt;
              &lt;p&gt;
                  Has undefined behavior when Membrane is &lt;b&gt;not&lt;/b&gt; started from command line
                  (=via the RouterCLI class, which &lt;tt&gt;service-proxy.ps1&lt;/tt&gt;/&lt;tt&gt;service-proxy.sh&lt;/tt&gt;
                  do use).
              &lt;/p&gt;
              &lt;p&gt;
                  Only actually terminates the running JVM, when used in the first
                  &lt;tt&gt;&lt;router&gt;&lt;/tt&gt; bean (which implicitly stands for
                  &lt;tt&gt;&lt;router id="router"&gt;&lt;/tt&gt;) called "router".
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="userFeature">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapStackTraceFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
              advised to test its functionality in combination with your SOAP service provider before deploying it in
              production.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="formValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiDocs">
</xsd:element>
<xsd:element ref="choose">
</xsd:element>
<xsd:element ref="testService">
</xsd:element>
<xsd:element ref="soap2Rest">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clusterNotification">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane API Gateway distribution.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setHeader">
</xsd:element>
<xsd:element ref="groovy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Groovy script. The script can access and manipulate data from the request and response.
 Use this or the Javascript plugin to extend the functions of Membrane by scripting.
 See: example/groovy for working samples&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtSign">
</xsd:element>
<xsd:element ref="statisticsProvider">
</xsd:element>
<xsd:element ref="replace">
</xsd:element>
<xsd:element ref="methodOverride">
</xsd:element>
<xsd:element ref="stompClient">
</xsd:element>
<xsd:element ref="webSocket">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
 attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="log">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages. The messages will appear either on the console or in
 a log file depending on the log configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="return">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Terminates the exchange flow. The returned response is determined in the following order:
 &lt;p&gt;
 1. If there is already a response in the exchange, that response is returned
 2. If there is no response in the exchange, the body and contentType of the request is copied into a new response.
 &lt;/p&gt;
 &lt;p&gt;
 The options statusCode and contentType will overwrite the values from the messages.
 &lt;/p&gt;
 &lt;p&gt;
 This plugin is useful together with the template plugin. See examples/template.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsCSV">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
              file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="openapiValidator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Validator for OpenAPI documents&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accountRegistration">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="kubernetesValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Kubernetes Integration is still experimental.
 &lt;p&gt;
 To create the CustomResourceDefinitions, apply kubernetes-config.yaml from
 core/target/classes/com/predic8/membrane/core/config/kubernetes/ or a part (e.g. the 'serviceproxies' CRD) of the file.
 &lt;/p&gt;
 &lt;p&gt;
 Create a key and certificate for TLS for &lt;a href="https://membrane-validator.membrane-soa.svc:444/"&gt;https://membrane-validator.membrane-soa.svc:444/&lt;/a&gt; and setup Membrane to serve
 this address. The configuration shown below configures Membrane on a fixed IP address outside of the Kubernetes cluster,
 but this is no requirement.
 &lt;/p&gt;
 &lt;p&gt;
 Embed the following serviceProxy and adjust the 'resources' attribute to a comma-separated list of CRDs that you applied.
 Note that while the CRDs have plural names, here you need to use the corresponding singular. Configure the "ssl" section
 using your key and certificate.
 &lt;/p&gt;
 &lt;code&gt;
 &gt;serviceProxy port="444"&gt;
 &gt;ssl&gt;
 &gt;key&gt;
 &gt;private&gt;
 -----BEGIN RSA PRIVATE KEY-----
 ...
 -----END RSA PRIVATE KEY-----
 &gt;/private&gt;
 &gt;certificate&gt;
 -----BEGIN CERTIFICATE-----
 ...
 -----END CERTIFICATE-----
 &gt;/certificate&gt;
 &gt;/key&gt;
 &gt;/ssl&gt;
 &gt;kubernetesValidation resources="serviceproxy" /&gt;
 &gt;/serviceProxy&gt;
 &lt;/code&gt;
 &lt;p&gt;
 Now register a Webhook to validate the new CRDs. (A note to the experts: Membrane's validation schemas are too
 complex to fit into the CRD, because they are highly nestable and self-referencing. We therefore use webhooks.)
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: admissionregistration.k8s.io/v1
 kind: ValidatingWebhookConfiguration
 metadata:
 name: membrane
 webhooks:
 - name: membrane.membrane-soa.org
 admissionReviewVersions: ["v1", "v1beta1"]
 failurePolicy: Fail
 rules:
 - operations: [ "*" ]
 apiGroups: [ "membrane-soa.org" ]
 apiVersions: [ "v1", "v1beta1" ]
 resources: [ "*" ]
 scope: "*"
 clientConfig:
 service:
 name: membrane-validator
 namespace: membrane-soa
 port: 444
 caBundle: LS0t...LQ0K        # base64 encoded, PEM-formatted CA certificate
 sideEffects: None
 ---
 apiVersion: v1
 kind: Namespace
 metadata:
 name: membrane-soa
 ---
 apiVersion: v1
 kind: Service
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 spec:
 ports:
 - port: 444
 ---
 apiVersion: v1
 kind: Endpoints
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 subsets:
 - addresses:
 - ip: 192.168.0.1   # Membrane's IP
 ports:
 - port: 444
 &lt;/code&gt;
 &lt;p&gt;
 Once this setup is complete, you can enable serviceProxies like this:
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: membrane-soa.org/v1beta1
 kind: serviceproxy
 metadata:
 name: demo
 namespace: membrane-soa
 spec:
 host: demo.predic8.de
 path:
 value: /some-path/
 interceptors:
 - response:
 interceptors:
 - groovy:
 src: |
 println "Hello!"
 target:
 host: thomas-bayer.com
 &lt;/code&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setProperty">
</xsd:element>
<xsd:element ref="javascript">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Javascript. The script can access and manipulate data from the request and response.
 Use this or the Groovy plugin to extend the functions of Membrane by scripting. See the samples in examples/javascript.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="paddingHeader">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="greaser">
</xsd:element>
<xsd:element ref="soapBody">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders a SOAP body for legacy intergration&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;response&gt; plugin you can limit their application to responses only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="throttle">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The throttle feature can slow down traffic to thwart denial of service attacks.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlContentFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
 using an XPath expression.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
 match a message at all. This can improve performance significantly, as a DOM tree does probably not have
 to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
 lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
 namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
 &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
 the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
 constructed.
 &lt;/p&gt;
 &lt;p&gt;
 If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
 XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
 modified reconstituted message.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="headerFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
 The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ntlm">
</xsd:element>
<xsd:element ref="login">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
              application.
              &lt;/p&gt;
              &lt;p&gt;
              Users firstly have to authenticate themselves against a directory server using a username and password.
              Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
              token verification, access to the web application is granted for the user's session. Single Sign On can
              easily be realized using a small source code extension or modification of a web application.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
              each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
              default implementations.)
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
              cell phone number, Single Sign On data, etc.).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
              session cookie).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
              attempts for a specified amount of time.
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
              secondary channel like text messaging).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;/ul&gt;
              &lt;p&gt;
              &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
              title="login interceptor workflow"/&gt;
              &lt;/p&gt;
              &lt;p&gt;
              (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
              possible.)
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
              valid, the workflow is as follows:
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
              &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
              &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
              used. Steps 5 and 6.)&lt;/li&gt;
              &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
              &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
              was directly requested). (Step 8.)&lt;/li&gt;
              &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="sampleSoapService">
</xsd:element>
<xsd:element ref="analyser">
</xsd:element>
<xsd:element ref="validator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlRewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="regExReplacer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="abort" type="com.predic8.membrane.core.config.spring.AbortParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Plugins are usually applied to requests and responses.
 In case of errors, the flow returns and &lt;i&gt;handleAbort()&lt;/i&gt; is called on plugins
 going back the chain.
 By nesting plugins into an &lt;abort&gt; you can limit their application to abort flows only.
 On plugins nested in &lt;abort&gt; handleResponse() is called not handleAbort() in order to
 allow normal processing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiKey">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Secures APIs by validating keys stored in either files or proxies.xml. Keys can be received from clients via HTTP headers or URL query parameters. Additional permission checks are possible through scope validation - scopes are loaded into an Exchange property and can be checked using the "hasScope()" SpEL function.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="oauth2authserver">
</xsd:element>
<xsd:element ref="adminConsole">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="urlNormalizer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Replaces "/./" in the request URI's path by "/".
              &lt;/p&gt;
              &lt;p&gt;
              Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
              links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
              root). The SOA model then combines "&lt;a href="http://foo/material/ArticleService?wsdl"&gt;http://foo/material/ArticleService?wsdl&lt;/a&gt;" and
              "./ArticleService?xsd=1" to "&lt;a href="http://foo/material/./ArticleService?xsd=1"&gt;http://foo/material/./ArticleService?xsd=1&lt;/a&gt;". This URI is sent to Membrane's
              new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
              not match.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ruleMatching">
</xsd:element>
<xsd:element ref="oauth2PermissionChecker">
</xsd:element>
<xsd:element ref="for">
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element name="target" type="com.predic8.membrane.core.config.spring.TargetParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The destination where the service proxy will send messages to. Use the target element, if you want
 to send the messages to a static target. If you want to use dynamic destinations have a look at the
 &lt;a href="https://membrane-soa.org/service-proxy-doc/configuration/reference/router.htm"&gt;content based router&lt;/a&gt;.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="name" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The name as shown in the Admin Console.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; By default, a name will be automatically generated from the target host, port, etc.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="blockRequest" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;legacy attribute&lt;/i&gt; for usage by Membrane Monitor&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="blockResponse" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;legacy attribute&lt;/i&gt; for usage by Membrane Monitor&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="port" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The port Membrane listens on for incoming connections.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 8080&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 80&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="ip" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If present, binds the port only on the specified IP. Useful for hosts with multiple IP addresses.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 127.0.0.1&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;not set&lt;/i&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="host" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;A space separated list of hostnames. If set, Membrane will only consider this rule, if the "Host"
 header of incoming HTTP requests matches one of the hostnames.
 &lt;/p&gt;
 &lt;p&gt;
 The asterisk '*' can be used for basic globbing (to match any number, including zero, characters).
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; predic8.de *.predic8.de&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;not set&lt;/i&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="method" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If set, Membrane will only consider this rule, if the method (GET, PUT, POST, DELETE, etc.)
              header of incoming HTTP requests matches. The asterisk '*' matches any method.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; GET&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; *&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.EchoParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="xml2Json">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If enabled converts body content from xml to json.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Can be used for both request and response. Xml file assumed to be in UTF-8. If input is invalid it returns
 empty json object.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="publicURL">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="publicURL" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.ConnectionParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="keepAliveTimeout" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Time in milliseconds after which an open connection to the server is not reused. Be sure to set it to a smaller value than the KeepAlive
 directive on your server. Note that the a "Keep-Alive" header in the response always takes precedence.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 30000&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 4000&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="timeout" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Socket timeout (connect, read, etc.) in milliseconds.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 10000&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="localAddr" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The local IP address to use for outbound connections.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; not set&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="xmlSessionIdExtractor">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Extracts a session ID from an XML HTTP request body based on the qualified name of an XML element.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="localName" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Specifies local name of session element.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; session&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="namespace" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Specifies namespace of session element.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; &lt;a href="http://chat.predic8.com/"&gt;http://chat.predic8.com/&lt;/a&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="authHead2Body">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="memoryExchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Stores all exchanges in-memory. The Java heap will overflow if this store is used to store too many
              Exchanges. Use for Membrane Monitor only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="webServer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
 "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
 &lt;/p&gt;
 &lt;p&gt;
 The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
 HTTP response with the contents of a file, or a "404 Not Found." error.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="docBase" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Sets path to the directory that contains the web content.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; docBase&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; docBase&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="index" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="generateIndex" type="spel_boolean" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.TargetParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Configures outbound SSL (HTTPS).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element ref="ssl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="host" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Host address of the target.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; localhost, 192.168.1.1&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="port" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Port number of the target.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 8080&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 80&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="url" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Absolute URL of the target. If this is set, &lt;i&gt;host&lt;/i&gt; and &lt;i&gt;port&lt;/i&gt; will be ignored.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; &lt;a href="http://membrane-soa.org"&gt;http://membrane-soa.org&lt;/a&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="adjustHostHeader" type="spel_boolean" >
</xsd:attribute>
<xsd:attribute name="method" type="xsd:string" >
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="internalRouting">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="exchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
              might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="name" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Bean name of the exchange store defined as a spring bean.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; forgetfulExchangeStore&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="bean">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; "bean" should be used for Kubernetes only. Experimental.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element ref="httpClient">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
 Server using the HTTP protocol. Usually it will be globally used
 inside the transport. However, it is also possible to use it
 inside a proxy to give the proxy an individual configuration for
 its outgoing HTTP connection that is different from the global
 configuration in the transport.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtAuth">
</xsd:element>
<xsd:element ref="wsStompReassembler">
</xsd:element>
<xsd:element ref="interceptor">
</xsd:element>
<xsd:element ref="tcp">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="tokenValidator">
</xsd:element>
<xsd:element ref="inMemoryStore">
</xsd:element>
<xsd:element ref="beautifier">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Beautifies request and response bodies. Supported are the Formats: JSON, XML&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="user" type="com.predic8.membrane.core.config.spring.StaticUserDataProvideruserParser">
</xsd:element>
<xsd:element ref="static">
</xsd:element>
<xsd:element name="jwk" type="com.predic8.membrane.core.config.spring.JwksjwkParser">
</xsd:element>
<xsd:element ref="keystore">
</xsd:element>
<xsd:element ref="jsonProtection">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="http2xml">
</xsd:element>
<xsd:element ref="serviceProxy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              A service proxy can be deployed on front of a Web server, Web Service or a REST resource. It conceals
              the server and offers the same interface as the target server to its clients.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="echo" type="com.predic8.membrane.core.config.spring.EchoParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Returns the flow of plugins and copies the content of the
 request into a new response. The response has a status code of 200.
 Useful for testing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xml2Json">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If enabled converts body content from xml to json.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Can be used for both request and response. Xml file assumed to be in UTF-8. If input is invalid it returns
 empty json object.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="publicURL">
</xsd:element>
<xsd:element name="connection" type="com.predic8.membrane.core.config.spring.ConnectionParser">
</xsd:element>
<xsd:element ref="xmlSessionIdExtractor">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Extracts a session ID from an XML HTTP request body based on the qualified name of an XML element.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="authHead2Body">
</xsd:element>
<xsd:element ref="memoryExchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Stores all exchanges in-memory. The Java heap will overflow if this store is used to store too many
              Exchanges. Use for Membrane Monitor only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="webServer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
 "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
 &lt;/p&gt;
 &lt;p&gt;
 The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
 HTTP response with the contents of a file, or a "404 Not Found." error.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="target" type="com.predic8.membrane.core.config.spring.TargetParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The destination where the service proxy will send messages to. Use the target element, if you want
 to send the messages to a static target. If you want to use dynamic destinations have a look at the
 &lt;a href="https://membrane-soa.org/service-proxy-doc/configuration/reference/router.htm"&gt;content based router&lt;/a&gt;.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="internalRouting">
</xsd:element>
<xsd:element ref="exchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
              might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="bean">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; "bean" should be used for Kubernetes only. Experimental.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="staticUserDataProvider">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; listing all user data in-place in the config file.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              the &lt;i&gt;staticuserdataprovider&lt;/i&gt; can be used to statically list user data within the config file.
              &lt;/p&gt;
              &lt;p&gt;
              each user must have a unique &lt;i&gt;username&lt;/i&gt; attribute as well as a &lt;i&gt;password&lt;/i&gt; attribute.
              &lt;/p&gt;
              &lt;p&gt;
              arbitrary attributes can be set on a user element. other sub-components of the &lt;i&gt;login&lt;/i&gt; interceptor
              might use those: for example, the &lt;i&gt;telekomsmstokenprovider&lt;/i&gt; uses the &lt;i&gt;sms&lt;/i&gt; property as the
              user's cell phone number. for example, the &lt;i&gt;totptokenprovider&lt;/i&gt; uses the &lt;i&gt;secret&lt;/i&gt; property to
              initialize the token sequence.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="dispatching">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
 element to the list of destinations of the exchange object. It
 must be placed into the transport to make Service Proxies Work
 properly. It has to be placed after the ruleMatching
 interceptor. The ruleMatching interceptor looks up a service
 proxy for an incoming request and places it into the exchange
 object. The dispatching interceptor needs the service proxy to
 get information about the target.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="attribute" type="com.predic8.membrane.core.config.spring.AttributeParser">
</xsd:element>
<xsd:element ref="shadowing">
</xsd:element>
<xsd:element ref="acme">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures an ACME (RFC 8555) client, e.g. to retrieve TLS certificates from
 &lt;a href="https://letsencrypt.org/"&gt;Let's Encrypt&lt;/a&gt;.&lt;/p&gt;
 &lt;p&gt;To store the key material and certificates, you can use the local file system or your Kubernetes cluster.&lt;/p&gt;
 &lt;p&gt;
     To use ACME:
     &lt;ol&gt;
         &lt;li&gt;Register your domain and point the DNS record to your server(s) runnig Membrane.&lt;/li&gt;
         &lt;li&gt;Let Membrane listen on port 80 and use the &lt;code&gt;&lt;acmeHttpChallenge /&gt;&lt;/code&gt; (see below).&lt;/li&gt;
         &lt;li&gt;Let Membrane listen on port 443 and use &lt;code&gt;&lt;ssl&gt;&lt;acme .../&gt;&lt;ssl&gt;&lt;/code&gt; (see below).
         Here, you have to configure where Membrane will store the keys and certificates.
         &lt;/li&gt;
     &lt;/ol&gt;
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="fileStorage" type="com.predic8.membrane.core.config.spring.FileStorageParser">
</xsd:element>
<xsd:element name="headerExtractor" type="com.predic8.membrane.core.config.spring.HeaderExtractorParser">
</xsd:element>
<xsd:element ref="headerJwtRetriever">
</xsd:element>
<xsd:element name="headerRetriever" type="com.predic8.membrane.core.config.spring.HeaderRetrieverParser">
</xsd:element>
<xsd:element ref="registration">
</xsd:element>
<xsd:element name="queryParamExtractor" type="com.predic8.membrane.core.config.spring.QueryParamExtractorParser">
</xsd:element>
<xsd:element ref="resolverMap">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="jwk" type="com.predic8.membrane.core.config.spring.JwtSessionManagerjwkParser">
</xsd:element>
<xsd:element ref="openapiPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;openapiPublisher&lt;/i&gt; serves OpenAPI documents
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="sslProxy">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="jwk" type="com.predic8.membrane.core.config.spring.XenAuthenticationjwtSessionManagerjwkParser">
</xsd:element>
<xsd:element ref="jdbcUserDataProvider">
</xsd:element>
<xsd:element name="greaseJson" type="com.predic8.membrane.core.config.spring.GreaseJsonParser">
</xsd:element>
<xsd:element ref="accessControl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
              requested resource.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accountBlocker">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Keeps track of blocked user accounts (accounts become blocked after too many failed logins).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The Account Blocker prevents password and token guessing attempts: It blocks a user (or the whole
              system) after too many failed login attempts.
              &lt;/p&gt;
              &lt;p&gt;
              When a user entered a wrong password or wrong token more than &lt;i&gt;afterFailedLogins&lt;/i&gt; times, this user
              becomes blocked: He will be prevented from logging in again within the next &lt;i&gt;blockFor&lt;/i&gt; milliseconds
              (writing 3600000 means "for 1 hour").
              &lt;/p&gt;
              &lt;p&gt;
              The failed login attempts have to occur within the last &lt;i&gt;afterFailedLoginsWithin&lt;/i&gt; milliseconds
              (writing 9223372036854775807 means "forever").
              &lt;/p&gt;
              &lt;p&gt;
              If more than &lt;i&gt;blockWholeSystemAfter&lt;/i&gt; users become blocked at a time, the &lt;i&gt;all&lt;/i&gt; users will
              become blocked. (This is necessary to limit memory usage.)
              &lt;/p&gt;
              &lt;h3&gt;Discussion&lt;/h3&gt;
              &lt;p&gt;
              Say, for example, a scripted dictionary attack tries to guess a user's password. Using the configuration
              shown above, which is the default configuration if no &lt;i&gt;accountBlocker&lt;/i&gt; is declared, this results in
              5 guesses per 3600000 milliseconds; or equivalently 42720 guesses per year.
              &lt;/p&gt;
              &lt;p&gt;
              The probability of hitting a uniformly at random chosen word of the standard German vocabulary within
              one year is therefore about 56%.
              &lt;/p&gt;
              &lt;p&gt;
              Therefore, a more secure password should be chosen, containing letters, digits and special characters.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="clusters" type="com.predic8.membrane.core.config.spring.ClustersParser">
</xsd:element>
<xsd:element ref="elasticSearchExchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Used for storing exchanges in the Elasticsearch.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Elasticsearch 7 is required. Exchanges can be viewed in admin console and using standard Elasticsearch
              tools. Before writing, this class will check if index exists in current Elasticsearch instance. If index does not
              exist, it will create index and set up mapping for data types. If the existing index already have mapping this step
              will be skipped in order to not to overwrite existing mapping.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jmxExporter">
</xsd:element>
<xsd:element name="userInfo" type="com.predic8.membrane.core.config.spring.UserInfoParser">
</xsd:element>
<xsd:element ref="acmeHttpChallenge">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See the documentation of the &lt;code&gt;&lt;acme /&gt;&lt;/code&gt; element for usage details.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="jwtSessionManager" type="com.predic8.membrane.core.config.spring.XenAuthenticationjwtSessionManagerParser">
</xsd:element>
<xsd:element name="map" type="com.predic8.membrane.core.config.spring.LdapUserDataProvidermapParser">
</xsd:element>
<xsd:element ref="transform">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transform feature applies an XSLT transformation to the content in the body of a message. After the
              transformation the body content is replaced with the result of the transformation.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jSessionIdExtractor">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;jSessionIdExtractor&lt;/i&gt; extracts the JSESSIONID from a
              message and provides it to the {@link Balancer}.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="ldapUserDataProvider" type="com.predic8.membrane.core.config.spring.LdapUserDataProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; querying an LDAP server to authorize users and retrieve attributes.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The LDAP User Data Provider performs two jobs:
              &lt;ol&gt;
              &lt;li&gt;Authentication of a &lt;i&gt;username&lt;/i&gt; and &lt;i&gt;password&lt;/i&gt;.&lt;/li&gt;
              &lt;li&gt;Retrieval of user attributes.&lt;/li&gt;
              &lt;/ol&gt;
              &lt;/p&gt;
              &lt;p&gt;
              To achieve this, it first binds to &lt;i&gt;base&lt;/i&gt; on the LDAP server &lt;i&gt;url&lt;/i&gt;. If &lt;i&gt;binddn&lt;/i&gt; is not
              present, it binds to the LDAP server anonymously, elsewise &lt;i&gt;binddn&lt;/i&gt; and &lt;i&gt;bindpw&lt;/i&gt; are used for
              authentication.
              &lt;/p&gt;
              &lt;p&gt;
              Next, a search &lt;i&gt;searchPattern&lt;/i&gt; with scope &lt;i&gt;searchScope&lt;/i&gt; is executed where "&lt;tt&gt;%LOGIN%&lt;/tt&gt;"
              is replaced by the escaped version of the &lt;i&gt;username&lt;/i&gt;.
              &lt;/p&gt;
              &lt;p&gt;
              The search returning no node or more than one node is treated as failure.
              &lt;/p&gt;
              &lt;p&gt;
              If &lt;i&gt;passwordAttribute&lt;/i&gt; is set, and the node has an attribute with this name and this attribute's
              value starts with "&lt;tt&gt;{x-plain}&lt;/tt&gt;", the password is checked against the rest of the value for
              equality. If &lt;i&gt;passwordAttribute&lt;/i&gt; is not set, a second binding is attempted on the node using the
              &lt;i&gt;password&lt;/i&gt; the user provided.
              &lt;/p&gt;
              &lt;p&gt;
              The user attribute keys specified in the mapping are then renamed according to the mapping and used for
              further processing (see the other modules of the &lt;i&gt;login&lt;/i&gt; interceptor).
              &lt;/p&gt;
              &lt;p&gt;
              &lt;/p&gt;
              &lt;p&gt;
              For the initial binding, &lt;i&gt;connectTimeout&lt;/i&gt; can be used to specify a timeout in milliseconds. For the
              search, &lt;i&gt;timeout&lt;/i&gt; can be used.
              &lt;/p&gt;
              &lt;p&gt;
              If &lt;i&gt;readAttributesAsSelf&lt;/i&gt; is not set, the user attributes are collected from the search result. If
              it is set, an additional request is made after the second successful binding to retrieve the node's
              attributes.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="roundRobinStrategy">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Rewrites or redirects the path of incoming requests based on a mapping.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="map" type="com.predic8.membrane.core.config.spring.RewritermapParser">
</xsd:element>
<xsd:element ref="rest2Soap">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xenAuthentication">
</xsd:element>
<xsd:element ref="graphQLProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Check GraphQL-over-HTTP requests, enforcing several limits and/or restrictions. This effectively helps to reduce
 the attack surface.
 &lt;p&gt;
 GraphQL Specification "October2021" is used. (But GraphQL only covers formulation of Documents/Queries.)
 &lt;/p&gt;
 &lt;p&gt;
 GraphQL-over-HTTP, which specifies how to submit GraphQL queries via HTTP, has not been released/finalized yet. We
 therefore use Version
 &lt;a href="https://github.com/graphql/graphql-over-http/blob/a1e6d8ca248c9a19eb59a2eedd988c204909ee3f/spec/GraphQLOverHTTP.md"&gt;a1e6d8ca&lt;/a&gt;.
 &lt;/p&gt;
 &lt;p&gt;
 Only GraphQL documents conforming to the 'ExecutableDocument' of the grammar are allowed: This includes the usual
 'query', 'mutation', 'subscription' and 'fragment's.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="description" type="com.predic8.membrane.core.config.spring.DescriptionParser">
</xsd:element>
<xsd:element ref="redis">
</xsd:element>
<xsd:element name="keys" type="com.predic8.membrane.core.config.spring.KeysParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Stores api keys inline as XML.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="target" type="com.predic8.membrane.core.config.spring.SslProxytargetParser">
</xsd:element>
<xsd:element ref="soapOperationExtractor">
</xsd:element>
<xsd:element ref="staticClientList">
</xsd:element>
<xsd:element ref="balancer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="reverseProxying">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
 as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
 hostnames and ports used to access Membrane  vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="forgetfulExchangeStore">
</xsd:element>
<xsd:element ref="clamav">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Delegates virus checks to an external Virus Scanner.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="destination">
</xsd:element>
<xsd:element ref="requireAuth">
</xsd:element>
<xsd:element ref="azureIdentity">
</xsd:element>
<xsd:element name="github" type="com.predic8.membrane.core.config.spring.GithubParser">
</xsd:element>
<xsd:element name="secret" type="com.predic8.membrane.core.config.spring.SecretParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Contains api keys and scopes.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="nodeOnlineChecker">
</xsd:element>
<xsd:element ref="fileUserDataProvider">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; utilizing htpasswd formatted files.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              the &lt;i&gt;fileuserdataprovider&lt;/i&gt; can be used to source authentication data from htpasswd files.
              &lt;/p&gt;
              &lt;p&gt;
              The files can only utilize algorithm magic strings supported by &lt;i&gt;crypt(3)&lt;/i&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;request&gt; Element you can limit their application to requests only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="fileStore">
</xsd:element>
<xsd:element ref="limitedMemoryExchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Stores exchange objects in-memory until a memory threshold is reached. When the threshold is reached and
 new exchanges arrive then old exchanges will be dropped (starting from oldest ascending) until the exchange can be
 stored. The LimitedMemoryExchangeStore is the default ExchangeStore Membrane uses.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="cache">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Don't use, this does NOT implement valid HTTP caching.
              &lt;/p&gt;
              &lt;p&gt;
                  We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                  the Docker Registry for offline use.
                  The cache does not revalidate any responses, so machines querying the cache for Debian
                  package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                  This is - simply put - the only use case, where using this class makes any sense.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="routerIpResolver" type="com.predic8.membrane.core.config.spring.SslProxyrouterIpResolverParser">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsJDBC">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
 database (one row per exchange).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="index">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
              To use this feature just add a serviceProxy containing the index
              element. Of course you can protect the service proxy by using
              SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="router">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Membrane API Gateway's main object.
 &lt;/p&gt;
 &lt;p&gt;
 The router is a Spring Lifecycle object: It is automatically started and stopped according to the
 Lifecycle of the Spring Context containing it. In Membrane's standard setup (standalone or in a J2EE web
 app), Membrane itself controls the creation of the Spring Context and its Lifecycle.
 &lt;/p&gt;
 &lt;p&gt;
 In this case, the router is &lt;i&gt;hot deployable&lt;/i&gt;: It can monitor &lt;i&gt;proxies.xml&lt;/i&gt;, the Spring
 configuration file, for changes and reinitialize the Spring Context, when a change is detected. Note
 that, during the Spring Context restart, the router object itself along with almost all other Membrane
 objects (interceptors, etc.) will be recreated.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;wsdlPublisher&lt;/i&gt; serves WSDL files (and attached XML Schema Documents), if your
 backend service does not already do so.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="claim" type="com.predic8.membrane.core.config.spring.SupportedClaimsclaimParser">
</xsd:element>
<xsd:element ref="webServiceExplorer">
</xsd:element>
<xsd:element ref="logContext">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="private">
</xsd:element>
<xsd:element ref="apiKeyFileStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Loads api keys from a file. File has to be one key per line, blank lines for formatting are allowed. Optionally, a comma separated list of scopes after the key and a colon in between the two. Hash symbol can be used for comments at the end of each line, including empty lines.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; See: https://github.com/membrane/api-gateway/blob/master/distribution/examples/security/api-key/simple/demo-keys.txt&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="dnsOperator" type="com.predic8.membrane.core.config.spring.DnsOperatorParser">
</xsd:element>
<xsd:element name="authentication" type="com.predic8.membrane.core.config.spring.AuthenticationParser">
</xsd:element>
<xsd:element ref="APIsJSON">
</xsd:element>
<xsd:element ref="memcachedSessionManager">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="api">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The api proxy extends the serviceProxy with API related functions like OpenAPI support and path parameters.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ssl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="uriFactory">
</xsd:element>
<xsd:element ref="flowInitiator">
</xsd:element>
<xsd:element ref="counter">
</xsd:element>
<xsd:element ref="rateLimiter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;rateLimiter&lt;/i&gt; plugin limits the number of requests of a client in a period of time.
 As a default the client requests are grouped by client-Ip address and then counted. There are lots of
 possibilities to group the requests using the keyExpression. The requests can even be counted from different
 clients together.&lt;/p&gt;
 &lt;p&gt;When the gateway is located behind a loadbalancer then
 the client-Ip address is not the one from the client but the address from the balancer. To get the real Ip-address loadbalancers,
 &lt;i&gt;Web Application Firewalls&lt;/i&gt; and reverse proxies set the ip from the original client into the &lt;i&gt;X-Forwarded-For&lt;/i&gt; HTTP
 header field. The limiter plugin can take the Ip-address from the header.&lt;/p&gt;
 &lt;p&gt;
 The X-Forwarded-For header can only be trusted when a trustworthy reverse proxy or load balancer is between the client and server. The gateway not should be
 reachable directly. Only activate this feature when you know what you are doing.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="proxy" type="com.predic8.membrane.core.config.spring.ProxyconfigurationParser">
</xsd:element>
<xsd:element ref="call">
</xsd:element>
<xsd:element ref="certificate">
</xsd:element>
<xsd:element ref="oauth2Resource2">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
 authorization server as response.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsInterceptor">
</xsd:element>
<xsd:element ref="soapProxy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 A SOAP proxy automatically configures itself using a WSDL description. It reads the WSDL to extract:
 &lt;/p&gt;
 - The &lt;soap:address/&gt; for target, port, and path.
 &lt;p&gt;
 The proxy sits in front of a SOAP Web Service, masking it while providing the same interface to clients
 as the target server. The proxy serves the WSDL to gateway clients, with the WSDL address pointing to the proxy
 instead of the backend. This ensures that client requests using the WSDL are routed through the API Gateway.
 &lt;/p&gt;
 Additionally, the SOAP proxy:
 - Can validate requests against the WSDL
 - Provides a simple service explorer&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; If the WSDL specified by the &lt;i&gt;wsdl&lt;/i&gt; attribute is unavailable at startup, the &lt;soapProxy&gt;
 becomes inactive. Reinitialization can be triggered via the admin console or automatically by the
 {@link Router}, which periodically attempts to restore the proxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="inMemorySessionManager" type="com.predic8.membrane.core.config.spring.InMemorySessionManagerParser">
</xsd:element>
<xsd:element ref="inMemorySessionManager2">
</xsd:element>
<xsd:element ref="if">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The "if" interceptor supports conditional execution of nested plugins.
 &lt;/p&gt;
 See:
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorSpELTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorGroovyTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorJsonpathTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorXPathTest&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="byThreadStrategy">
</xsd:element>
<xsd:element ref="template">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders the body content of a message from a template. The template can
 produce plain text, Json or XML. Variables in the template are substituted with values from the body,
 header, query parameters, etc. If the extension of a referenced template file is &lt;i&gt;.xml&lt;/i&gt; it will use
 &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_xmltemplateengine"&gt;XMLTemplateEngine&lt;/a&gt;
 otherwise &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_streamingtemplateengine"&gt;StreamingTemplateEngine&lt;/a&gt;.
 Have a look at the samples in &lt;a href="https://github.com/membrane/service-proxy/tree/master/distribution/examples"&gt;examples/template&lt;/a&gt;.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="groovyTemplate">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Uses the groovy template markup engine to produce HTML-based responses.
 &lt;code&gt;
 &lt;groovyTemplate&gt;&lt;![CDATA[
   html {
     head {
       title('Resource')
     }
     body {
       p('Hello from Membrane!')
     }
   }
 ]]&gt;&lt;/groovyTemplate&gt;
 &lt;/code&gt;
 &lt;p&gt;
 The word "spring" refers to the Spring ApplicationContext.
 The word "exc" refers to the Membrane Exchange being handled.
 The word "flow" refers to the current Membrane Flow (=REQUEST).
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessLog">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes exchange metrics into a Log4j appender&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Defaults to Apache Common Log pattern&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="field" type="com.predic8.membrane.core.config.spring.FormValidationfieldParser">
</xsd:element>
<xsd:element ref="prometheus">
</xsd:element>
<xsd:element name="gatekeeper" type="com.predic8.membrane.core.config.spring.SslProxygatekeeperParser">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wadlRewriter">
</xsd:element>
<xsd:element name="jwk" type="com.predic8.membrane.core.config.spring.BearerJwtTokenjwkParser">
</xsd:element>
<xsd:element name="memoryStorage" type="com.predic8.membrane.core.config.spring.MemoryStorageParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; For testing purposes only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="cachingUserDataProvider" type="com.predic8.membrane.core.config.spring.CachingUserDataProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Caching User Data provider caches previous successful logins in order to make authentication faster&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="rewrite" type="com.predic8.membrane.core.config.spring.RewriteParser">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="openTelemetry">
</xsd:element>
<xsd:element ref="httpSchemaResolver">
</xsd:element>
<xsd:element ref="limit">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Note that due to the streaming nature of Membrane, a request header may already have been passed on to
              the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
              aborted and the connection to the backend is simply closed.
              &lt;/p&gt;
              &lt;p&gt;
              To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
              &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="basicAuthentication">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="json2Xml">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts body payload from JSON to XML. The JSON must be an object other JSON documents e.g. arrays are not supported.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Resulting XML will be in UTF-8 encoding.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shutdown">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Shutdown interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                  Adds the ability to shutdown main router thread via an HTTP request.
                  Don't forget to setup security for this interceptor.
              &lt;/p&gt;
              &lt;p&gt;
                  Has undefined behavior when Membrane is &lt;b&gt;not&lt;/b&gt; started from command line
                  (=via the RouterCLI class, which &lt;tt&gt;service-proxy.ps1&lt;/tt&gt;/&lt;tt&gt;service-proxy.sh&lt;/tt&gt;
                  do use).
              &lt;/p&gt;
              &lt;p&gt;
                  Only actually terminates the running JVM, when used in the first
                  &lt;tt&gt;&lt;router&gt;&lt;/tt&gt; bean (which implicitly stands for
                  &lt;tt&gt;&lt;router id="router"&gt;&lt;/tt&gt;) called "router".
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="databaseApiKeyStore" type="com.predic8.membrane.core.config.spring.DatabaseApiKeyStoreParser">
</xsd:element>
<xsd:element ref="userFeature">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="proxy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Clients can send HTTP requests to a proxy that forward the request to a Web server. It acts on behalf of the client.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="include">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Contains a Java regex for &lt;i&gt;including&lt;/i&gt; message headers.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="node" type="com.predic8.membrane.core.config.spring.NodeParser">
</xsd:element>
<xsd:element ref="keyGenerator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Experimental.
 &lt;p&gt;Allows to dynamically generate keys/certificates for arbitrary domain names on the fly, signed by a specified
 root CA key.&lt;/p&gt;
 &lt;p&gt;This is an alternative for {@link Key} and {@link KeyStore}.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapStackTraceFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
              advised to test its functionality in combination with your SOAP service provider before deploying it in
              production.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="case" type="com.predic8.membrane.core.config.spring.CaseParser">
</xsd:element>
<xsd:element ref="refresh">
</xsd:element>
<xsd:element name="kubernetesStorage" type="com.predic8.membrane.core.config.spring.KubernetesStorageParser">
</xsd:element>
<xsd:element name="emailTokenProvider" type="com.predic8.membrane.core.config.spring.EmailTokenProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;emailTokenProvider&lt;/i&gt; randomly generates a 6-digit token after the user entered her correct
              password.
              &lt;/p&gt;
              &lt;p&gt;
              The token is then sent to the user via email. The user's attribute &lt;i&gt;email&lt;/i&gt; is used as the
              recipient email address. If this attribute has not been provided by the &lt;i&gt;user data provider&lt;/i&gt;, the
              login attempt fails.
              &lt;/p&gt;
              &lt;p&gt;
              The email is sent using the SMTP protocol via the &lt;i&gt;smtpHost&lt;/i&gt;. Optionally, &lt;i&gt;ssl&lt;/i&gt; and &lt;i&gt;smptPort&lt;/i&gt; can
              be set to configure the type of connection. Optionally, &lt;i&gt;smtpUser&lt;/i&gt; and &lt;i&gt;smtpPassword&lt;/i&gt; can be used to
              use sender authentification.
              &lt;/p&gt;
              &lt;p&gt;
              The email is assembled using &lt;i&gt;sender&lt;/i&gt;, &lt;i&gt;recipient&lt;/i&gt;, &lt;i&gt;subject&lt;/i&gt; and &lt;i&gt;body&lt;/i&gt;. All of these values
              may contain properties in the form of &lt;tt&gt;${propertyname}&lt;/tt&gt;.
              &lt;/p&gt;
              &lt;p&gt;
              The properties will be replaced by the corresponding user attributes set by the &lt;i&gt;user data provider&lt;/i&gt;, or &lt;tt&gt;token&lt;/tt&gt;
              will be replaced by the numeric token value.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;token provider&lt;/i&gt; sending a randomly generated numeric token
              to the user via email.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="formValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiDocs">
</xsd:element>
<xsd:element ref="stompProxy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Proxies incoming STOMP CONNECT requests. Use a &lt;stompClient&gt; to forward these requests so some other machine.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="choose">
</xsd:element>
<xsd:element ref="redisSessionManager">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="testService">
</xsd:element>
<xsd:element ref="soap2Rest">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clusterNotification">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane API Gateway distribution.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="additionalVariable" type="com.predic8.membrane.core.config.spring.AccessLogscopeParser">
</xsd:element>
<xsd:element ref="setHeader">
</xsd:element>
<xsd:element name="path" type="com.predic8.membrane.core.config.spring.PathParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The value of the content will be taken to match the path.
              &lt;/p&gt;

              &lt;p&gt;
              If &lt;tt&gt;isRegExp="true"&lt;/tt&gt;, the whole path has to match the given regular expression. If
              &lt;tt&gt;isRegExp="false"&lt;/tt&gt;, the path has to start with the given string.
              &lt;/p&gt;

              &lt;p&gt;
              If &lt;tt&gt;&lt;path /&gt;&lt;/tt&gt; is a child element of a &lt;tt&gt;&lt;soapProxy /&gt;&lt;/tt&gt;, the &lt;tt&gt;isRegExp&lt;/tt&gt;
              attribute must not be present.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="groovy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Groovy script. The script can access and manipulate data from the request and response.
 Use this or the Javascript plugin to extend the functions of Membrane by scripting.
 See: example/groovy for working samples&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="scope" type="com.predic8.membrane.core.config.spring.ClaimsscopeParser">
</xsd:element>
<xsd:element ref="httpClientConfig">
</xsd:element>
<xsd:element ref="jwtSign">
</xsd:element>
<xsd:element ref="jwks">
</xsd:element>
<xsd:element ref="statisticsProvider">
</xsd:element>
<xsd:element ref="replace">
</xsd:element>
<xsd:element ref="claims">
</xsd:element>
<xsd:element ref="methodOverride">
</xsd:element>
<xsd:element ref="memcached">
</xsd:element>
<xsd:element ref="loginParameter">
</xsd:element>
<xsd:element ref="stompClient">
</xsd:element>
<xsd:element ref="webSocket">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
 attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="log">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages. The messages will appear either on the console or in
 a log file depending on the log configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="bearerJwtToken">
</xsd:element>
<xsd:element ref="faultMonitoringStrategy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Monitors the outcome of requests to each node to quickly disable/re-enable faulty ones.

 &lt;h2&gt;WHY THIS CLASS&lt;/h2&gt;
 &lt;p&gt;This is a drop-in replacement for the default {@link RoundRobinStrategy}. In fact, as long as all nodes
 respond correctly, it works the same. Things only start changing once nodes fail.
 Whereas the RoundRobin keeps dispatching to faulty nodes, causing delays for the service user, this
 strategy detects the issue and favours functional nodes.
 &lt;/p&gt;

 &lt;h2&gt;FORECAST PREDICTION USING "PERSISTENCE METHOD"&lt;/h2&gt;
 &lt;p&gt;Predicting tomorrow's weather by saying it will be equal to today's works well in many areas of the
 world. Similarly, predicting that another service request to a node will succeed after a success, or fail
 after a failure, is very likely.
 That's the main concept behind the logic and algorithm used within this class.
 &lt;/p&gt;

 &lt;h2&gt;HOW IT WORKS&lt;/h2&gt;
 &lt;p&gt;Once a node returns with a failure, a fault profile for that node is created. The node is instantly
 considered to be faulty. From then on, all status (success/failure) of that node is monitored.
 If enough successive calls are successful, the node is cleared from its bad reputation.
 If the node is not used anymore (either not requests at all, or none to that node because it's
 faulty and there are enough good nodes) then the node is cleared from its bad reputation after
 a configurable amount of time.
 When there are enough functional nodes (configurable ratio), only the functional ones are used
 with the simplistic round-robin strategy. If not, then all nodes are used, and the selection is a
 weighted chance operation by recent success rate.
 &lt;/p&gt;

 &lt;h2&gt;WHAT IS A FAULT&lt;/h2&gt;
 &lt;p&gt;A fault is when the destination replied with a valid 5xx HTTP status code, or when an exception
 (such as a ConnectException) was thrown. Everything else, including 4xx codes, is considered a success.&lt;/p&gt;

 &lt;h2&gt;PER NODE, NOT PER DESTINATION&lt;/h2&gt;
 &lt;p&gt;Success status could be monitored per node (host/port) or per destination (host/port/servicename).
 In practice, most failures affect all services. Rarely only one service on a node is faulty, but it's
 also very possible. This implementation currently monitors per node. This is for technical reasons,
 per destination is currently not possible with the information that is present. If it was available,
 I'm not sure which one is better to choose. Maybe configurable would be nice.
 If monitoring happens per destination, and one service is detected to be faulty, but in fact the
 whole node is down, this information will then not be freely available for the other destinations...
 they have to figure it out independently. Unless some more complicated functionality is built in.
 &lt;/p&gt;

 &lt;h2&gt;GOALS OF THIS CLASS&lt;/h2&gt;
 &lt;p&gt;Simple super-fast, super-low memory use. The goal is to provide a great service experience to the api
 user. Over-complicating things in here and introducing possible bugs or bottlenecks must be avoided.
 &lt;/p&gt;

 &lt;h2&gt;WHAT IT'S NOT&lt;/h2&gt;
 &lt;p&gt;It does not do response time monitoring to identify slow/laggy servers, or to favour faster ones.
 There can be different kinds of services on the same hosts, simple and complex expensive ones,
 and we don't have that kind of information here. Another similar DispatchingStrategy could do
 such logic.
 &lt;/p&gt;

 &lt;h2&gt;LIMITATIONS&lt;/h2&gt;
 &lt;p&gt;No background checking of faulty nodes.
 For certain kinds of failures, including ConnectException and UnknownHostException, a background service
 could keep checking a faulty node, and only re-enable it once that works again.
 For other cases, there could be a pluggable BackgroundUptimeCheck interface. This would allow a
 service implementor to write his own check that fits his needs. For example by sending a real
 service request that does not harm.
 Automatic background retry of previous failed requests to see if the service is back online is a bad
 idea... think payment service.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="trust">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Allows to insert one or more PEM blocks containing the certificates to be trusted directly into the proxies.xml
 file.&lt;/p&gt;
 &lt;p&gt;This is an alternative for {@link TrustStore}.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="return">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Terminates the exchange flow. The returned response is determined in the following order:
 &lt;p&gt;
 1. If there is already a response in the exchange, that response is returned
 2. If there is no response in the exchange, the body and contentType of the request is copied into a new response.
 &lt;/p&gt;
 &lt;p&gt;
 The options statusCode and contentType will overwrite the values from the messages.
 &lt;/p&gt;
 &lt;p&gt;
 This plugin is useful together with the template plugin. See examples/template.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="memcachedOriginalExchangeStore">
</xsd:element>
<xsd:element ref="statisticsCSV">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
              file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="transport">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transport receives messages from clients and invokes interceptors in the request and response flow.
              The interceptors that are engaged with the transport are global and are invoked for each message flowing
              through the router.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="client" type="com.predic8.membrane.core.config.spring.StaticClientListclientParser">
</xsd:element>
<xsd:element ref="openapiValidator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Validator for OpenAPI documents&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="internal">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Internal proxy that can only be invoked by other proxies within the gateway. An internal
 proxy does not listen on any port.&lt;/p&gt;
 &lt;p&gt;Internal proxies are useful to better structure the configuration of the gateway.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="openapi" type="com.predic8.membrane.core.config.spring.OpenapiParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Reads an OpenAPI description and deploys an API with the information of it.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accountRegistration">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="defaultConfig">
</xsd:element>
<xsd:element ref="membrane">
</xsd:element>
<xsd:element ref="fileExchangeStore">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="cluster" type="com.predic8.membrane.core.config.spring.ClusterParser">
</xsd:element>
<xsd:element ref="keyTable">
</xsd:element>
<xsd:element name="whateverMobileSMSTokenProvider" type="com.predic8.membrane.core.config.spring.WhateverMobileSMSTokenProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;whateverMobileSMSTokenProvider&lt;/i&gt; randomly generates a
              6-digit token after the user entered her correct password.
              &lt;/p&gt;
              &lt;p&gt;
              The token is then sent to the user via text message. The user's
              attribute &lt;i&gt;sms&lt;/i&gt; is used as the recipient phone number. If
              this attribute has not been provided by the &lt;i&gt;user data
              provider&lt;/i&gt;, the login attempt fails.
              &lt;/p&gt;
              &lt;p&gt;
              The text message is sent via &lt;a
              href="https://whatevermobile.com/"&gt;WhateverMobile&lt;/a&gt; REST API.
              To use this API, a registered user account with sufficient
              balance is necessary. Membrane uses the specified user name and
              password to identify itself when connecting to the
              WhateverMobile SMS Gateway.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;token provider&lt;/i&gt; using &lt;i&gt;&lt;a
              href="https://whatevermobile.com/"&gt;WhateverMobile&lt;/a&gt;'s&lt;/i&gt; REST
              interface to send a randomly generated numeric token to the
              user's phone via text message.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="kubernetesValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Kubernetes Integration is still experimental.
 &lt;p&gt;
 To create the CustomResourceDefinitions, apply kubernetes-config.yaml from
 core/target/classes/com/predic8/membrane/core/config/kubernetes/ or a part (e.g. the 'serviceproxies' CRD) of the file.
 &lt;/p&gt;
 &lt;p&gt;
 Create a key and certificate for TLS for &lt;a href="https://membrane-validator.membrane-soa.svc:444/"&gt;https://membrane-validator.membrane-soa.svc:444/&lt;/a&gt; and setup Membrane to serve
 this address. The configuration shown below configures Membrane on a fixed IP address outside of the Kubernetes cluster,
 but this is no requirement.
 &lt;/p&gt;
 &lt;p&gt;
 Embed the following serviceProxy and adjust the 'resources' attribute to a comma-separated list of CRDs that you applied.
 Note that while the CRDs have plural names, here you need to use the corresponding singular. Configure the "ssl" section
 using your key and certificate.
 &lt;/p&gt;
 &lt;code&gt;
 &gt;serviceProxy port="444"&gt;
 &gt;ssl&gt;
 &gt;key&gt;
 &gt;private&gt;
 -----BEGIN RSA PRIVATE KEY-----
 ...
 -----END RSA PRIVATE KEY-----
 &gt;/private&gt;
 &gt;certificate&gt;
 -----BEGIN CERTIFICATE-----
 ...
 -----END CERTIFICATE-----
 &gt;/certificate&gt;
 &gt;/key&gt;
 &gt;/ssl&gt;
 &gt;kubernetesValidation resources="serviceproxy" /&gt;
 &gt;/serviceProxy&gt;
 &lt;/code&gt;
 &lt;p&gt;
 Now register a Webhook to validate the new CRDs. (A note to the experts: Membrane's validation schemas are too
 complex to fit into the CRD, because they are highly nestable and self-referencing. We therefore use webhooks.)
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: admissionregistration.k8s.io/v1
 kind: ValidatingWebhookConfiguration
 metadata:
 name: membrane
 webhooks:
 - name: membrane.membrane-soa.org
 admissionReviewVersions: ["v1", "v1beta1"]
 failurePolicy: Fail
 rules:
 - operations: [ "*" ]
 apiGroups: [ "membrane-soa.org" ]
 apiVersions: [ "v1", "v1beta1" ]
 resources: [ "*" ]
 scope: "*"
 clientConfig:
 service:
 name: membrane-validator
 namespace: membrane-soa
 port: 444
 caBundle: LS0t...LQ0K        # base64 encoded, PEM-formatted CA certificate
 sideEffects: None
 ---
 apiVersion: v1
 kind: Namespace
 metadata:
 name: membrane-soa
 ---
 apiVersion: v1
 kind: Service
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 spec:
 ports:
 - port: 444
 ---
 apiVersion: v1
 kind: Endpoints
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 subsets:
 - addresses:
 - ip: 192.168.0.1   # Membrane's IP
 ports:
 - port: 444
 &lt;/code&gt;
 &lt;p&gt;
 Once this setup is complete, you can enable serviceProxies like this:
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: membrane-soa.org/v1beta1
 kind: serviceproxy
 metadata:
 name: demo
 namespace: membrane-soa
 spec:
 host: demo.predic8.de
 path:
 value: /some-path/
 interceptors:
 - response:
 interceptors:
 - groovy:
 src: |
 println "Hello!"
 target:
 host: thomas-bayer.com
 &lt;/code&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setProperty">
</xsd:element>
<xsd:element ref="javascript">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Javascript. The script can access and manipulate data from the request and response.
 Use this or the Groovy plugin to extend the functions of Membrane by scripting. See the samples in examples/javascript.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="google" type="com.predic8.membrane.core.config.spring.GoogleParser">
</xsd:element>
<xsd:element ref="paddingHeader">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsLog">
</xsd:element>
<xsd:element ref="greaser">
</xsd:element>
<xsd:element ref="soapBody">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders a SOAP body for legacy intergration&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="azureTableStorage" type="com.predic8.membrane.core.config.spring.AzureTableStorageParser">
</xsd:element>
<xsd:element name="Otherwise" type="com.predic8.membrane.core.config.spring.OtherwiseParser">
</xsd:element>
<xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;response&gt; plugin you can limit their application to responses only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="throttle">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The throttle feature can slow down traffic to thwart denial of service attacks.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="redisOriginalExchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Used for storing exchanges temporarily in Redis. Supports authentication with or without password and username&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtSessionManager">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlContentFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
 using an XPath expression.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
 match a message at all. This can improve performance significantly, as a DOM tree does probably not have
 to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
 lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
 namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
 &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
 the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
 constructed.
 &lt;/p&gt;
 &lt;p&gt;
 If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
 XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
 modified reconstituted message.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="headerFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
 The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="key">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Experimental.
 &lt;p&gt;Allows to insert a PEM block containing the key (as well as one or more blocks for the
 certificate(s)) directly into the proxies.xml file.&lt;/p&gt;
 &lt;p&gt;This is an alternative for {@link KeyStore}.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="cookieOriginalExchangeStore">
</xsd:element>
<xsd:element ref="ntlm">
</xsd:element>
<xsd:element ref="login">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
              application.
              &lt;/p&gt;
              &lt;p&gt;
              Users firstly have to authenticate themselves against a directory server using a username and password.
              Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
              token verification, access to the web application is granted for the user's session. Single Sign On can
              easily be realized using a small source code extension or modification of a web application.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
              each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
              default implementations.)
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
              cell phone number, Single Sign On data, etc.).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
              session cookie).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
              attempts for a specified amount of time.
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
              secondary channel like text messaging).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;/ul&gt;
              &lt;p&gt;
              &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
              title="login interceptor workflow"/&gt;
              &lt;/p&gt;
              &lt;p&gt;
              (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
              possible.)
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
              valid, the workflow is as follows:
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
              &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
              &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
              used. Steps 5 and 6.)&lt;/li&gt;
              &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
              &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
              was directly requested). (Step 8.)&lt;/li&gt;
              &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="sampleSoapService">
</xsd:element>
<xsd:element ref="sessionOriginalExchangeStore">
</xsd:element>
<xsd:element ref="analyser">
</xsd:element>
<xsd:element name="scope" type="com.predic8.membrane.core.config.spring.ScopeParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Contains a scope for use in &lt;secret value="..."&gt;...&lt;/secret&gt; elements.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="validator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlRewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="sessionManager" type="com.predic8.membrane.core.config.spring.SessionManagerParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The Session Manager identifies users across HTTP requests using a session cookie.
              &lt;/p&gt;
              &lt;p&gt;
              The name of the session cookie can be specified using the &lt;i&gt;cookieName&lt;/i&gt; attribute. The default name
              is "&lt;tt&gt;SESSIONID&lt;/tt&gt;".
              &lt;/p&gt;
              &lt;p&gt;
              The session timeout can be specified in milliseconds using the &lt;i&gt;timeout&lt;/i&gt; attribute. The default
              timeout is 5 minutes.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="emptyTokenProvider" type="com.predic8.membrane.core.config.spring.EmptyTokenProviderParser">
</xsd:element>
<xsd:element ref="scopeTable">
</xsd:element>
<xsd:element ref="regExReplacer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="abort" type="com.predic8.membrane.core.config.spring.AbortParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Plugins are usually applied to requests and responses.
 In case of errors, the flow returns and &lt;i&gt;handleAbort()&lt;/i&gt; is called on plugins
 going back the chain.
 By nesting plugins into an &lt;abort&gt; you can limit their application to abort flows only.
 On plugins nested in &lt;abort&gt; handleResponse() is called not handleAbort() in order to
 allow normal processing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiKey">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Secures APIs by validating keys stored in either files or proxies.xml. Keys can be received from clients via HTTP headers or URL query parameters. Additional permission checks are possible through scope validation - scopes are loaded into an Exchange property and can be checked using the "hasScope()" SpEL function.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="oauth2authserver">
</xsd:element>
<xsd:element ref="bearerToken">
</xsd:element>
<xsd:element name="telekomSMSTokenProvider" type="com.predic8.membrane.core.config.spring.TelekomSMSTokenProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; randomly generates a 6-digit token after the user entered her correct
              password.
              &lt;/p&gt;
              &lt;p&gt;
              The token is then sent to the user via text message. The user's attribute &lt;i&gt;sms&lt;/i&gt; is used as the
              recipient phone number. If this attribute has not been provided by the &lt;i&gt;user data provider&lt;/i&gt;, the
              login attempt fails.
              &lt;/p&gt;
              &lt;p&gt;
              The text message is sent via &lt;a href="http://www.developergarden.com/"&gt;Deutsche Telekom's developer
              garden&lt;/a&gt; REST API. To use this API, a registered user account with sufficient balance is necessary and
              the &lt;i&gt;Send SMS&lt;/i&gt; API has to be enabled for this account. Membrane API Gateway must be registered as an
              "application" on the developer garden website, and the "Global SMS API" must be enabled both for the user account
              as well as the registered application. Once completed, the &lt;i&gt;scope&lt;/i&gt;, &lt;i&gt;clientId&lt;/i&gt; and &lt;i&gt;clientSecret&lt;/i&gt;
              settings must be copied from the website into Membrane's proxies.xml configuration file. Membrane uses these three
              parameters to identify itself when connecting to the Telekom API Gateway.
              &lt;/p&gt;
              &lt;p&gt;
              When using a non-standard &lt;i&gt;environment&lt;/i&gt; (see https://www.developergarden.com/apis/documentation/bundle/telekom-api-rest/html/sendsms.html#environmental_infos for more information),
              the parameters &lt;i&gt;senderName&lt;/i&gt; and &lt;i&gt;senderAddress&lt;/i&gt; may be used to set the SMS sender address and name.
              &lt;/p&gt;
              &lt;p&gt;
              The token is prepended by &lt;i&gt;prefixText&lt;/i&gt; to generate the text message's text.
              &lt;/p&gt;
              &lt;p&gt;
              If &lt;i&gt;normalizeTelephoneNumber&lt;/i&gt; is set, the user's &lt;i&gt;sms&lt;/i&gt; attribute will be normalized according
              to the following rules before using it:
              &lt;ul&gt;
              &lt;li&gt;'&lt;tt&gt;+&lt;/tt&gt;' is replaced by '&lt;tt&gt;00&lt;/tt&gt;'.&lt;/li&gt;
              &lt;li&gt;Any characters within round brackets, '&lt;tt&gt;(&lt;/tt&gt;' and '&lt;tt&gt;)&lt;/tt&gt;', are removed.&lt;/li&gt;
              &lt;li&gt;'&lt;tt&gt;-&lt;/tt&gt;' and '&lt;tt&gt;&#160;&lt;/tt&gt;' are removed.&lt;/li&gt;
              &lt;/ul&gt;
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;token provider&lt;/i&gt; using &lt;i&gt;Deutsche Telekom's&lt;/i&gt; REST interface &lt;a
              href="http://www.developergarden.com/"&gt;developer garden&lt;/a&gt; to send a randomly generated numeric token
              to the user via text message.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="customStatementJdbcUserDataProvider">
</xsd:element>
<xsd:element ref="adminConsole">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="exclude">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Contains a Java regex for &lt;i&gt;excluding&lt;/i&gt; message headers.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtSessionManager2">
</xsd:element>
<xsd:element name="totpTokenProvider" type="com.predic8.membrane.core.config.spring.TotpTokenProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;token provider&lt;/i&gt; using the Time-based One-time Password (TOTP) algorithm specified in RFC 6238 to
              verify tokens using a pre-shared secret.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;totpTokenProvider&lt;/i&gt; uses the Time-based One-time Password (TOTP) algorithm specified in &lt;a
              href="http://tools.ietf.org/html/rfc6238"&gt;RFC 6238&lt;/a&gt; to verify tokens using a pre-shared secret.
              &lt;/p&gt;
              &lt;p&gt;
              The tokens consist of 6 digits.
              &lt;/p&gt;
              &lt;p&gt;
              The user's attribute &lt;i&gt;secret&lt;/i&gt; is used as the pre-shared secret. If this attribute is missing, the
              login attempt fails.
              &lt;/p&gt;
              &lt;p&gt;
              Note that the server's system time is taken into account when verifying tokens.
              &lt;/p&gt;
              &lt;p&gt;
              It is possible, for example, to use the &lt;a href="http://code.google.com/p/google-authenticator"&gt;Google
              Authenticator App&lt;/a&gt; to store the pre-shared secret and generate such tokens.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="urlNormalizer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Replaces "/./" in the request URI's path by "/".
              &lt;/p&gt;
              &lt;p&gt;
              Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
              links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
              root). The SOA model then combines "&lt;a href="http://foo/material/ArticleService?wsdl"&gt;http://foo/material/ArticleService?wsdl&lt;/a&gt;" and
              "./ArticleService?xsd=1" to "&lt;a href="http://foo/material/./ArticleService?xsd=1"&gt;http://foo/material/./ArticleService?xsd=1&lt;/a&gt;". This URI is sent to Membrane's
              new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
              not match.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ruleMatching">
</xsd:element>
<xsd:element name="otlpExporter" type="com.predic8.membrane.core.config.spring.OtlpExporterParser">
</xsd:element>
<xsd:element name="addHeader" type="com.predic8.membrane.core.config.spring.AddHeaderParser">
</xsd:element>
<xsd:element ref="truststore">
</xsd:element>
<xsd:element ref="oauth2PermissionChecker">
</xsd:element>
<xsd:element name="azureDns" type="com.predic8.membrane.core.config.spring.AzureDnsParser">
</xsd:element>
<xsd:element name="unifyingUserDataProvider" type="com.predic8.membrane.core.config.spring.UnifyingUserDataProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;unifyingUserDataProvider&lt;/i&gt; can be used to merge two or more other &lt;i&gt;user data providers&lt;/i&gt;
              into one.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;unifyingUserDataProvider&lt;/i&gt; will forward a login attempt (username and password) to each inner
              user data provider in the order they are specified. After one of the inner user data providers returned
              a successful login (and returned the user's attributes), the procedure terminates. If no inner user data
              provider could verify the user, the login attempt fails.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="for">
</xsd:element>
<xsd:element name="mapping" type="com.predic8.membrane.core.config.spring.Rest2SoapmappingParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="staticUserDataProvider">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; listing all user data in-place in the config file.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              the &lt;i&gt;staticuserdataprovider&lt;/i&gt; can be used to statically list user data within the config file.
              &lt;/p&gt;
              &lt;p&gt;
              each user must have a unique &lt;i&gt;username&lt;/i&gt; attribute as well as a &lt;i&gt;password&lt;/i&gt; attribute.
              &lt;/p&gt;
              &lt;p&gt;
              arbitrary attributes can be set on a user element. other sub-components of the &lt;i&gt;login&lt;/i&gt; interceptor
              might use those: for example, the &lt;i&gt;telekomsmstokenprovider&lt;/i&gt; uses the &lt;i&gt;sms&lt;/i&gt; property as the
              user's cell phone number. for example, the &lt;i&gt;totptokenprovider&lt;/i&gt; uses the &lt;i&gt;secret&lt;/i&gt; property to
              initialize the token sequence.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element name="user" type="com.predic8.membrane.core.config.spring.StaticUserDataProvideruserParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="dispatching">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
 element to the list of destinations of the exchange object. It
 must be placed into the transport to make Service Proxies Work
 properly. It has to be placed after the ruleMatching
 interceptor. The ruleMatching interceptor looks up a service
 proxy for an incoming request and places it into the exchange
 object. The dispatching interceptor needs the service proxy to
 get information about the target.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.AttributeParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="from" type="xsd:string" use="required">
</xsd:attribute>
<xsd:attribute name="to" type="xsd:string" use="required">
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="shadowing">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
<xsd:element name="target" type="com.predic8.membrane.core.config.spring.TargetParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The destination where the service proxy will send messages to. Use the target element, if you want
 to send the messages to a static target. If you want to use dynamic destinations have a look at the
 &lt;a href="https://membrane-soa.org/service-proxy-doc/configuration/reference/router.htm"&gt;content based router&lt;/a&gt;.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="acme">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures an ACME (RFC 8555) client, e.g. to retrieve TLS certificates from
 &lt;a href="https://letsencrypt.org/"&gt;Let's Encrypt&lt;/a&gt;.&lt;/p&gt;
 &lt;p&gt;To store the key material and certificates, you can use the local file system or your Kubernetes cluster.&lt;/p&gt;
 &lt;p&gt;
     To use ACME:
     &lt;ol&gt;
         &lt;li&gt;Register your domain and point the DNS record to your server(s) runnig Membrane.&lt;/li&gt;
         &lt;li&gt;Let Membrane listen on port 80 and use the &lt;code&gt;&lt;acmeHttpChallenge /&gt;&lt;/code&gt; (see below).&lt;/li&gt;
         &lt;li&gt;Let Membrane listen on port 443 and use &lt;code&gt;&lt;ssl&gt;&lt;acme .../&gt;&lt;ssl&gt;&lt;/code&gt; (see below).
         Here, you have to configure where Membrane will store the keys and certificates.
         &lt;/li&gt;
     &lt;/ol&gt;
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element name="fileStorage" type="com.predic8.membrane.core.config.spring.FileStorageParser">
</xsd:element>
<xsd:element name="memoryStorage" type="com.predic8.membrane.core.config.spring.MemoryStorageParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; For testing purposes only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="kubernetesStorage" type="com.predic8.membrane.core.config.spring.KubernetesStorageParser">
</xsd:element>
<xsd:element name="azureTableStorage" type="com.predic8.membrane.core.config.spring.AzureTableStorageParser">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element ref="httpClientConfig">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element name="dnsOperator" type="com.predic8.membrane.core.config.spring.DnsOperatorParser">
</xsd:element>
<xsd:element name="azureDns" type="com.predic8.membrane.core.config.spring.AzureDnsParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="directoryUrl" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="termsOfServiceAgreed" type="spel_boolean" >
</xsd:attribute>
<xsd:attribute name="contacts" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; mailto:webmaster&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="validity" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; PT7D&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="experimental" type="spel_boolean" >
</xsd:attribute>
<xsd:attribute name="hosts" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="renewal" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; When to renew the certificate. Can be "1/3" (meaning that the certificate will be renewed when 1/3 of the
 validity period is left) or "never" (meaning that renewal will never be attempted). If you choose "never",
 someone else should take care of renewing the key and certificate and update the storage accordingly.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 1/3&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="retry" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Number of milliseconds after which a retry should be attempted. (in case of any error, e.g. in case the
 ACME server cannot be reached or validation failed.)&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 10000&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.FileStorageParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="dir" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:complexType name="com.predic8.membrane.core.config.spring.HeaderExtractorParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="name" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="headerJwtRetriever">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="header" type="xsd:string" use="required">
</xsd:attribute>
<xsd:attribute name="removeFromValue" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.HeaderRetrieverParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="user" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="pass" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="domain" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="workstation" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="registration">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element ref="ssl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element ref="httpClient">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
 Server using the HTTP protocol. Usually it will be globally used
 inside the transport. However, it is also possible to use it
 inside a proxy to give the proxy an individual configuration for
 its outgoing HTTP connection that is different from the global
 configuration in the transport.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtAuth">
</xsd:element>
<xsd:element ref="interceptor">
</xsd:element>
<xsd:element ref="tcp">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="tokenValidator">
</xsd:element>
<xsd:element ref="beautifier">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Beautifies request and response bodies. Supported are the Formats: JSON, XML&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="static">
</xsd:element>
<xsd:element ref="jsonProtection">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="http2xml">
</xsd:element>
<xsd:element name="echo" type="com.predic8.membrane.core.config.spring.EchoParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Returns the flow of plugins and copies the content of the
 request into a new response. The response has a status code of 200.
 Useful for testing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xml2Json">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If enabled converts body content from xml to json.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Can be used for both request and response. Xml file assumed to be in UTF-8. If input is invalid it returns
 empty json object.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="authHead2Body">
</xsd:element>
<xsd:element ref="webServer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
 "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
 &lt;/p&gt;
 &lt;p&gt;
 The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
 HTTP response with the contents of a file, or a "404 Not Found." error.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="internalRouting">
</xsd:element>
<xsd:element ref="exchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
              might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="dispatching">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
 element to the list of destinations of the exchange object. It
 must be placed into the transport to make Service Proxies Work
 properly. It has to be placed after the ruleMatching
 interceptor. The ruleMatching interceptor looks up a service
 proxy for an incoming request and places it into the exchange
 object. The dispatching interceptor needs the service proxy to
 get information about the target.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shadowing">
</xsd:element>
<xsd:element ref="openapiPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;openapiPublisher&lt;/i&gt; serves OpenAPI documents
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessControl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
              requested resource.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="acmeHttpChallenge">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See the documentation of the &lt;code&gt;&lt;acme /&gt;&lt;/code&gt; element for usage details.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="transform">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transform feature applies an XSLT transformation to the content in the body of a message. After the
              transformation the body content is replaced with the result of the transformation.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Rewrites or redirects the path of incoming requests based on a mapping.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rest2Soap">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xenAuthentication">
</xsd:element>
<xsd:element ref="graphQLProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Check GraphQL-over-HTTP requests, enforcing several limits and/or restrictions. This effectively helps to reduce
 the attack surface.
 &lt;p&gt;
 GraphQL Specification "October2021" is used. (But GraphQL only covers formulation of Documents/Queries.)
 &lt;/p&gt;
 &lt;p&gt;
 GraphQL-over-HTTP, which specifies how to submit GraphQL queries via HTTP, has not been released/finalized yet. We
 therefore use Version
 &lt;a href="https://github.com/graphql/graphql-over-http/blob/a1e6d8ca248c9a19eb59a2eedd988c204909ee3f/spec/GraphQLOverHTTP.md"&gt;a1e6d8ca&lt;/a&gt;.
 &lt;/p&gt;
 &lt;p&gt;
 Only GraphQL documents conforming to the 'ExecutableDocument' of the grammar are allowed: This includes the usual
 'query', 'mutation', 'subscription' and 'fragment's.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapOperationExtractor">
</xsd:element>
<xsd:element ref="balancer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="reverseProxying">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
 as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
 hostnames and ports used to access Membrane  vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clamav">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Delegates virus checks to an external Virus Scanner.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="destination">
</xsd:element>
<xsd:element ref="requireAuth">
</xsd:element>
<xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;request&gt; Element you can limit their application to requests only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="cache">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Don't use, this does NOT implement valid HTTP caching.
              &lt;/p&gt;
              &lt;p&gt;
                  We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                  the Docker Registry for offline use.
                  The cache does not revalidate any responses, so machines querying the cache for Debian
                  package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                  This is - simply put - the only use case, where using this class makes any sense.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsJDBC">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
 database (one row per exchange).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="index">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
              To use this feature just add a serviceProxy containing the index
              element. Of course you can protect the service proxy by using
              SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;wsdlPublisher&lt;/i&gt; serves WSDL files (and attached XML Schema Documents), if your
 backend service does not already do so.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="webServiceExplorer">
</xsd:element>
<xsd:element ref="logContext">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="APIsJSON">
</xsd:element>
<xsd:element ref="flowInitiator">
</xsd:element>
<xsd:element ref="counter">
</xsd:element>
<xsd:element ref="rateLimiter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;rateLimiter&lt;/i&gt; plugin limits the number of requests of a client in a period of time.
 As a default the client requests are grouped by client-Ip address and then counted. There are lots of
 possibilities to group the requests using the keyExpression. The requests can even be counted from different
 clients together.&lt;/p&gt;
 &lt;p&gt;When the gateway is located behind a loadbalancer then
 the client-Ip address is not the one from the client but the address from the balancer. To get the real Ip-address loadbalancers,
 &lt;i&gt;Web Application Firewalls&lt;/i&gt; and reverse proxies set the ip from the original client into the &lt;i&gt;X-Forwarded-For&lt;/i&gt; HTTP
 header field. The limiter plugin can take the Ip-address from the header.&lt;/p&gt;
 &lt;p&gt;
 The X-Forwarded-For header can only be trusted when a trustworthy reverse proxy or load balancer is between the client and server. The gateway not should be
 reachable directly. Only activate this feature when you know what you are doing.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="call">
</xsd:element>
<xsd:element ref="oauth2Resource2">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
 authorization server as response.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="if">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The "if" interceptor supports conditional execution of nested plugins.
 &lt;/p&gt;
 See:
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorSpELTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorGroovyTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorJsonpathTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorXPathTest&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="template">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders the body content of a message from a template. The template can
 produce plain text, Json or XML. Variables in the template are substituted with values from the body,
 header, query parameters, etc. If the extension of a referenced template file is &lt;i&gt;.xml&lt;/i&gt; it will use
 &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_xmltemplateengine"&gt;XMLTemplateEngine&lt;/a&gt;
 otherwise &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_streamingtemplateengine"&gt;StreamingTemplateEngine&lt;/a&gt;.
 Have a look at the samples in &lt;a href="https://github.com/membrane/service-proxy/tree/master/distribution/examples"&gt;examples/template&lt;/a&gt;.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="groovyTemplate">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Uses the groovy template markup engine to produce HTML-based responses.
 &lt;code&gt;
 &lt;groovyTemplate&gt;&lt;![CDATA[
   html {
     head {
       title('Resource')
     }
     body {
       p('Hello from Membrane!')
     }
   }
 ]]&gt;&lt;/groovyTemplate&gt;
 &lt;/code&gt;
 &lt;p&gt;
 The word "spring" refers to the Spring ApplicationContext.
 The word "exc" refers to the Membrane Exchange being handled.
 The word "flow" refers to the current Membrane Flow (=REQUEST).
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessLog">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes exchange metrics into a Log4j appender&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Defaults to Apache Common Log pattern&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="prometheus">
</xsd:element>
<xsd:element ref="wadlRewriter">
</xsd:element>
<xsd:element ref="openTelemetry">
</xsd:element>
<xsd:element ref="limit">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Note that due to the streaming nature of Membrane, a request header may already have been passed on to
              the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
              aborted and the connection to the backend is simply closed.
              &lt;/p&gt;
              &lt;p&gt;
              To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
              &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="basicAuthentication">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="json2Xml">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts body payload from JSON to XML. The JSON must be an object other JSON documents e.g. arrays are not supported.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Resulting XML will be in UTF-8 encoding.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shutdown">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Shutdown interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                  Adds the ability to shutdown main router thread via an HTTP request.
                  Don't forget to setup security for this interceptor.
              &lt;/p&gt;
              &lt;p&gt;
                  Has undefined behavior when Membrane is &lt;b&gt;not&lt;/b&gt; started from command line
                  (=via the RouterCLI class, which &lt;tt&gt;service-proxy.ps1&lt;/tt&gt;/&lt;tt&gt;service-proxy.sh&lt;/tt&gt;
                  do use).
              &lt;/p&gt;
              &lt;p&gt;
                  Only actually terminates the running JVM, when used in the first
                  &lt;tt&gt;&lt;router&gt;&lt;/tt&gt; bean (which implicitly stands for
                  &lt;tt&gt;&lt;router id="router"&gt;&lt;/tt&gt;) called "router".
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="userFeature">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapStackTraceFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
              advised to test its functionality in combination with your SOAP service provider before deploying it in
              production.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="formValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiDocs">
</xsd:element>
<xsd:element ref="choose">
</xsd:element>
<xsd:element ref="testService">
</xsd:element>
<xsd:element ref="soap2Rest">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clusterNotification">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane API Gateway distribution.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setHeader">
</xsd:element>
<xsd:element ref="groovy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Groovy script. The script can access and manipulate data from the request and response.
 Use this or the Javascript plugin to extend the functions of Membrane by scripting.
 See: example/groovy for working samples&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtSign">
</xsd:element>
<xsd:element ref="statisticsProvider">
</xsd:element>
<xsd:element ref="replace">
</xsd:element>
<xsd:element ref="methodOverride">
</xsd:element>
<xsd:element ref="stompClient">
</xsd:element>
<xsd:element ref="webSocket">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
 attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="log">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages. The messages will appear either on the console or in
 a log file depending on the log configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="return">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Terminates the exchange flow. The returned response is determined in the following order:
 &lt;p&gt;
 1. If there is already a response in the exchange, that response is returned
 2. If there is no response in the exchange, the body and contentType of the request is copied into a new response.
 &lt;/p&gt;
 &lt;p&gt;
 The options statusCode and contentType will overwrite the values from the messages.
 &lt;/p&gt;
 &lt;p&gt;
 This plugin is useful together with the template plugin. See examples/template.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsCSV">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
              file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="openapiValidator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Validator for OpenAPI documents&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accountRegistration">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="kubernetesValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Kubernetes Integration is still experimental.
 &lt;p&gt;
 To create the CustomResourceDefinitions, apply kubernetes-config.yaml from
 core/target/classes/com/predic8/membrane/core/config/kubernetes/ or a part (e.g. the 'serviceproxies' CRD) of the file.
 &lt;/p&gt;
 &lt;p&gt;
 Create a key and certificate for TLS for &lt;a href="https://membrane-validator.membrane-soa.svc:444/"&gt;https://membrane-validator.membrane-soa.svc:444/&lt;/a&gt; and setup Membrane to serve
 this address. The configuration shown below configures Membrane on a fixed IP address outside of the Kubernetes cluster,
 but this is no requirement.
 &lt;/p&gt;
 &lt;p&gt;
 Embed the following serviceProxy and adjust the 'resources' attribute to a comma-separated list of CRDs that you applied.
 Note that while the CRDs have plural names, here you need to use the corresponding singular. Configure the "ssl" section
 using your key and certificate.
 &lt;/p&gt;
 &lt;code&gt;
 &gt;serviceProxy port="444"&gt;
 &gt;ssl&gt;
 &gt;key&gt;
 &gt;private&gt;
 -----BEGIN RSA PRIVATE KEY-----
 ...
 -----END RSA PRIVATE KEY-----
 &gt;/private&gt;
 &gt;certificate&gt;
 -----BEGIN CERTIFICATE-----
 ...
 -----END CERTIFICATE-----
 &gt;/certificate&gt;
 &gt;/key&gt;
 &gt;/ssl&gt;
 &gt;kubernetesValidation resources="serviceproxy" /&gt;
 &gt;/serviceProxy&gt;
 &lt;/code&gt;
 &lt;p&gt;
 Now register a Webhook to validate the new CRDs. (A note to the experts: Membrane's validation schemas are too
 complex to fit into the CRD, because they are highly nestable and self-referencing. We therefore use webhooks.)
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: admissionregistration.k8s.io/v1
 kind: ValidatingWebhookConfiguration
 metadata:
 name: membrane
 webhooks:
 - name: membrane.membrane-soa.org
 admissionReviewVersions: ["v1", "v1beta1"]
 failurePolicy: Fail
 rules:
 - operations: [ "*" ]
 apiGroups: [ "membrane-soa.org" ]
 apiVersions: [ "v1", "v1beta1" ]
 resources: [ "*" ]
 scope: "*"
 clientConfig:
 service:
 name: membrane-validator
 namespace: membrane-soa
 port: 444
 caBundle: LS0t...LQ0K        # base64 encoded, PEM-formatted CA certificate
 sideEffects: None
 ---
 apiVersion: v1
 kind: Namespace
 metadata:
 name: membrane-soa
 ---
 apiVersion: v1
 kind: Service
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 spec:
 ports:
 - port: 444
 ---
 apiVersion: v1
 kind: Endpoints
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 subsets:
 - addresses:
 - ip: 192.168.0.1   # Membrane's IP
 ports:
 - port: 444
 &lt;/code&gt;
 &lt;p&gt;
 Once this setup is complete, you can enable serviceProxies like this:
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: membrane-soa.org/v1beta1
 kind: serviceproxy
 metadata:
 name: demo
 namespace: membrane-soa
 spec:
 host: demo.predic8.de
 path:
 value: /some-path/
 interceptors:
 - response:
 interceptors:
 - groovy:
 src: |
 println "Hello!"
 target:
 host: thomas-bayer.com
 &lt;/code&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setProperty">
</xsd:element>
<xsd:element ref="javascript">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Javascript. The script can access and manipulate data from the request and response.
 Use this or the Groovy plugin to extend the functions of Membrane by scripting. See the samples in examples/javascript.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="paddingHeader">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="greaser">
</xsd:element>
<xsd:element ref="soapBody">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders a SOAP body for legacy intergration&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;response&gt; plugin you can limit their application to responses only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="throttle">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The throttle feature can slow down traffic to thwart denial of service attacks.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlContentFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
 using an XPath expression.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
 match a message at all. This can improve performance significantly, as a DOM tree does probably not have
 to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
 lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
 namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
 &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
 the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
 constructed.
 &lt;/p&gt;
 &lt;p&gt;
 If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
 XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
 modified reconstituted message.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="headerFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
 The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ntlm">
</xsd:element>
<xsd:element ref="login">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
              application.
              &lt;/p&gt;
              &lt;p&gt;
              Users firstly have to authenticate themselves against a directory server using a username and password.
              Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
              token verification, access to the web application is granted for the user's session. Single Sign On can
              easily be realized using a small source code extension or modification of a web application.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
              each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
              default implementations.)
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
              cell phone number, Single Sign On data, etc.).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
              session cookie).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
              attempts for a specified amount of time.
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
              secondary channel like text messaging).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;/ul&gt;
              &lt;p&gt;
              &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
              title="login interceptor workflow"/&gt;
              &lt;/p&gt;
              &lt;p&gt;
              (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
              possible.)
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
              valid, the workflow is as follows:
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
              &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
              &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
              used. Steps 5 and 6.)&lt;/li&gt;
              &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
              &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
              was directly requested). (Step 8.)&lt;/li&gt;
              &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="sampleSoapService">
</xsd:element>
<xsd:element ref="analyser">
</xsd:element>
<xsd:element ref="validator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlRewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="regExReplacer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="abort" type="com.predic8.membrane.core.config.spring.AbortParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Plugins are usually applied to requests and responses.
 In case of errors, the flow returns and &lt;i&gt;handleAbort()&lt;/i&gt; is called on plugins
 going back the chain.
 By nesting plugins into an &lt;abort&gt; you can limit their application to abort flows only.
 On plugins nested in &lt;abort&gt; handleResponse() is called not handleAbort() in order to
 allow normal processing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiKey">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Secures APIs by validating keys stored in either files or proxies.xml. Keys can be received from clients via HTTP headers or URL query parameters. Additional permission checks are possible through scope validation - scopes are loaded into an Exchange property and can be checked using the "hasScope()" SpEL function.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="oauth2authserver">
</xsd:element>
<xsd:element ref="adminConsole">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="urlNormalizer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Replaces "/./" in the request URI's path by "/".
              &lt;/p&gt;
              &lt;p&gt;
              Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
              links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
              root). The SOA model then combines "&lt;a href="http://foo/material/ArticleService?wsdl"&gt;http://foo/material/ArticleService?wsdl&lt;/a&gt;" and
              "./ArticleService?xsd=1" to "&lt;a href="http://foo/material/./ArticleService?xsd=1"&gt;http://foo/material/./ArticleService?xsd=1&lt;/a&gt;". This URI is sent to Membrane's
              new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
              not match.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ruleMatching">
</xsd:element>
<xsd:element ref="oauth2PermissionChecker">
</xsd:element>
<xsd:element ref="for">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element ref="httpClientConfig">
</xsd:element>
</xsd:choice>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.QueryParamExtractorParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="name" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="resolverMap">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.JwtSessionManagerjwkParser">
<xsd:complexContent mixed="true">
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/></xsd:sequence>
<xsd:attribute name="location" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See &lt;a href="https://www.membrane-soa.org/service-proxy-doc/current/configuration/location.htm"&gt;here&lt;/a&gt; for a description of the format.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="openapiPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;openapiPublisher&lt;/i&gt; serves OpenAPI documents
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="sslProxy">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element name="connection" type="com.predic8.membrane.core.config.spring.ConnectionParser">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element name="routerIpResolver" type="com.predic8.membrane.core.config.spring.SslProxyrouterIpResolverParser">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="gatekeeper" type="com.predic8.membrane.core.config.spring.SslProxygatekeeperParser">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
<xsd:choice minOccurs="1">
<xsd:element name="target" type="com.predic8.membrane.core.config.spring.SslProxytargetParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="port" type="spel_number" >
</xsd:attribute>
<xsd:attribute name="ip" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If present, binds the port only on the specified IP. Useful for hosts with multiple IP addresses.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 127.0.0.1&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;not set&lt;/i&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="host" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="useAsDefault" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; whether to use the SSLContext built from this SSLProxy when no SNI header was transmitted.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.XenAuthenticationjwtSessionManagerjwkParser">
<xsd:complexContent mixed="true">
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/></xsd:sequence>
<xsd:attribute name="location" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See &lt;a href="https://www.membrane-soa.org/service-proxy-doc/current/configuration/location.htm"&gt;here&lt;/a&gt; for a description of the format.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="jdbcUserDataProvider">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="datasource" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="tableName" type="xsd:string" use="required">
</xsd:attribute>
<xsd:attribute name="userColumnName" type="xsd:string" use="required">
</xsd:attribute>
<xsd:attribute name="passwordColumnName" type="xsd:string" use="required">
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.GreaseJsonParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="additionalProperties" type="spel_boolean" >
</xsd:attribute>
<xsd:attribute name="shuffleFields" type="spel_boolean" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="accessControl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
              requested resource.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="useXForwardedForAsClientAddr" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; whether to use the last value of the last "X-Forwarded-For" header instead of the remote IP address&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="file" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Location of the ACL file.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; acl/acl.xml&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="accountBlocker">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Keeps track of blocked user accounts (accounts become blocked after too many failed logins).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The Account Blocker prevents password and token guessing attempts: It blocks a user (or the whole
              system) after too many failed login attempts.
              &lt;/p&gt;
              &lt;p&gt;
              When a user entered a wrong password or wrong token more than &lt;i&gt;afterFailedLogins&lt;/i&gt; times, this user
              becomes blocked: He will be prevented from logging in again within the next &lt;i&gt;blockFor&lt;/i&gt; milliseconds
              (writing 3600000 means "for 1 hour").
              &lt;/p&gt;
              &lt;p&gt;
              The failed login attempts have to occur within the last &lt;i&gt;afterFailedLoginsWithin&lt;/i&gt; milliseconds
              (writing 9223372036854775807 means "forever").
              &lt;/p&gt;
              &lt;p&gt;
              If more than &lt;i&gt;blockWholeSystemAfter&lt;/i&gt; users become blocked at a time, the &lt;i&gt;all&lt;/i&gt; users will
              become blocked. (This is necessary to limit memory usage.)
              &lt;/p&gt;
              &lt;h3&gt;Discussion&lt;/h3&gt;
              &lt;p&gt;
              Say, for example, a scripted dictionary attack tries to guess a user's password. Using the configuration
              shown above, which is the default configuration if no &lt;i&gt;accountBlocker&lt;/i&gt; is declared, this results in
              5 guesses per 3600000 milliseconds; or equivalently 42720 guesses per year.
              &lt;/p&gt;
              &lt;p&gt;
              The probability of hitting a uniformly at random chosen word of the standard German vocabulary within
              one year is therefore about 56%.
              &lt;/p&gt;
              &lt;p&gt;
              Therefore, a more secure password should be chosen, containing letters, digits and special characters.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="blockWholeSystemAfter" type="spel_number" >
</xsd:attribute>
<xsd:attribute name="afterFailedLogins" type="spel_number" >
</xsd:attribute>
<xsd:attribute name="afterFailedLoginsWithin" type="spel_number" >
</xsd:attribute>
<xsd:attribute name="blockFor" type="spel_number" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.ClustersParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A list of clusters.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element name="cluster" type="com.predic8.membrane.core.config.spring.ClusterParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="elasticSearchExchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Used for storing exchanges in the Elasticsearch.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Elasticsearch 7 is required. Exchanges can be viewed in admin console and using standard Elasticsearch
              tools. Before writing, this class will check if index exists in current Elasticsearch instance. If index does not
              exist, it will create index and set up mapping for data types. If the existing index already have mapping this step
              will be skipped in order to not to overwrite existing mapping.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="client" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="updateIntervalMs" type="spel_number" >
</xsd:attribute>
<xsd:attribute name="location" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; base URL of Elasticsearch&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;a href="http://localhost:9200"&gt;http://localhost:9200&lt;/a&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="index" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; index name to use for Elasticsearch&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; membrane&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="documentPrefix" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; used for issuer field. Can be used to check which membrane instance is writing current exchange&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; set to hostname as default&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="maxBodySize" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 100000&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="bodyExceedingMaxSizeStrategy" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The strategy to use (TRUNCATE or ERROR) when a HTTP message body is larger than the &lt;tt&gt;maxBodySize&lt;/tt&gt;.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; TRUNCATE&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="jmxExporter">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.UserInfoParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="field" type="xsd:string" use="required">
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="acmeHttpChallenge">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See the documentation of the &lt;code&gt;&lt;acme /&gt;&lt;/code&gt; element for usage details.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.XenAuthenticationjwtSessionManagerParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="1">
<xsd:element name="jwk" type="com.predic8.membrane.core.config.spring.XenAuthenticationjwtSessionManagerjwkParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="audience" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:complexType name="com.predic8.membrane.core.config.spring.LdapUserDataProvidermapParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element name="attribute" type="com.predic8.membrane.core.config.spring.AttributeParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="transform">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transform feature applies an XSLT transformation to the content in the body of a message. After the
              transformation the body content is replaced with the result of the transformation.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="xslt" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Location of the XSLT stylesheet that will be applied to request and response.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; strip.xslt&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="jSessionIdExtractor">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;jSessionIdExtractor&lt;/i&gt; extracts the JSESSIONID from a
              message and provides it to the {@link Balancer}.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.LdapUserDataProviderParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element ref="ssl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element name="map" type="com.predic8.membrane.core.config.spring.LdapUserDataProvidermapParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="url" type="xsd:string" use="required">
</xsd:attribute>
<xsd:attribute name="base" type="xsd:string" use="required">
</xsd:attribute>
<xsd:attribute name="binddn" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="bindpw" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="searchPattern" type="xsd:string" use="required">
</xsd:attribute>
<xsd:attribute name="searchScope" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; subtree&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="passwordAttribute" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="timeout" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 1000&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="connectTimeout" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 1000&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="readAttributesAsSelf" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="roundRobinStrategy">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="rewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Rewrites or redirects the path of incoming requests based on a mapping.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="1" maxOccurs="unbounded">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Defines a regex and a replacement for the rewriting of the URI.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element name="map" type="com.predic8.membrane.core.config.spring.RewritermapParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.RewritermapParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="from" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Java Regular expression&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; ^/bank/(.*)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="to" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Replacement string. Can contain references to matching groups.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; /axis2/$1&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="do" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; What to do: "rewrite", "redirect-temporary" or "redirect-permanent".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; redirect-temporary&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; rewrite (default) or redirect (if "to" contains "://")&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="rest2Soap">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Specifies the mappings. The first matching mapping will be applied to the request.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element name="mapping" type="com.predic8.membrane.core.config.spring.Rest2SoapmappingParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="xenAuthentication">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element ref="staticUserDataProvider">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; listing all user data in-place in the config file.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              the &lt;i&gt;staticuserdataprovider&lt;/i&gt; can be used to statically list user data within the config file.
              &lt;/p&gt;
              &lt;p&gt;
              each user must have a unique &lt;i&gt;username&lt;/i&gt; attribute as well as a &lt;i&gt;password&lt;/i&gt; attribute.
              &lt;/p&gt;
              &lt;p&gt;
              arbitrary attributes can be set on a user element. other sub-components of the &lt;i&gt;login&lt;/i&gt; interceptor
              might use those: for example, the &lt;i&gt;telekomsmstokenprovider&lt;/i&gt; uses the &lt;i&gt;sms&lt;/i&gt; property as the
              user's cell phone number. for example, the &lt;i&gt;totptokenprovider&lt;/i&gt; uses the &lt;i&gt;secret&lt;/i&gt; property to
              initialize the token sequence.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jdbcUserDataProvider">
</xsd:element>
<xsd:element name="ldapUserDataProvider" type="com.predic8.membrane.core.config.spring.LdapUserDataProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; querying an LDAP server to authorize users and retrieve attributes.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The LDAP User Data Provider performs two jobs:
              &lt;ol&gt;
              &lt;li&gt;Authentication of a &lt;i&gt;username&lt;/i&gt; and &lt;i&gt;password&lt;/i&gt;.&lt;/li&gt;
              &lt;li&gt;Retrieval of user attributes.&lt;/li&gt;
              &lt;/ol&gt;
              &lt;/p&gt;
              &lt;p&gt;
              To achieve this, it first binds to &lt;i&gt;base&lt;/i&gt; on the LDAP server &lt;i&gt;url&lt;/i&gt;. If &lt;i&gt;binddn&lt;/i&gt; is not
              present, it binds to the LDAP server anonymously, elsewise &lt;i&gt;binddn&lt;/i&gt; and &lt;i&gt;bindpw&lt;/i&gt; are used for
              authentication.
              &lt;/p&gt;
              &lt;p&gt;
              Next, a search &lt;i&gt;searchPattern&lt;/i&gt; with scope &lt;i&gt;searchScope&lt;/i&gt; is executed where "&lt;tt&gt;%LOGIN%&lt;/tt&gt;"
              is replaced by the escaped version of the &lt;i&gt;username&lt;/i&gt;.
              &lt;/p&gt;
              &lt;p&gt;
              The search returning no node or more than one node is treated as failure.
              &lt;/p&gt;
              &lt;p&gt;
              If &lt;i&gt;passwordAttribute&lt;/i&gt; is set, and the node has an attribute with this name and this attribute's
              value starts with "&lt;tt&gt;{x-plain}&lt;/tt&gt;", the password is checked against the rest of the value for
              equality. If &lt;i&gt;passwordAttribute&lt;/i&gt; is not set, a second binding is attempted on the node using the
              &lt;i&gt;password&lt;/i&gt; the user provided.
              &lt;/p&gt;
              &lt;p&gt;
              The user attribute keys specified in the mapping are then renamed according to the mapping and used for
              further processing (see the other modules of the &lt;i&gt;login&lt;/i&gt; interceptor).
              &lt;/p&gt;
              &lt;p&gt;
              &lt;/p&gt;
              &lt;p&gt;
              For the initial binding, &lt;i&gt;connectTimeout&lt;/i&gt; can be used to specify a timeout in milliseconds. For the
              search, &lt;i&gt;timeout&lt;/i&gt; can be used.
              &lt;/p&gt;
              &lt;p&gt;
              If &lt;i&gt;readAttributesAsSelf&lt;/i&gt; is not set, the user attributes are collected from the search result. If
              it is set, an additional request is made after the second successful binding to retrieve the node's
              attributes.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="fileUserDataProvider">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; utilizing htpasswd formatted files.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              the &lt;i&gt;fileuserdataprovider&lt;/i&gt; can be used to source authentication data from htpasswd files.
              &lt;/p&gt;
              &lt;p&gt;
              The files can only utilize algorithm magic strings supported by &lt;i&gt;crypt(3)&lt;/i&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="cachingUserDataProvider" type="com.predic8.membrane.core.config.spring.CachingUserDataProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Caching User Data provider caches previous successful logins in order to make authentication faster&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="customStatementJdbcUserDataProvider">
</xsd:element>
<xsd:element name="unifyingUserDataProvider" type="com.predic8.membrane.core.config.spring.UnifyingUserDataProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;unifyingUserDataProvider&lt;/i&gt; can be used to merge two or more other &lt;i&gt;user data providers&lt;/i&gt;
              into one.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;unifyingUserDataProvider&lt;/i&gt; will forward a login attempt (username and password) to each inner
              user data provider in the order they are specified. After one of the inner user data providers returned
              a successful login (and returned the user's attributes), the procedure terminates. If no inner user data
              provider could verify the user, the login attempt fails.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element name="jwtSessionManager" type="com.predic8.membrane.core.config.spring.XenAuthenticationjwtSessionManagerParser">
</xsd:element>
<xsd:element name="inMemorySessionManager" type="com.predic8.membrane.core.config.spring.InMemorySessionManagerParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="user" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="password" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="graphQLProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Check GraphQL-over-HTTP requests, enforcing several limits and/or restrictions. This effectively helps to reduce
 the attack surface.
 &lt;p&gt;
 GraphQL Specification "October2021" is used. (But GraphQL only covers formulation of Documents/Queries.)
 &lt;/p&gt;
 &lt;p&gt;
 GraphQL-over-HTTP, which specifies how to submit GraphQL queries via HTTP, has not been released/finalized yet. We
 therefore use Version
 &lt;a href="https://github.com/graphql/graphql-over-http/blob/a1e6d8ca248c9a19eb59a2eedd988c204909ee3f/spec/GraphQLOverHTTP.md"&gt;a1e6d8ca&lt;/a&gt;.
 &lt;/p&gt;
 &lt;p&gt;
 Only GraphQL documents conforming to the 'ExecutableDocument' of the grammar are allowed: This includes the usual
 'query', 'mutation', 'subscription' and 'fragment's.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="maxMutations" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limit how many mutations can be defined in a document query.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 2&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 5&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="allowExtensions" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Whether to allow GraphQL "extensions".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="allowedMethods" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Which HTTP methods to allow. Note that per the GraphQL-over-HTTP spec, you need POST for mutation or subscription queries.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; GET, POST&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="maxRecursion" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; How deep recursive parts of queries can be nested.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 3&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="maxDepth" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; How deep queries can be nested.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 7&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.DescriptionParser">
<xsd:complexContent mixed="true">
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/></xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="redis">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="connectionNumber" type="spel_number" >
</xsd:attribute>
<xsd:attribute name="minIdleConnection" type="spel_number" >
</xsd:attribute>
<xsd:attribute name="timeout" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Timeout value when connecting to Redis instance. Default is 10000 milliseconds. Unit is in milliseconds&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="user" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Username to use when connecting redis.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="password" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Password to use when connecting redis.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="ssl" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Used for enabling ssl. Default value is false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="host" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Host name to connect to, or multiple host names separated by spaces ' '.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="port" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Port number to connect to&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="dbNumber" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Database number to use&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="useSentinels" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="masterName" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; mymaster&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.KeysParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;secret value="..." /&gt; elements containing the key as value property.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element name="secret" type="com.predic8.membrane.core.config.spring.SecretParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Contains api keys and scopes.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:complexType name="com.predic8.membrane.core.config.spring.SslProxytargetParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="port" type="spel_number" >
</xsd:attribute>
<xsd:attribute name="host" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="soapOperationExtractor">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="staticClientList">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element name="client" type="com.predic8.membrane.core.config.spring.StaticClientListclientParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="balancer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Sets the strategy used to extract a session ID from incoming HTTP requests.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element ref="xmlSessionIdExtractor">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Extracts a session ID from an XML HTTP request body based on the qualified name of an XML element.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jSessionIdExtractor">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;jSessionIdExtractor&lt;/i&gt; extracts the JSESSIONID from a
              message and provides it to the {@link Balancer}.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Specifies a list of clusters.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element name="clusters" type="com.predic8.membrane.core.config.spring.ClustersParser">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Sets the strategy used to choose the backend nodes.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element ref="roundRobinStrategy">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="byThreadStrategy">
</xsd:element>
<xsd:element ref="faultMonitoringStrategy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Monitors the outcome of requests to each node to quickly disable/re-enable faulty ones.

 &lt;h2&gt;WHY THIS CLASS&lt;/h2&gt;
 &lt;p&gt;This is a drop-in replacement for the default {@link RoundRobinStrategy}. In fact, as long as all nodes
 respond correctly, it works the same. Things only start changing once nodes fail.
 Whereas the RoundRobin keeps dispatching to faulty nodes, causing delays for the service user, this
 strategy detects the issue and favours functional nodes.
 &lt;/p&gt;

 &lt;h2&gt;FORECAST PREDICTION USING "PERSISTENCE METHOD"&lt;/h2&gt;
 &lt;p&gt;Predicting tomorrow's weather by saying it will be equal to today's works well in many areas of the
 world. Similarly, predicting that another service request to a node will succeed after a success, or fail
 after a failure, is very likely.
 That's the main concept behind the logic and algorithm used within this class.
 &lt;/p&gt;

 &lt;h2&gt;HOW IT WORKS&lt;/h2&gt;
 &lt;p&gt;Once a node returns with a failure, a fault profile for that node is created. The node is instantly
 considered to be faulty. From then on, all status (success/failure) of that node is monitored.
 If enough successive calls are successful, the node is cleared from its bad reputation.
 If the node is not used anymore (either not requests at all, or none to that node because it's
 faulty and there are enough good nodes) then the node is cleared from its bad reputation after
 a configurable amount of time.
 When there are enough functional nodes (configurable ratio), only the functional ones are used
 with the simplistic round-robin strategy. If not, then all nodes are used, and the selection is a
 weighted chance operation by recent success rate.
 &lt;/p&gt;

 &lt;h2&gt;WHAT IS A FAULT&lt;/h2&gt;
 &lt;p&gt;A fault is when the destination replied with a valid 5xx HTTP status code, or when an exception
 (such as a ConnectException) was thrown. Everything else, including 4xx codes, is considered a success.&lt;/p&gt;

 &lt;h2&gt;PER NODE, NOT PER DESTINATION&lt;/h2&gt;
 &lt;p&gt;Success status could be monitored per node (host/port) or per destination (host/port/servicename).
 In practice, most failures affect all services. Rarely only one service on a node is faulty, but it's
 also very possible. This implementation currently monitors per node. This is for technical reasons,
 per destination is currently not possible with the information that is present. If it was available,
 I'm not sure which one is better to choose. Maybe configurable would be nice.
 If monitoring happens per destination, and one service is detected to be faulty, but in fact the
 whole node is down, this information will then not be freely available for the other destinations...
 they have to figure it out independently. Unless some more complicated functionality is built in.
 &lt;/p&gt;

 &lt;h2&gt;GOALS OF THIS CLASS&lt;/h2&gt;
 &lt;p&gt;Simple super-fast, super-low memory use. The goal is to provide a great service experience to the api
 user. Over-complicating things in here and introducing possible bugs or bottlenecks must be avoided.
 &lt;/p&gt;

 &lt;h2&gt;WHAT IT'S NOT&lt;/h2&gt;
 &lt;p&gt;It does not do response time monitoring to identify slow/laggy servers, or to favour faster ones.
 There can be different kinds of services on the same hosts, simple and complex expensive ones,
 and we don't have that kind of information here. Another similar DispatchingStrategy could do
 such logic.
 &lt;/p&gt;

 &lt;h2&gt;LIMITATIONS&lt;/h2&gt;
 &lt;p&gt;No background checking of faulty nodes.
 For certain kinds of failures, including ConnectException and UnknownHostException, a background service
 could keep checking a faulty node, and only re-enable it once that works again.
 For other cases, there could be a pluggable BackgroundUptimeCheck interface. This would allow a
 service implementor to write his own check that fits his needs. For example by sending a real
 service request that does not harm.
 Automatic background retry of previous failed requests to see if the service is back online is a bad
 idea... think payment service.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Checks if nodes are still available. Sets them to "DOWN" when not reachable, else sets them back up when they are reachable.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element ref="nodeOnlineChecker">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="name" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Uniquely identifies this Load Balancer, if there is more than one. Used
 in the web administration interface and lbclient to manage nodes.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; balancer1&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; Default&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="sessionTimeout" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Time in milliseconds after which sessions time out. (If a session
 extractor is used.) Default is 1 hour, 0 means never.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 600000 &lt;i&gt;(10min)&lt;/i&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 3600000&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="reverseProxying">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
 as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
 hostnames and ports used to access Membrane  vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="forgetfulExchangeStore">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="clamav">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Delegates virus checks to an external Virus Scanner.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="host" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the host of the clamav daemon&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; localhost&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="port" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the port of the clamav daemon&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 3310&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="destination">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="url" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Use destination instead of target&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; https://api.predic8.de&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; ignored&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="requireAuth">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="expectedAud" type="xsd:string" use="required">
</xsd:attribute>
<xsd:attribute name="oauth2" type="xsd:string" use="required">
</xsd:attribute>
<xsd:attribute name="required" type="spel_boolean" >
</xsd:attribute>
<xsd:attribute name="errorStatus" type="spel_number" >
</xsd:attribute>
<xsd:attribute name="scope" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="azureIdentity">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="grantType" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="clientId" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="clientSecret" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="resource" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="tenantId" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.GithubParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element ref="ssl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="httpClientConfiguration" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="clientId" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="clientSecret" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="scope" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="useJWTForClientAuth" type="spel_boolean" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:complexType name="com.predic8.membrane.core.config.spring.SecretParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;scope&gt;...&lt;/scope&gt; elements for defining scopes for this key.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element name="scope" type="com.predic8.membrane.core.config.spring.ScopeParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Contains a scope for use in &lt;secret value="..."&gt;...&lt;/secret&gt; elements.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="value" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The api key itself.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="nodeOnlineChecker">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="retryTimeInSeconds" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the time in seconds until offline nodes are checked again. -1 to disable&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; -1&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="nodeCounterLimit5XX" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the number of times a node has to fail with a 5XX statuscode until it is taken down&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 10&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="fileUserDataProvider">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; utilizing htpasswd formatted files.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              the &lt;i&gt;fileuserdataprovider&lt;/i&gt; can be used to source authentication data from htpasswd files.
              &lt;/p&gt;
              &lt;p&gt;
              The files can only utilize algorithm magic strings supported by &lt;i&gt;crypt(3)&lt;/i&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="htpasswdPath" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A path pointing to the htpasswd file.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.RequestParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element ref="httpClient">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
 Server using the HTTP protocol. Usually it will be globally used
 inside the transport. However, it is also possible to use it
 inside a proxy to give the proxy an individual configuration for
 its outgoing HTTP connection that is different from the global
 configuration in the transport.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtAuth">
</xsd:element>
<xsd:element ref="interceptor">
</xsd:element>
<xsd:element ref="tcp">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="tokenValidator">
</xsd:element>
<xsd:element ref="beautifier">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Beautifies request and response bodies. Supported are the Formats: JSON, XML&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="static">
</xsd:element>
<xsd:element ref="jsonProtection">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="http2xml">
</xsd:element>
<xsd:element name="echo" type="com.predic8.membrane.core.config.spring.EchoParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Returns the flow of plugins and copies the content of the
 request into a new response. The response has a status code of 200.
 Useful for testing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xml2Json">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If enabled converts body content from xml to json.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Can be used for both request and response. Xml file assumed to be in UTF-8. If input is invalid it returns
 empty json object.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="authHead2Body">
</xsd:element>
<xsd:element ref="webServer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
 "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
 &lt;/p&gt;
 &lt;p&gt;
 The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
 HTTP response with the contents of a file, or a "404 Not Found." error.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="internalRouting">
</xsd:element>
<xsd:element ref="exchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
              might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="dispatching">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
 element to the list of destinations of the exchange object. It
 must be placed into the transport to make Service Proxies Work
 properly. It has to be placed after the ruleMatching
 interceptor. The ruleMatching interceptor looks up a service
 proxy for an incoming request and places it into the exchange
 object. The dispatching interceptor needs the service proxy to
 get information about the target.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shadowing">
</xsd:element>
<xsd:element ref="openapiPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;openapiPublisher&lt;/i&gt; serves OpenAPI documents
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessControl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
              requested resource.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="acmeHttpChallenge">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See the documentation of the &lt;code&gt;&lt;acme /&gt;&lt;/code&gt; element for usage details.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="transform">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transform feature applies an XSLT transformation to the content in the body of a message. After the
              transformation the body content is replaced with the result of the transformation.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Rewrites or redirects the path of incoming requests based on a mapping.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rest2Soap">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xenAuthentication">
</xsd:element>
<xsd:element ref="graphQLProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Check GraphQL-over-HTTP requests, enforcing several limits and/or restrictions. This effectively helps to reduce
 the attack surface.
 &lt;p&gt;
 GraphQL Specification "October2021" is used. (But GraphQL only covers formulation of Documents/Queries.)
 &lt;/p&gt;
 &lt;p&gt;
 GraphQL-over-HTTP, which specifies how to submit GraphQL queries via HTTP, has not been released/finalized yet. We
 therefore use Version
 &lt;a href="https://github.com/graphql/graphql-over-http/blob/a1e6d8ca248c9a19eb59a2eedd988c204909ee3f/spec/GraphQLOverHTTP.md"&gt;a1e6d8ca&lt;/a&gt;.
 &lt;/p&gt;
 &lt;p&gt;
 Only GraphQL documents conforming to the 'ExecutableDocument' of the grammar are allowed: This includes the usual
 'query', 'mutation', 'subscription' and 'fragment's.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapOperationExtractor">
</xsd:element>
<xsd:element ref="balancer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="reverseProxying">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
 as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
 hostnames and ports used to access Membrane  vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clamav">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Delegates virus checks to an external Virus Scanner.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="destination">
</xsd:element>
<xsd:element ref="requireAuth">
</xsd:element>
<xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;request&gt; Element you can limit their application to requests only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="cache">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Don't use, this does NOT implement valid HTTP caching.
              &lt;/p&gt;
              &lt;p&gt;
                  We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                  the Docker Registry for offline use.
                  The cache does not revalidate any responses, so machines querying the cache for Debian
                  package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                  This is - simply put - the only use case, where using this class makes any sense.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsJDBC">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
 database (one row per exchange).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="index">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
              To use this feature just add a serviceProxy containing the index
              element. Of course you can protect the service proxy by using
              SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;wsdlPublisher&lt;/i&gt; serves WSDL files (and attached XML Schema Documents), if your
 backend service does not already do so.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="webServiceExplorer">
</xsd:element>
<xsd:element ref="logContext">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="APIsJSON">
</xsd:element>
<xsd:element ref="flowInitiator">
</xsd:element>
<xsd:element ref="counter">
</xsd:element>
<xsd:element ref="rateLimiter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;rateLimiter&lt;/i&gt; plugin limits the number of requests of a client in a period of time.
 As a default the client requests are grouped by client-Ip address and then counted. There are lots of
 possibilities to group the requests using the keyExpression. The requests can even be counted from different
 clients together.&lt;/p&gt;
 &lt;p&gt;When the gateway is located behind a loadbalancer then
 the client-Ip address is not the one from the client but the address from the balancer. To get the real Ip-address loadbalancers,
 &lt;i&gt;Web Application Firewalls&lt;/i&gt; and reverse proxies set the ip from the original client into the &lt;i&gt;X-Forwarded-For&lt;/i&gt; HTTP
 header field. The limiter plugin can take the Ip-address from the header.&lt;/p&gt;
 &lt;p&gt;
 The X-Forwarded-For header can only be trusted when a trustworthy reverse proxy or load balancer is between the client and server. The gateway not should be
 reachable directly. Only activate this feature when you know what you are doing.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="call">
</xsd:element>
<xsd:element ref="oauth2Resource2">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
 authorization server as response.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="if">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The "if" interceptor supports conditional execution of nested plugins.
 &lt;/p&gt;
 See:
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorSpELTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorGroovyTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorJsonpathTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorXPathTest&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="template">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders the body content of a message from a template. The template can
 produce plain text, Json or XML. Variables in the template are substituted with values from the body,
 header, query parameters, etc. If the extension of a referenced template file is &lt;i&gt;.xml&lt;/i&gt; it will use
 &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_xmltemplateengine"&gt;XMLTemplateEngine&lt;/a&gt;
 otherwise &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_streamingtemplateengine"&gt;StreamingTemplateEngine&lt;/a&gt;.
 Have a look at the samples in &lt;a href="https://github.com/membrane/service-proxy/tree/master/distribution/examples"&gt;examples/template&lt;/a&gt;.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="groovyTemplate">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Uses the groovy template markup engine to produce HTML-based responses.
 &lt;code&gt;
 &lt;groovyTemplate&gt;&lt;![CDATA[
   html {
     head {
       title('Resource')
     }
     body {
       p('Hello from Membrane!')
     }
   }
 ]]&gt;&lt;/groovyTemplate&gt;
 &lt;/code&gt;
 &lt;p&gt;
 The word "spring" refers to the Spring ApplicationContext.
 The word "exc" refers to the Membrane Exchange being handled.
 The word "flow" refers to the current Membrane Flow (=REQUEST).
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessLog">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes exchange metrics into a Log4j appender&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Defaults to Apache Common Log pattern&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="prometheus">
</xsd:element>
<xsd:element ref="wadlRewriter">
</xsd:element>
<xsd:element ref="openTelemetry">
</xsd:element>
<xsd:element ref="limit">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Note that due to the streaming nature of Membrane, a request header may already have been passed on to
              the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
              aborted and the connection to the backend is simply closed.
              &lt;/p&gt;
              &lt;p&gt;
              To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
              &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="basicAuthentication">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="json2Xml">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts body payload from JSON to XML. The JSON must be an object other JSON documents e.g. arrays are not supported.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Resulting XML will be in UTF-8 encoding.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shutdown">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Shutdown interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                  Adds the ability to shutdown main router thread via an HTTP request.
                  Don't forget to setup security for this interceptor.
              &lt;/p&gt;
              &lt;p&gt;
                  Has undefined behavior when Membrane is &lt;b&gt;not&lt;/b&gt; started from command line
                  (=via the RouterCLI class, which &lt;tt&gt;service-proxy.ps1&lt;/tt&gt;/&lt;tt&gt;service-proxy.sh&lt;/tt&gt;
                  do use).
              &lt;/p&gt;
              &lt;p&gt;
                  Only actually terminates the running JVM, when used in the first
                  &lt;tt&gt;&lt;router&gt;&lt;/tt&gt; bean (which implicitly stands for
                  &lt;tt&gt;&lt;router id="router"&gt;&lt;/tt&gt;) called "router".
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="userFeature">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapStackTraceFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
              advised to test its functionality in combination with your SOAP service provider before deploying it in
              production.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="formValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiDocs">
</xsd:element>
<xsd:element ref="choose">
</xsd:element>
<xsd:element ref="testService">
</xsd:element>
<xsd:element ref="soap2Rest">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clusterNotification">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane API Gateway distribution.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setHeader">
</xsd:element>
<xsd:element ref="groovy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Groovy script. The script can access and manipulate data from the request and response.
 Use this or the Javascript plugin to extend the functions of Membrane by scripting.
 See: example/groovy for working samples&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtSign">
</xsd:element>
<xsd:element ref="statisticsProvider">
</xsd:element>
<xsd:element ref="replace">
</xsd:element>
<xsd:element ref="methodOverride">
</xsd:element>
<xsd:element ref="stompClient">
</xsd:element>
<xsd:element ref="webSocket">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
 attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="log">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages. The messages will appear either on the console or in
 a log file depending on the log configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="return">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Terminates the exchange flow. The returned response is determined in the following order:
 &lt;p&gt;
 1. If there is already a response in the exchange, that response is returned
 2. If there is no response in the exchange, the body and contentType of the request is copied into a new response.
 &lt;/p&gt;
 &lt;p&gt;
 The options statusCode and contentType will overwrite the values from the messages.
 &lt;/p&gt;
 &lt;p&gt;
 This plugin is useful together with the template plugin. See examples/template.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsCSV">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
              file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="openapiValidator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Validator for OpenAPI documents&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accountRegistration">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="kubernetesValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Kubernetes Integration is still experimental.
 &lt;p&gt;
 To create the CustomResourceDefinitions, apply kubernetes-config.yaml from
 core/target/classes/com/predic8/membrane/core/config/kubernetes/ or a part (e.g. the 'serviceproxies' CRD) of the file.
 &lt;/p&gt;
 &lt;p&gt;
 Create a key and certificate for TLS for &lt;a href="https://membrane-validator.membrane-soa.svc:444/"&gt;https://membrane-validator.membrane-soa.svc:444/&lt;/a&gt; and setup Membrane to serve
 this address. The configuration shown below configures Membrane on a fixed IP address outside of the Kubernetes cluster,
 but this is no requirement.
 &lt;/p&gt;
 &lt;p&gt;
 Embed the following serviceProxy and adjust the 'resources' attribute to a comma-separated list of CRDs that you applied.
 Note that while the CRDs have plural names, here you need to use the corresponding singular. Configure the "ssl" section
 using your key and certificate.
 &lt;/p&gt;
 &lt;code&gt;
 &gt;serviceProxy port="444"&gt;
 &gt;ssl&gt;
 &gt;key&gt;
 &gt;private&gt;
 -----BEGIN RSA PRIVATE KEY-----
 ...
 -----END RSA PRIVATE KEY-----
 &gt;/private&gt;
 &gt;certificate&gt;
 -----BEGIN CERTIFICATE-----
 ...
 -----END CERTIFICATE-----
 &gt;/certificate&gt;
 &gt;/key&gt;
 &gt;/ssl&gt;
 &gt;kubernetesValidation resources="serviceproxy" /&gt;
 &gt;/serviceProxy&gt;
 &lt;/code&gt;
 &lt;p&gt;
 Now register a Webhook to validate the new CRDs. (A note to the experts: Membrane's validation schemas are too
 complex to fit into the CRD, because they are highly nestable and self-referencing. We therefore use webhooks.)
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: admissionregistration.k8s.io/v1
 kind: ValidatingWebhookConfiguration
 metadata:
 name: membrane
 webhooks:
 - name: membrane.membrane-soa.org
 admissionReviewVersions: ["v1", "v1beta1"]
 failurePolicy: Fail
 rules:
 - operations: [ "*" ]
 apiGroups: [ "membrane-soa.org" ]
 apiVersions: [ "v1", "v1beta1" ]
 resources: [ "*" ]
 scope: "*"
 clientConfig:
 service:
 name: membrane-validator
 namespace: membrane-soa
 port: 444
 caBundle: LS0t...LQ0K        # base64 encoded, PEM-formatted CA certificate
 sideEffects: None
 ---
 apiVersion: v1
 kind: Namespace
 metadata:
 name: membrane-soa
 ---
 apiVersion: v1
 kind: Service
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 spec:
 ports:
 - port: 444
 ---
 apiVersion: v1
 kind: Endpoints
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 subsets:
 - addresses:
 - ip: 192.168.0.1   # Membrane's IP
 ports:
 - port: 444
 &lt;/code&gt;
 &lt;p&gt;
 Once this setup is complete, you can enable serviceProxies like this:
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: membrane-soa.org/v1beta1
 kind: serviceproxy
 metadata:
 name: demo
 namespace: membrane-soa
 spec:
 host: demo.predic8.de
 path:
 value: /some-path/
 interceptors:
 - response:
 interceptors:
 - groovy:
 src: |
 println "Hello!"
 target:
 host: thomas-bayer.com
 &lt;/code&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setProperty">
</xsd:element>
<xsd:element ref="javascript">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Javascript. The script can access and manipulate data from the request and response.
 Use this or the Groovy plugin to extend the functions of Membrane by scripting. See the samples in examples/javascript.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="paddingHeader">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="greaser">
</xsd:element>
<xsd:element ref="soapBody">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders a SOAP body for legacy intergration&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;response&gt; plugin you can limit their application to responses only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="throttle">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The throttle feature can slow down traffic to thwart denial of service attacks.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlContentFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
 using an XPath expression.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
 match a message at all. This can improve performance significantly, as a DOM tree does probably not have
 to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
 lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
 namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
 &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
 the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
 constructed.
 &lt;/p&gt;
 &lt;p&gt;
 If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
 XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
 modified reconstituted message.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="headerFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
 The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ntlm">
</xsd:element>
<xsd:element ref="login">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
              application.
              &lt;/p&gt;
              &lt;p&gt;
              Users firstly have to authenticate themselves against a directory server using a username and password.
              Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
              token verification, access to the web application is granted for the user's session. Single Sign On can
              easily be realized using a small source code extension or modification of a web application.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
              each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
              default implementations.)
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
              cell phone number, Single Sign On data, etc.).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
              session cookie).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
              attempts for a specified amount of time.
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
              secondary channel like text messaging).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;/ul&gt;
              &lt;p&gt;
              &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
              title="login interceptor workflow"/&gt;
              &lt;/p&gt;
              &lt;p&gt;
              (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
              possible.)
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
              valid, the workflow is as follows:
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
              &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
              &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
              used. Steps 5 and 6.)&lt;/li&gt;
              &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
              &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
              was directly requested). (Step 8.)&lt;/li&gt;
              &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="sampleSoapService">
</xsd:element>
<xsd:element ref="analyser">
</xsd:element>
<xsd:element ref="validator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlRewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="regExReplacer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="abort" type="com.predic8.membrane.core.config.spring.AbortParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Plugins are usually applied to requests and responses.
 In case of errors, the flow returns and &lt;i&gt;handleAbort()&lt;/i&gt; is called on plugins
 going back the chain.
 By nesting plugins into an &lt;abort&gt; you can limit their application to abort flows only.
 On plugins nested in &lt;abort&gt; handleResponse() is called not handleAbort() in order to
 allow normal processing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiKey">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Secures APIs by validating keys stored in either files or proxies.xml. Keys can be received from clients via HTTP headers or URL query parameters. Additional permission checks are possible through scope validation - scopes are loaded into an Exchange property and can be checked using the "hasScope()" SpEL function.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="oauth2authserver">
</xsd:element>
<xsd:element ref="adminConsole">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="urlNormalizer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Replaces "/./" in the request URI's path by "/".
              &lt;/p&gt;
              &lt;p&gt;
              Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
              links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
              root). The SOA model then combines "&lt;a href="http://foo/material/ArticleService?wsdl"&gt;http://foo/material/ArticleService?wsdl&lt;/a&gt;" and
              "./ArticleService?xsd=1" to "&lt;a href="http://foo/material/./ArticleService?xsd=1"&gt;http://foo/material/./ArticleService?xsd=1&lt;/a&gt;". This URI is sent to Membrane's
              new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
              not match.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ruleMatching">
</xsd:element>
<xsd:element ref="oauth2PermissionChecker">
</xsd:element>
<xsd:element ref="for">
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="fileStore">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="dir" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="limitedMemoryExchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Stores exchange objects in-memory until a memory threshold is reached. When the threshold is reached and
 new exchanges arrive then old exchanges will be dropped (starting from oldest ascending) until the exchange can be
 stored. The LimitedMemoryExchangeStore is the default ExchangeStore Membrane uses.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="maxSize" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Threshold limit in bytes until old exchanges are dropped.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 1048576&lt;i&gt;(1Mb)&lt;/i&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 1000000&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="maxBodySize" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Maximum body size limit in bytes. If bodies are collected, which exceed this limit, the
 strategy determines, what happens.&lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 100000&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="bodyExceedingMaxSizeStrategy" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The strategy to use (TRUNCATE or ERROR) when a HTTP message body is larger than the &lt;tt&gt;maxBodySize&lt;/tt&gt;.
 &lt;tt&gt;TRUNCATE&lt;/tt&gt; means that only the first bytes are kept in memory. &lt;tt&gt;ERROR&lt;/tt&gt; means that HTTP requests
 exceeding this limit will cause an error and not be processed any further: If the request exceeds the limit, it will
 not be processed further; if the response exceeds the limit, it will not be processed further. ("Further processing"
 usually includes transmission over a network.)&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; TRUNCATE&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="cache">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Don't use, this does NOT implement valid HTTP caching.
              &lt;/p&gt;
              &lt;p&gt;
                  We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                  the Docker Registry for offline use.
                  The cache does not revalidate any responses, so machines querying the cache for Debian
                  package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                  This is - simply put - the only use case, where using this class makes any sense.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="1">
<xsd:element ref="inMemoryStore">
</xsd:element>
<xsd:element ref="fileStore">
</xsd:element>
</xsd:choice>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.SslProxyrouterIpResolverParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element ref="httpClientConfig">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element ref="ssl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="routerIps" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="port" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; If not set (=0), the default port of the connection protocol (https) is used.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="errorOutcome" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; ABORT&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="statisticsJDBC">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
 database (one row per exchange).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="dataSource" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The spring bean ID of a data source bean.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="postMethodOnly" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="createTable" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; toggle to try automatic table creation or disable table creation altogether&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="soapOnly" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="index">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
              To use this feature just add a serviceProxy containing the index
              element. Of course you can protect the service proxy by using
              SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="router">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Membrane API Gateway's main object.
 &lt;/p&gt;
 &lt;p&gt;
 The router is a Spring Lifecycle object: It is automatically started and stopped according to the
 Lifecycle of the Spring Context containing it. In Membrane's standard setup (standalone or in a J2EE web
 app), Membrane itself controls the creation of the Spring Context and its Lifecycle.
 &lt;/p&gt;
 &lt;p&gt;
 In this case, the router is &lt;i&gt;hot deployable&lt;/i&gt;: It can monitor &lt;i&gt;proxies.xml&lt;/i&gt;, the Spring
 configuration file, for changes and reinitialize the Spring Context, when a change is detected. Note
 that, during the Spring Context restart, the router object itself along with almost all other Membrane
 objects (interceptors, etc.) will be recreated.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element ref="uriFactory">
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element ref="httpClientConfig">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element ref="transport">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transport receives messages from clients and invokes interceptors in the request and response flow.
              The interceptors that are engaged with the transport are global and are invoked for each message flowing
              through the router.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element ref="serviceProxy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              A service proxy can be deployed on front of a Web server, Web Service or a REST resource. It conceals
              the server and offers the same interface as the target server to its clients.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="sslProxy">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="api">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The api proxy extends the serviceProxy with API related functions like OpenAPI support and path parameters.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapProxy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 A SOAP proxy automatically configures itself using a WSDL description. It reads the WSDL to extract:
 &lt;/p&gt;
 - The &lt;soap:address/&gt; for target, port, and path.
 &lt;p&gt;
 The proxy sits in front of a SOAP Web Service, masking it while providing the same interface to clients
 as the target server. The proxy serves the WSDL to gateway clients, with the WSDL address pointing to the proxy
 instead of the backend. This ensures that client requests using the WSDL are routed through the API Gateway.
 &lt;/p&gt;
 Additionally, the SOAP proxy:
 - Can validate requests against the WSDL
 - Provides a simple service explorer&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; If the WSDL specified by the &lt;i&gt;wsdl&lt;/i&gt; attribute is unavailable at startup, the &lt;soapProxy&gt;
 becomes inactive. Reinitialization can be triggered via the admin console or automatically by the
 {@link Router}, which periodically attempts to restore the proxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="proxy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Clients can send HTTP requests to a proxy that forward the request to a Web server. It acts on behalf of the client.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="stompProxy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Proxies incoming STOMP CONNECT requests. Use a &lt;stompClient&gt; to forward these requests so some other machine.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="internal">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Internal proxy that can only be invoked by other proxies within the gateway. An internal
 proxy does not listen on any port.&lt;/p&gt;
 &lt;p&gt;Internal proxies are useful to better structure the configuration of the gateway.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="exchangeStore" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Spring Bean ID of an {@link ExchangeStore}. The exchange store will be used by this router's
 components ({@link AdminConsoleInterceptor}, {@link ExchangeStoreInterceptor}, etc.) by default, if
 no other exchange store is explicitly set to be used by them.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; create a {@link LimitedMemoryExchangeStore} limited to the size of 1 MB.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="hotDeploy" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Whether changes to the router's configuration file should automatically trigger a restart.
 &lt;/p&gt;
 &lt;p&gt;
 Monitoring the router's configuration file &lt;i&gt;proxies.xml&lt;/i&gt; is only possible, if the router
 is created by a Spring Application Context which supports monitoring.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="retryInitInterval" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; number of milliseconds after which reinitialization of &lt;soapProxy&gt;s should be attempted periodically&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 5 minutes&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="retryInit" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Whether the router should continue startup, if initialization of a rule (proxy, serviceProxy or soapProxy) failed
 (for example, when a WSDL a component depends on could not be downloaded).&lt;/p&gt;
 &lt;p&gt;If false, the router will exit with code -1 just after startup, when the initialization of a rule failed.&lt;/p&gt;
 &lt;p&gt;If true, the router will continue startup, and all rules which could not be initialized will be &lt;i&gt;inactive&lt;/i&gt; (=not
 {@link Proxy#isActive()}).&lt;/p&gt;
 &lt;h3&gt;Inactive rules&lt;/h3&gt;
 &lt;p&gt;Inactive rules will simply be ignored for routing decisions for incoming requests.
 This means that requests for inactive rules might be routed using different routes or result in a "400 Bad Request"
 when no active route could be matched to the request.&lt;/p&gt;
 &lt;p&gt;Once rules become active due to reinitialization, they are considered in future routing decision.&lt;/p&gt;
 &lt;h3&gt;Reinitialization&lt;/h3&gt;
 &lt;p&gt;Inactive rules may be &lt;i&gt;reinitialized&lt;/i&gt; and, if reinitialization succeeds, become active.&lt;/p&gt;
 &lt;p&gt;By default, reinitialization is attempted at regular intervals using a timer (see {@link #setRetryInitInterval(int)}).&lt;/p&gt;
 &lt;p&gt;Additionally, using the {@link AdminConsoleInterceptor}, an admin may trigger reinitialization of inactive rules at any time.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="production" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;By default the error messages Membrane sends back to an HTTP client provide information to help the caller
 find the problem. The caller might even get sensitive information. In production the error messages should not reveal
 to much details. With this option you can put Membrane in production mode and reduce the amount of information in
 error messages.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="jmx" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="wsdlPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;wsdlPublisher&lt;/i&gt; serves WSDL files (and attached XML Schema Documents), if your
 backend service does not already do so.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="wsdl" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The WSDL (URL or file).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; /WEB-INF/wsdl/ArticleService.wsdl&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.SupportedClaimsclaimParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="webServiceExplorer">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="wsdl" type="xsd:string" use="required">
</xsd:attribute>
<xsd:attribute name="portName" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="logContext">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="private">
<xsd:complexType>
<xsd:complexContent mixed="true">
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/></xsd:sequence>
<xsd:attribute name="location" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See &lt;a href="https://www.membrane-soa.org/service-proxy-doc/current/configuration/location.htm"&gt;here&lt;/a&gt; for a description of the format.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="apiKeyFileStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Loads api keys from a file. File has to be one key per line, blank lines for formatting are allowed. Optionally, a comma separated list of scopes after the key and a colon in between the two. Hash symbol can be used for comments at the end of each line, including empty lines.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; See: https://github.com/membrane/api-gateway/blob/master/distribution/examples/security/api-key/simple/demo-keys.txt&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="location" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Path/URL to the api key file.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.DnsOperatorParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:complexType name="com.predic8.membrane.core.config.spring.AuthenticationParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="username" type="xsd:string" use="required">
</xsd:attribute>
<xsd:attribute name="password" type="xsd:string" use="required">
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="APIsJSON">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="rootDomain" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="collectionId" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="name" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="description" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="url" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="created" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="modified" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="memcachedSessionManager">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="expiresAfterSeconds" type="spel_number" >
</xsd:attribute>
<xsd:attribute name="domain" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="httpOnly" type="spel_boolean" >
</xsd:attribute>
<xsd:attribute name="sameSite" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="issuer" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="ttlExpiryRefreshOnAccess" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; controls if the expiry refreshes to expiresAfterSeconds on access (true) or if it should not refresh (false)&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="secure" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; forces secure cookie attribute even when no ssl context is present (e.g. TLS termination in front of membrane)&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="sessionCookie" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; if true removes the expire part of a set cookie header and thus makes it a session cookie&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="connector" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="cookiePrefix" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; randomly chosen 8-character long string.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="api">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The api proxy extends the serviceProxy with API related functions like OpenAPI support and path parameters.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element name="description" type="com.predic8.membrane.core.config.spring.DescriptionParser">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Deploys an API from an OpenAPI document.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element name="openapi" type="com.predic8.membrane.core.config.spring.OpenapiParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Reads an OpenAPI description and deploys an API with the information of it.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If set, Membrane will only consider this rule, if the path of incoming HTTP requests matches.
 {@link Path} supports starts-with and regex matching.
 &lt;/p&gt;
 &lt;p&gt;
 If used in a {@link SOAPProxy}, this causes path rewriting of SOAP requests and in the WSDL to
 automatically be configured.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element name="path" type="com.predic8.membrane.core.config.spring.PathParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The value of the content will be taken to match the path.
              &lt;/p&gt;

              &lt;p&gt;
              If &lt;tt&gt;isRegExp="true"&lt;/tt&gt;, the whole path has to match the given regular expression. If
              &lt;tt&gt;isRegExp="false"&lt;/tt&gt;, the path has to start with the given string.
              &lt;/p&gt;

              &lt;p&gt;
              If &lt;tt&gt;&lt;path /&gt;&lt;/tt&gt; is a child element of a &lt;tt&gt;&lt;soapProxy /&gt;&lt;/tt&gt;, the &lt;tt&gt;isRegExp&lt;/tt&gt;
              attribute must not be present.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Configures the usage of inbound SSL (HTTPS).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element ref="ssl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element ref="httpClient">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
 Server using the HTTP protocol. Usually it will be globally used
 inside the transport. However, it is also possible to use it
 inside a proxy to give the proxy an individual configuration for
 its outgoing HTTP connection that is different from the global
 configuration in the transport.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtAuth">
</xsd:element>
<xsd:element ref="interceptor">
</xsd:element>
<xsd:element ref="tcp">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="tokenValidator">
</xsd:element>
<xsd:element ref="beautifier">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Beautifies request and response bodies. Supported are the Formats: JSON, XML&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="static">
</xsd:element>
<xsd:element ref="jsonProtection">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="http2xml">
</xsd:element>
<xsd:element name="echo" type="com.predic8.membrane.core.config.spring.EchoParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Returns the flow of plugins and copies the content of the
 request into a new response. The response has a status code of 200.
 Useful for testing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xml2Json">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If enabled converts body content from xml to json.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Can be used for both request and response. Xml file assumed to be in UTF-8. If input is invalid it returns
 empty json object.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="authHead2Body">
</xsd:element>
<xsd:element ref="webServer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
 "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
 &lt;/p&gt;
 &lt;p&gt;
 The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
 HTTP response with the contents of a file, or a "404 Not Found." error.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="internalRouting">
</xsd:element>
<xsd:element ref="exchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
              might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="dispatching">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
 element to the list of destinations of the exchange object. It
 must be placed into the transport to make Service Proxies Work
 properly. It has to be placed after the ruleMatching
 interceptor. The ruleMatching interceptor looks up a service
 proxy for an incoming request and places it into the exchange
 object. The dispatching interceptor needs the service proxy to
 get information about the target.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shadowing">
</xsd:element>
<xsd:element ref="openapiPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;openapiPublisher&lt;/i&gt; serves OpenAPI documents
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessControl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
              requested resource.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="acmeHttpChallenge">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See the documentation of the &lt;code&gt;&lt;acme /&gt;&lt;/code&gt; element for usage details.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="transform">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transform feature applies an XSLT transformation to the content in the body of a message. After the
              transformation the body content is replaced with the result of the transformation.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Rewrites or redirects the path of incoming requests based on a mapping.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rest2Soap">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xenAuthentication">
</xsd:element>
<xsd:element ref="graphQLProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Check GraphQL-over-HTTP requests, enforcing several limits and/or restrictions. This effectively helps to reduce
 the attack surface.
 &lt;p&gt;
 GraphQL Specification "October2021" is used. (But GraphQL only covers formulation of Documents/Queries.)
 &lt;/p&gt;
 &lt;p&gt;
 GraphQL-over-HTTP, which specifies how to submit GraphQL queries via HTTP, has not been released/finalized yet. We
 therefore use Version
 &lt;a href="https://github.com/graphql/graphql-over-http/blob/a1e6d8ca248c9a19eb59a2eedd988c204909ee3f/spec/GraphQLOverHTTP.md"&gt;a1e6d8ca&lt;/a&gt;.
 &lt;/p&gt;
 &lt;p&gt;
 Only GraphQL documents conforming to the 'ExecutableDocument' of the grammar are allowed: This includes the usual
 'query', 'mutation', 'subscription' and 'fragment's.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapOperationExtractor">
</xsd:element>
<xsd:element ref="balancer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="reverseProxying">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
 as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
 hostnames and ports used to access Membrane  vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clamav">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Delegates virus checks to an external Virus Scanner.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="destination">
</xsd:element>
<xsd:element ref="requireAuth">
</xsd:element>
<xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;request&gt; Element you can limit their application to requests only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="cache">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Don't use, this does NOT implement valid HTTP caching.
              &lt;/p&gt;
              &lt;p&gt;
                  We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                  the Docker Registry for offline use.
                  The cache does not revalidate any responses, so machines querying the cache for Debian
                  package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                  This is - simply put - the only use case, where using this class makes any sense.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsJDBC">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
 database (one row per exchange).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="index">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
              To use this feature just add a serviceProxy containing the index
              element. Of course you can protect the service proxy by using
              SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;wsdlPublisher&lt;/i&gt; serves WSDL files (and attached XML Schema Documents), if your
 backend service does not already do so.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="webServiceExplorer">
</xsd:element>
<xsd:element ref="logContext">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="APIsJSON">
</xsd:element>
<xsd:element ref="flowInitiator">
</xsd:element>
<xsd:element ref="counter">
</xsd:element>
<xsd:element ref="rateLimiter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;rateLimiter&lt;/i&gt; plugin limits the number of requests of a client in a period of time.
 As a default the client requests are grouped by client-Ip address and then counted. There are lots of
 possibilities to group the requests using the keyExpression. The requests can even be counted from different
 clients together.&lt;/p&gt;
 &lt;p&gt;When the gateway is located behind a loadbalancer then
 the client-Ip address is not the one from the client but the address from the balancer. To get the real Ip-address loadbalancers,
 &lt;i&gt;Web Application Firewalls&lt;/i&gt; and reverse proxies set the ip from the original client into the &lt;i&gt;X-Forwarded-For&lt;/i&gt; HTTP
 header field. The limiter plugin can take the Ip-address from the header.&lt;/p&gt;
 &lt;p&gt;
 The X-Forwarded-For header can only be trusted when a trustworthy reverse proxy or load balancer is between the client and server. The gateway not should be
 reachable directly. Only activate this feature when you know what you are doing.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="call">
</xsd:element>
<xsd:element ref="oauth2Resource2">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
 authorization server as response.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="if">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The "if" interceptor supports conditional execution of nested plugins.
 &lt;/p&gt;
 See:
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorSpELTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorGroovyTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorJsonpathTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorXPathTest&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="template">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders the body content of a message from a template. The template can
 produce plain text, Json or XML. Variables in the template are substituted with values from the body,
 header, query parameters, etc. If the extension of a referenced template file is &lt;i&gt;.xml&lt;/i&gt; it will use
 &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_xmltemplateengine"&gt;XMLTemplateEngine&lt;/a&gt;
 otherwise &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_streamingtemplateengine"&gt;StreamingTemplateEngine&lt;/a&gt;.
 Have a look at the samples in &lt;a href="https://github.com/membrane/service-proxy/tree/master/distribution/examples"&gt;examples/template&lt;/a&gt;.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="groovyTemplate">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Uses the groovy template markup engine to produce HTML-based responses.
 &lt;code&gt;
 &lt;groovyTemplate&gt;&lt;![CDATA[
   html {
     head {
       title('Resource')
     }
     body {
       p('Hello from Membrane!')
     }
   }
 ]]&gt;&lt;/groovyTemplate&gt;
 &lt;/code&gt;
 &lt;p&gt;
 The word "spring" refers to the Spring ApplicationContext.
 The word "exc" refers to the Membrane Exchange being handled.
 The word "flow" refers to the current Membrane Flow (=REQUEST).
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessLog">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes exchange metrics into a Log4j appender&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Defaults to Apache Common Log pattern&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="prometheus">
</xsd:element>
<xsd:element ref="wadlRewriter">
</xsd:element>
<xsd:element ref="openTelemetry">
</xsd:element>
<xsd:element ref="limit">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Note that due to the streaming nature of Membrane, a request header may already have been passed on to
              the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
              aborted and the connection to the backend is simply closed.
              &lt;/p&gt;
              &lt;p&gt;
              To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
              &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="basicAuthentication">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="json2Xml">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts body payload from JSON to XML. The JSON must be an object other JSON documents e.g. arrays are not supported.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Resulting XML will be in UTF-8 encoding.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shutdown">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Shutdown interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                  Adds the ability to shutdown main router thread via an HTTP request.
                  Don't forget to setup security for this interceptor.
              &lt;/p&gt;
              &lt;p&gt;
                  Has undefined behavior when Membrane is &lt;b&gt;not&lt;/b&gt; started from command line
                  (=via the RouterCLI class, which &lt;tt&gt;service-proxy.ps1&lt;/tt&gt;/&lt;tt&gt;service-proxy.sh&lt;/tt&gt;
                  do use).
              &lt;/p&gt;
              &lt;p&gt;
                  Only actually terminates the running JVM, when used in the first
                  &lt;tt&gt;&lt;router&gt;&lt;/tt&gt; bean (which implicitly stands for
                  &lt;tt&gt;&lt;router id="router"&gt;&lt;/tt&gt;) called "router".
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="userFeature">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapStackTraceFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
              advised to test its functionality in combination with your SOAP service provider before deploying it in
              production.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="formValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiDocs">
</xsd:element>
<xsd:element ref="choose">
</xsd:element>
<xsd:element ref="testService">
</xsd:element>
<xsd:element ref="soap2Rest">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clusterNotification">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane API Gateway distribution.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setHeader">
</xsd:element>
<xsd:element ref="groovy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Groovy script. The script can access and manipulate data from the request and response.
 Use this or the Javascript plugin to extend the functions of Membrane by scripting.
 See: example/groovy for working samples&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtSign">
</xsd:element>
<xsd:element ref="statisticsProvider">
</xsd:element>
<xsd:element ref="replace">
</xsd:element>
<xsd:element ref="methodOverride">
</xsd:element>
<xsd:element ref="stompClient">
</xsd:element>
<xsd:element ref="webSocket">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
 attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="log">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages. The messages will appear either on the console or in
 a log file depending on the log configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="return">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Terminates the exchange flow. The returned response is determined in the following order:
 &lt;p&gt;
 1. If there is already a response in the exchange, that response is returned
 2. If there is no response in the exchange, the body and contentType of the request is copied into a new response.
 &lt;/p&gt;
 &lt;p&gt;
 The options statusCode and contentType will overwrite the values from the messages.
 &lt;/p&gt;
 &lt;p&gt;
 This plugin is useful together with the template plugin. See examples/template.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsCSV">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
              file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="openapiValidator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Validator for OpenAPI documents&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accountRegistration">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="kubernetesValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Kubernetes Integration is still experimental.
 &lt;p&gt;
 To create the CustomResourceDefinitions, apply kubernetes-config.yaml from
 core/target/classes/com/predic8/membrane/core/config/kubernetes/ or a part (e.g. the 'serviceproxies' CRD) of the file.
 &lt;/p&gt;
 &lt;p&gt;
 Create a key and certificate for TLS for &lt;a href="https://membrane-validator.membrane-soa.svc:444/"&gt;https://membrane-validator.membrane-soa.svc:444/&lt;/a&gt; and setup Membrane to serve
 this address. The configuration shown below configures Membrane on a fixed IP address outside of the Kubernetes cluster,
 but this is no requirement.
 &lt;/p&gt;
 &lt;p&gt;
 Embed the following serviceProxy and adjust the 'resources' attribute to a comma-separated list of CRDs that you applied.
 Note that while the CRDs have plural names, here you need to use the corresponding singular. Configure the "ssl" section
 using your key and certificate.
 &lt;/p&gt;
 &lt;code&gt;
 &gt;serviceProxy port="444"&gt;
 &gt;ssl&gt;
 &gt;key&gt;
 &gt;private&gt;
 -----BEGIN RSA PRIVATE KEY-----
 ...
 -----END RSA PRIVATE KEY-----
 &gt;/private&gt;
 &gt;certificate&gt;
 -----BEGIN CERTIFICATE-----
 ...
 -----END CERTIFICATE-----
 &gt;/certificate&gt;
 &gt;/key&gt;
 &gt;/ssl&gt;
 &gt;kubernetesValidation resources="serviceproxy" /&gt;
 &gt;/serviceProxy&gt;
 &lt;/code&gt;
 &lt;p&gt;
 Now register a Webhook to validate the new CRDs. (A note to the experts: Membrane's validation schemas are too
 complex to fit into the CRD, because they are highly nestable and self-referencing. We therefore use webhooks.)
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: admissionregistration.k8s.io/v1
 kind: ValidatingWebhookConfiguration
 metadata:
 name: membrane
 webhooks:
 - name: membrane.membrane-soa.org
 admissionReviewVersions: ["v1", "v1beta1"]
 failurePolicy: Fail
 rules:
 - operations: [ "*" ]
 apiGroups: [ "membrane-soa.org" ]
 apiVersions: [ "v1", "v1beta1" ]
 resources: [ "*" ]
 scope: "*"
 clientConfig:
 service:
 name: membrane-validator
 namespace: membrane-soa
 port: 444
 caBundle: LS0t...LQ0K        # base64 encoded, PEM-formatted CA certificate
 sideEffects: None
 ---
 apiVersion: v1
 kind: Namespace
 metadata:
 name: membrane-soa
 ---
 apiVersion: v1
 kind: Service
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 spec:
 ports:
 - port: 444
 ---
 apiVersion: v1
 kind: Endpoints
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 subsets:
 - addresses:
 - ip: 192.168.0.1   # Membrane's IP
 ports:
 - port: 444
 &lt;/code&gt;
 &lt;p&gt;
 Once this setup is complete, you can enable serviceProxies like this:
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: membrane-soa.org/v1beta1
 kind: serviceproxy
 metadata:
 name: demo
 namespace: membrane-soa
 spec:
 host: demo.predic8.de
 path:
 value: /some-path/
 interceptors:
 - response:
 interceptors:
 - groovy:
 src: |
 println "Hello!"
 target:
 host: thomas-bayer.com
 &lt;/code&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setProperty">
</xsd:element>
<xsd:element ref="javascript">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Javascript. The script can access and manipulate data from the request and response.
 Use this or the Groovy plugin to extend the functions of Membrane by scripting. See the samples in examples/javascript.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="paddingHeader">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="greaser">
</xsd:element>
<xsd:element ref="soapBody">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders a SOAP body for legacy intergration&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;response&gt; plugin you can limit their application to responses only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="throttle">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The throttle feature can slow down traffic to thwart denial of service attacks.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlContentFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
 using an XPath expression.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
 match a message at all. This can improve performance significantly, as a DOM tree does probably not have
 to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
 lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
 namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
 &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
 the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
 constructed.
 &lt;/p&gt;
 &lt;p&gt;
 If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
 XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
 modified reconstituted message.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="headerFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
 The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ntlm">
</xsd:element>
<xsd:element ref="login">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
              application.
              &lt;/p&gt;
              &lt;p&gt;
              Users firstly have to authenticate themselves against a directory server using a username and password.
              Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
              token verification, access to the web application is granted for the user's session. Single Sign On can
              easily be realized using a small source code extension or modification of a web application.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
              each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
              default implementations.)
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
              cell phone number, Single Sign On data, etc.).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
              session cookie).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
              attempts for a specified amount of time.
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
              secondary channel like text messaging).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;/ul&gt;
              &lt;p&gt;
              &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
              title="login interceptor workflow"/&gt;
              &lt;/p&gt;
              &lt;p&gt;
              (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
              possible.)
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
              valid, the workflow is as follows:
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
              &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
              &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
              used. Steps 5 and 6.)&lt;/li&gt;
              &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
              &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
              was directly requested). (Step 8.)&lt;/li&gt;
              &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="sampleSoapService">
</xsd:element>
<xsd:element ref="analyser">
</xsd:element>
<xsd:element ref="validator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlRewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="regExReplacer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="abort" type="com.predic8.membrane.core.config.spring.AbortParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Plugins are usually applied to requests and responses.
 In case of errors, the flow returns and &lt;i&gt;handleAbort()&lt;/i&gt; is called on plugins
 going back the chain.
 By nesting plugins into an &lt;abort&gt; you can limit their application to abort flows only.
 On plugins nested in &lt;abort&gt; handleResponse() is called not handleAbort() in order to
 allow normal processing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiKey">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Secures APIs by validating keys stored in either files or proxies.xml. Keys can be received from clients via HTTP headers or URL query parameters. Additional permission checks are possible through scope validation - scopes are loaded into an Exchange property and can be checked using the "hasScope()" SpEL function.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="oauth2authserver">
</xsd:element>
<xsd:element ref="adminConsole">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="urlNormalizer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Replaces "/./" in the request URI's path by "/".
              &lt;/p&gt;
              &lt;p&gt;
              Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
              links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
              root). The SOA model then combines "&lt;a href="http://foo/material/ArticleService?wsdl"&gt;http://foo/material/ArticleService?wsdl&lt;/a&gt;" and
              "./ArticleService?xsd=1" to "&lt;a href="http://foo/material/./ArticleService?xsd=1"&gt;http://foo/material/./ArticleService?xsd=1&lt;/a&gt;". This URI is sent to Membrane's
              new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
              not match.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ruleMatching">
</xsd:element>
<xsd:element ref="oauth2PermissionChecker">
</xsd:element>
<xsd:element ref="for">
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element name="target" type="com.predic8.membrane.core.config.spring.TargetParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The destination where the service proxy will send messages to. Use the target element, if you want
 to send the messages to a static target. If you want to use dynamic destinations have a look at the
 &lt;a href="https://membrane-soa.org/service-proxy-doc/configuration/reference/router.htm"&gt;content based router&lt;/a&gt;.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="name" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The name as shown in the Admin Console.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; By default, a name will be automatically generated from the target host, port, etc.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="blockRequest" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;legacy attribute&lt;/i&gt; for usage by Membrane Monitor&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="blockResponse" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;legacy attribute&lt;/i&gt; for usage by Membrane Monitor&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="port" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The port Membrane listens on for incoming connections.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 8080&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 80&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="ip" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If present, binds the port only on the specified IP. Useful for hosts with multiple IP addresses.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 127.0.0.1&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;not set&lt;/i&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="host" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;A space separated list of hostnames. If set, Membrane will only consider this rule, if the "Host"
 header of incoming HTTP requests matches one of the hostnames.
 &lt;/p&gt;
 &lt;p&gt;
 The asterisk '*' can be used for basic globbing (to match any number, including zero, characters).
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; predic8.de *.predic8.de&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;not set&lt;/i&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="method" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If set, Membrane will only consider this rule, if the method (GET, PUT, POST, DELETE, etc.)
              header of incoming HTTP requests matches. The asterisk '*' matches any method.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; GET&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; *&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="test" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="language" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="ssl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element ref="keystore">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Used to manually compose the keystore.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element ref="key">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Experimental.
 &lt;p&gt;Allows to insert a PEM block containing the key (as well as one or more blocks for the
 certificate(s)) directly into the proxies.xml file.&lt;/p&gt;
 &lt;p&gt;This is an alternative for {@link KeyStore}.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Used to dynamically generate a key for the incoming connection on the fly.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element ref="keyGenerator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Experimental.
 &lt;p&gt;Allows to dynamically generate keys/certificates for arbitrary domain names on the fly, signed by a specified
 root CA key.&lt;/p&gt;
 &lt;p&gt;This is an alternative for {@link Key} and {@link KeyStore}.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element ref="truststore">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Used to manually compose the truststore.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element ref="trust">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Allows to insert one or more PEM blocks containing the certificates to be trusted directly into the proxies.xml
 file.&lt;/p&gt;
 &lt;p&gt;This is an alternative for {@link TrustStore}.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element ref="acme">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures an ACME (RFC 8555) client, e.g. to retrieve TLS certificates from
 &lt;a href="https://letsencrypt.org/"&gt;Let's Encrypt&lt;/a&gt;.&lt;/p&gt;
 &lt;p&gt;To store the key material and certificates, you can use the local file system or your Kubernetes cluster.&lt;/p&gt;
 &lt;p&gt;
     To use ACME:
     &lt;ol&gt;
         &lt;li&gt;Register your domain and point the DNS record to your server(s) runnig Membrane.&lt;/li&gt;
         &lt;li&gt;Let Membrane listen on port 80 and use the &lt;code&gt;&lt;acmeHttpChallenge /&gt;&lt;/code&gt; (see below).&lt;/li&gt;
         &lt;li&gt;Let Membrane listen on port 443 and use &lt;code&gt;&lt;ssl&gt;&lt;acme .../&gt;&lt;ssl&gt;&lt;/code&gt; (see below).
         Here, you have to configure where Membrane will store the keys and certificates.
         &lt;/li&gt;
     &lt;/ol&gt;
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="algorithm" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;a href="http://docs.oracle.com/javase/6/docs/api/javax/net/ssl/KeyManagerFactory.html#getDefaultAlgorithm%28%29"&gt;getDefaultAlgorithm()&lt;/a&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; SunX509&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; java default&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="protocol" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;a href="http://docs.oracle.com/javase/6/docs/api/javax/net/ssl/SSLContext.html#getInstance%28java.lang.String%29"&gt;SSLContext.getInstance()&lt;/a&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; TLS&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="protocols" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;a href="http://docs.oracle.com/javase/6/docs/api/javax/net/ssl/SSLSocket.html#setEnabledProtocols%28java.lang.String[]%29"&gt;SSLSocket.setEnabledProtocols()&lt;/a&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; TLS*&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="ciphers" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Space separated list of ciphers to allow. &lt;a href="http://docs.oracle.com/javase/6/docs/api/javax/net/ssl/SSLSocketFactory.html#getSupportedCipherSuites%28%29"&gt;getSupportedCipherSuites()&lt;/a&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; TLS_ECDH_anon_WITH_RC4_128_SHA&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; all system default ciphers&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="clientAuth" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Either not set (=no), or &lt;tt&gt;want&lt;/tt&gt; or &lt;tt&gt;need&lt;/tt&gt;.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; &lt;tt&gt;need&lt;/tt&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;not set&lt;/i&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="ignoreTimestampCheckFailure" type="spel_boolean" >
</xsd:attribute>
<xsd:attribute name="endpointIdentificationAlgorithm" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See &lt;a href="http://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLParameters.html#setEndpointIdentificationAlgorithm%28java.lang.String%29"&gt;setEndpointIdentificationAlgorithm()&lt;/a&gt;.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; HTTPS&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="serverName" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Setting the serverName tells Java to use the SNI (&lt;a href="http://www.rfc-base.org/txt/rfc-3546.txt"&gt;...&lt;/a&gt;) on outbound
		 TLS connections to indicate to the TLS server, which hostname the client wants to connect to.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; same as target hostname.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="showSSLExceptions" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Tells Membrane to show SSL exceptions in its log&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="useAsDefault" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; whether to use the SSLContext built from this SSLParser when no SNI header was transmitted.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="useExperimentalHttp2" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; whether to enable receiving HTTP/2 requests. (experimental)&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="uriFactory">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="allowIllegalCharacters" type="spel_boolean" >
</xsd:attribute>
<xsd:attribute name="autoEscapeBackslashes" type="spel_boolean" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="flowInitiator">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element ref="loginParameter">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="triggerFlow" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="oauth2" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="defaultFlow" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="afterLoginUrl" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="logoutBeforeFlow" type="spel_boolean" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="counter">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="name" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Sets the name that will be displayed on the web page.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; Mock Node 1&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="rateLimiter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;rateLimiter&lt;/i&gt; plugin limits the number of requests of a client in a period of time.
 As a default the client requests are grouped by client-Ip address and then counted. There are lots of
 possibilities to group the requests using the keyExpression. The requests can even be counted from different
 clients together.&lt;/p&gt;
 &lt;p&gt;When the gateway is located behind a loadbalancer then
 the client-Ip address is not the one from the client but the address from the balancer. To get the real Ip-address loadbalancers,
 &lt;i&gt;Web Application Firewalls&lt;/i&gt; and reverse proxies set the ip from the original client into the &lt;i&gt;X-Forwarded-For&lt;/i&gt; HTTP
 header field. The limiter plugin can take the Ip-address from the header.&lt;/p&gt;
 &lt;p&gt;
 The X-Forwarded-For header can only be trusted when a trustworthy reverse proxy or load balancer is between the client and server. The gateway not should be
 reachable directly. Only activate this feature when you know what you are doing.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="language" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the language of the 'test' condition&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; SpEL, groovy, jsonpath, xpath&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; groovy&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="requestLimit" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Number of requests within the period of measurement.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 1000&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="requestLimitDuration" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Duration after the limit is reset in the &lt;i&gt;ISO 8600 Duration&lt;/i&gt; format, e.g. PT10S for 10 seconds,
 PT5M for 5 minutes or PT8H for eight hours.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; PT3600S&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="keyExpression" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The expression the ratelimiter should use to group the requests before counting. The Spring Expression Language (SpEL)
 is used as language. In the expression the build-in variables request, header, properties can be used.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; ip-address&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="trustedProxyList" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Comma separated list of trusted proxy servers and loadbalancers. Used to evaluate the X-Forwarded-For header.
 If both &lt;b&gt;trustedProxyList&lt;/b&gt; and &lt;b&gt;trustedProxyCount&lt;/b&gt; is specified, the trustedProxyList is used to
 determine the client ip address. To make this configuration active set &lt;pre&gt;isTrustForwardedFor&lt;/pre&gt; to true.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; empty String&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="trustedProxyCount" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Number of trusted proxy servers and loadbalancers. Used to evaluate the X-Forwarded-For header.
 If both &lt;pre&gt;trustedProxyList&lt;/pre&gt; and &lt;pre&gt;trustedProxyCount&lt;/pre&gt; is specified, the trustedProxyList is used to
 determine the client ip address. To make this configuration active set &lt;pre&gt;isTrustForwardedFor&lt;/pre&gt; to true.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 0&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="trustForwardedFor" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Set this only to true if you know that are you doing. The function of the ratelimter relays on current 'X-ForwaredFor' header values.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.ProxyconfigurationParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element ref="ssl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="host" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="port" type="spel_number" >
</xsd:attribute>
<xsd:attribute name="password" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="username" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="authentication" type="spel_boolean" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="call">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="language" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the language of the 'test' condition&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; SpEL, groovy, jsonpath, xpath&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; groovy&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="url" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Sets the category of the logged message.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; Membrane&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; com.predic8.membrane.core.interceptor.log.LogInterceptor&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="certificate">
<xsd:complexType>
<xsd:complexContent mixed="true">
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/></xsd:sequence>
<xsd:attribute name="location" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See &lt;a href="https://www.membrane-soa.org/service-proxy-doc/current/configuration/location.htm"&gt;here&lt;/a&gt; for a description of the format.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="oauth2Resource2">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
 authorization server as response.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element ref="memcachedSessionManager">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="inMemorySessionManager2">
</xsd:element>
<xsd:element ref="redisSessionManager">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtSessionManager">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element ref="publicURL">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="1">
<xsd:element name="github" type="com.predic8.membrane.core.config.spring.GithubParser">
</xsd:element>
<xsd:element ref="membrane">
</xsd:element>
<xsd:element name="google" type="com.predic8.membrane.core.config.spring.GoogleParser">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element ref="memcachedOriginalExchangeStore">
</xsd:element>
<xsd:element ref="redisOriginalExchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Used for storing exchanges temporarily in Redis. Supports authentication with or without password and username&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="cookieOriginalExchangeStore">
</xsd:element>
<xsd:element ref="sessionOriginalExchangeStore">
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element ref="loginParameter">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="skipUserInfo" type="spel_boolean" >
</xsd:attribute>
<xsd:attribute name="revalidateTokenAfter" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; time in seconds until a oauth2 access token is revalidatet with authorization server. This is disabled for values &lt; 0&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; -1&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="callbackPath" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the path used for the OAuth2 callback. ensure that it does not collide with any path used by the application&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; oauth2callback&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="customHeaderUserPropertyPrefix" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A user property prefix (e.g. "header"), which can be used to make the interceptor emit custom per-user headers.
 For example, if you have a user property "headerX: Y" on a user U, and the user U logs in, all requests belonging to this
 user will have an additional HTTP header "X: Y". If null, this feature is disabled.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; null&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="logoutUrl" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Path (as seen by the user agent) to call to trigger a log out.
 If the Authorization Server supports &lt;a href="https://openid.net/specs/openid-connect-rpinitiated-1_0.html"&gt;OpenID
 Connect RP-Initiated Logout 1.0&lt;/a&gt;, the user logout ("single log out") will be triggered there as well.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="afterLogoutUrl" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="appendAccessTokenToRequest" type="spel_boolean" >
</xsd:attribute>
<xsd:attribute name="afterErrorUrl" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="onlyRefreshToken" type="spel_boolean" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="wsInterceptor">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="refid" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Spring bean id of the referenced interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; myInterceptor&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="soapProxy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 A SOAP proxy automatically configures itself using a WSDL description. It reads the WSDL to extract:
 &lt;/p&gt;
 - The &lt;soap:address/&gt; for target, port, and path.
 &lt;p&gt;
 The proxy sits in front of a SOAP Web Service, masking it while providing the same interface to clients
 as the target server. The proxy serves the WSDL to gateway clients, with the WSDL address pointing to the proxy
 instead of the backend. This ensures that client requests using the WSDL are routed through the API Gateway.
 &lt;/p&gt;
 Additionally, the SOAP proxy:
 - Can validate requests against the WSDL
 - Provides a simple service explorer&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; If the WSDL specified by the &lt;i&gt;wsdl&lt;/i&gt; attribute is unavailable at startup, the &lt;soapProxy&gt;
 becomes inactive. Reinitialization can be triggered via the admin console or automatically by the
 {@link Router}, which periodically attempts to restore the proxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If set, Membrane will only consider this rule, if the path of incoming HTTP requests matches.
 {@link Path} supports starts-with and regex matching.
 &lt;/p&gt;
 &lt;p&gt;
 If used in a {@link SOAPProxy}, this causes path rewriting of SOAP requests and in the WSDL to
 automatically be configured.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element name="path" type="com.predic8.membrane.core.config.spring.PathParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The value of the content will be taken to match the path.
              &lt;/p&gt;

              &lt;p&gt;
              If &lt;tt&gt;isRegExp="true"&lt;/tt&gt;, the whole path has to match the given regular expression. If
              &lt;tt&gt;isRegExp="false"&lt;/tt&gt;, the path has to start with the given string.
              &lt;/p&gt;

              &lt;p&gt;
              If &lt;tt&gt;&lt;path /&gt;&lt;/tt&gt; is a child element of a &lt;tt&gt;&lt;soapProxy /&gt;&lt;/tt&gt;, the &lt;tt&gt;isRegExp&lt;/tt&gt;
              attribute must not be present.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Configures the usage of inbound SSL (HTTPS).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element ref="ssl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element ref="httpClient">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
 Server using the HTTP protocol. Usually it will be globally used
 inside the transport. However, it is also possible to use it
 inside a proxy to give the proxy an individual configuration for
 its outgoing HTTP connection that is different from the global
 configuration in the transport.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtAuth">
</xsd:element>
<xsd:element ref="interceptor">
</xsd:element>
<xsd:element ref="tcp">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="tokenValidator">
</xsd:element>
<xsd:element ref="beautifier">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Beautifies request and response bodies. Supported are the Formats: JSON, XML&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="static">
</xsd:element>
<xsd:element ref="jsonProtection">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="http2xml">
</xsd:element>
<xsd:element name="echo" type="com.predic8.membrane.core.config.spring.EchoParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Returns the flow of plugins and copies the content of the
 request into a new response. The response has a status code of 200.
 Useful for testing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xml2Json">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If enabled converts body content from xml to json.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Can be used for both request and response. Xml file assumed to be in UTF-8. If input is invalid it returns
 empty json object.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="authHead2Body">
</xsd:element>
<xsd:element ref="webServer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
 "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
 &lt;/p&gt;
 &lt;p&gt;
 The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
 HTTP response with the contents of a file, or a "404 Not Found." error.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="internalRouting">
</xsd:element>
<xsd:element ref="exchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
              might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="dispatching">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
 element to the list of destinations of the exchange object. It
 must be placed into the transport to make Service Proxies Work
 properly. It has to be placed after the ruleMatching
 interceptor. The ruleMatching interceptor looks up a service
 proxy for an incoming request and places it into the exchange
 object. The dispatching interceptor needs the service proxy to
 get information about the target.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shadowing">
</xsd:element>
<xsd:element ref="openapiPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;openapiPublisher&lt;/i&gt; serves OpenAPI documents
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessControl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
              requested resource.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="acmeHttpChallenge">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See the documentation of the &lt;code&gt;&lt;acme /&gt;&lt;/code&gt; element for usage details.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="transform">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transform feature applies an XSLT transformation to the content in the body of a message. After the
              transformation the body content is replaced with the result of the transformation.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Rewrites or redirects the path of incoming requests based on a mapping.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rest2Soap">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xenAuthentication">
</xsd:element>
<xsd:element ref="graphQLProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Check GraphQL-over-HTTP requests, enforcing several limits and/or restrictions. This effectively helps to reduce
 the attack surface.
 &lt;p&gt;
 GraphQL Specification "October2021" is used. (But GraphQL only covers formulation of Documents/Queries.)
 &lt;/p&gt;
 &lt;p&gt;
 GraphQL-over-HTTP, which specifies how to submit GraphQL queries via HTTP, has not been released/finalized yet. We
 therefore use Version
 &lt;a href="https://github.com/graphql/graphql-over-http/blob/a1e6d8ca248c9a19eb59a2eedd988c204909ee3f/spec/GraphQLOverHTTP.md"&gt;a1e6d8ca&lt;/a&gt;.
 &lt;/p&gt;
 &lt;p&gt;
 Only GraphQL documents conforming to the 'ExecutableDocument' of the grammar are allowed: This includes the usual
 'query', 'mutation', 'subscription' and 'fragment's.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapOperationExtractor">
</xsd:element>
<xsd:element ref="balancer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="reverseProxying">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
 as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
 hostnames and ports used to access Membrane  vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clamav">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Delegates virus checks to an external Virus Scanner.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="destination">
</xsd:element>
<xsd:element ref="requireAuth">
</xsd:element>
<xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;request&gt; Element you can limit their application to requests only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="cache">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Don't use, this does NOT implement valid HTTP caching.
              &lt;/p&gt;
              &lt;p&gt;
                  We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                  the Docker Registry for offline use.
                  The cache does not revalidate any responses, so machines querying the cache for Debian
                  package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                  This is - simply put - the only use case, where using this class makes any sense.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsJDBC">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
 database (one row per exchange).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="index">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
              To use this feature just add a serviceProxy containing the index
              element. Of course you can protect the service proxy by using
              SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;wsdlPublisher&lt;/i&gt; serves WSDL files (and attached XML Schema Documents), if your
 backend service does not already do so.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="webServiceExplorer">
</xsd:element>
<xsd:element ref="logContext">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="APIsJSON">
</xsd:element>
<xsd:element ref="flowInitiator">
</xsd:element>
<xsd:element ref="counter">
</xsd:element>
<xsd:element ref="rateLimiter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;rateLimiter&lt;/i&gt; plugin limits the number of requests of a client in a period of time.
 As a default the client requests are grouped by client-Ip address and then counted. There are lots of
 possibilities to group the requests using the keyExpression. The requests can even be counted from different
 clients together.&lt;/p&gt;
 &lt;p&gt;When the gateway is located behind a loadbalancer then
 the client-Ip address is not the one from the client but the address from the balancer. To get the real Ip-address loadbalancers,
 &lt;i&gt;Web Application Firewalls&lt;/i&gt; and reverse proxies set the ip from the original client into the &lt;i&gt;X-Forwarded-For&lt;/i&gt; HTTP
 header field. The limiter plugin can take the Ip-address from the header.&lt;/p&gt;
 &lt;p&gt;
 The X-Forwarded-For header can only be trusted when a trustworthy reverse proxy or load balancer is between the client and server. The gateway not should be
 reachable directly. Only activate this feature when you know what you are doing.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="call">
</xsd:element>
<xsd:element ref="oauth2Resource2">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
 authorization server as response.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="if">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The "if" interceptor supports conditional execution of nested plugins.
 &lt;/p&gt;
 See:
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorSpELTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorGroovyTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorJsonpathTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorXPathTest&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="template">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders the body content of a message from a template. The template can
 produce plain text, Json or XML. Variables in the template are substituted with values from the body,
 header, query parameters, etc. If the extension of a referenced template file is &lt;i&gt;.xml&lt;/i&gt; it will use
 &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_xmltemplateengine"&gt;XMLTemplateEngine&lt;/a&gt;
 otherwise &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_streamingtemplateengine"&gt;StreamingTemplateEngine&lt;/a&gt;.
 Have a look at the samples in &lt;a href="https://github.com/membrane/service-proxy/tree/master/distribution/examples"&gt;examples/template&lt;/a&gt;.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="groovyTemplate">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Uses the groovy template markup engine to produce HTML-based responses.
 &lt;code&gt;
 &lt;groovyTemplate&gt;&lt;![CDATA[
   html {
     head {
       title('Resource')
     }
     body {
       p('Hello from Membrane!')
     }
   }
 ]]&gt;&lt;/groovyTemplate&gt;
 &lt;/code&gt;
 &lt;p&gt;
 The word "spring" refers to the Spring ApplicationContext.
 The word "exc" refers to the Membrane Exchange being handled.
 The word "flow" refers to the current Membrane Flow (=REQUEST).
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessLog">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes exchange metrics into a Log4j appender&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Defaults to Apache Common Log pattern&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="prometheus">
</xsd:element>
<xsd:element ref="wadlRewriter">
</xsd:element>
<xsd:element ref="openTelemetry">
</xsd:element>
<xsd:element ref="limit">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Note that due to the streaming nature of Membrane, a request header may already have been passed on to
              the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
              aborted and the connection to the backend is simply closed.
              &lt;/p&gt;
              &lt;p&gt;
              To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
              &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="basicAuthentication">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="json2Xml">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts body payload from JSON to XML. The JSON must be an object other JSON documents e.g. arrays are not supported.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Resulting XML will be in UTF-8 encoding.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shutdown">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Shutdown interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                  Adds the ability to shutdown main router thread via an HTTP request.
                  Don't forget to setup security for this interceptor.
              &lt;/p&gt;
              &lt;p&gt;
                  Has undefined behavior when Membrane is &lt;b&gt;not&lt;/b&gt; started from command line
                  (=via the RouterCLI class, which &lt;tt&gt;service-proxy.ps1&lt;/tt&gt;/&lt;tt&gt;service-proxy.sh&lt;/tt&gt;
                  do use).
              &lt;/p&gt;
              &lt;p&gt;
                  Only actually terminates the running JVM, when used in the first
                  &lt;tt&gt;&lt;router&gt;&lt;/tt&gt; bean (which implicitly stands for
                  &lt;tt&gt;&lt;router id="router"&gt;&lt;/tt&gt;) called "router".
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="userFeature">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapStackTraceFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
              advised to test its functionality in combination with your SOAP service provider before deploying it in
              production.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="formValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiDocs">
</xsd:element>
<xsd:element ref="choose">
</xsd:element>
<xsd:element ref="testService">
</xsd:element>
<xsd:element ref="soap2Rest">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clusterNotification">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane API Gateway distribution.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setHeader">
</xsd:element>
<xsd:element ref="groovy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Groovy script. The script can access and manipulate data from the request and response.
 Use this or the Javascript plugin to extend the functions of Membrane by scripting.
 See: example/groovy for working samples&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtSign">
</xsd:element>
<xsd:element ref="statisticsProvider">
</xsd:element>
<xsd:element ref="replace">
</xsd:element>
<xsd:element ref="methodOverride">
</xsd:element>
<xsd:element ref="stompClient">
</xsd:element>
<xsd:element ref="webSocket">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
 attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="log">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages. The messages will appear either on the console or in
 a log file depending on the log configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="return">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Terminates the exchange flow. The returned response is determined in the following order:
 &lt;p&gt;
 1. If there is already a response in the exchange, that response is returned
 2. If there is no response in the exchange, the body and contentType of the request is copied into a new response.
 &lt;/p&gt;
 &lt;p&gt;
 The options statusCode and contentType will overwrite the values from the messages.
 &lt;/p&gt;
 &lt;p&gt;
 This plugin is useful together with the template plugin. See examples/template.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsCSV">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
              file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="openapiValidator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Validator for OpenAPI documents&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accountRegistration">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="kubernetesValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Kubernetes Integration is still experimental.
 &lt;p&gt;
 To create the CustomResourceDefinitions, apply kubernetes-config.yaml from
 core/target/classes/com/predic8/membrane/core/config/kubernetes/ or a part (e.g. the 'serviceproxies' CRD) of the file.
 &lt;/p&gt;
 &lt;p&gt;
 Create a key and certificate for TLS for &lt;a href="https://membrane-validator.membrane-soa.svc:444/"&gt;https://membrane-validator.membrane-soa.svc:444/&lt;/a&gt; and setup Membrane to serve
 this address. The configuration shown below configures Membrane on a fixed IP address outside of the Kubernetes cluster,
 but this is no requirement.
 &lt;/p&gt;
 &lt;p&gt;
 Embed the following serviceProxy and adjust the 'resources' attribute to a comma-separated list of CRDs that you applied.
 Note that while the CRDs have plural names, here you need to use the corresponding singular. Configure the "ssl" section
 using your key and certificate.
 &lt;/p&gt;
 &lt;code&gt;
 &gt;serviceProxy port="444"&gt;
 &gt;ssl&gt;
 &gt;key&gt;
 &gt;private&gt;
 -----BEGIN RSA PRIVATE KEY-----
 ...
 -----END RSA PRIVATE KEY-----
 &gt;/private&gt;
 &gt;certificate&gt;
 -----BEGIN CERTIFICATE-----
 ...
 -----END CERTIFICATE-----
 &gt;/certificate&gt;
 &gt;/key&gt;
 &gt;/ssl&gt;
 &gt;kubernetesValidation resources="serviceproxy" /&gt;
 &gt;/serviceProxy&gt;
 &lt;/code&gt;
 &lt;p&gt;
 Now register a Webhook to validate the new CRDs. (A note to the experts: Membrane's validation schemas are too
 complex to fit into the CRD, because they are highly nestable and self-referencing. We therefore use webhooks.)
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: admissionregistration.k8s.io/v1
 kind: ValidatingWebhookConfiguration
 metadata:
 name: membrane
 webhooks:
 - name: membrane.membrane-soa.org
 admissionReviewVersions: ["v1", "v1beta1"]
 failurePolicy: Fail
 rules:
 - operations: [ "*" ]
 apiGroups: [ "membrane-soa.org" ]
 apiVersions: [ "v1", "v1beta1" ]
 resources: [ "*" ]
 scope: "*"
 clientConfig:
 service:
 name: membrane-validator
 namespace: membrane-soa
 port: 444
 caBundle: LS0t...LQ0K        # base64 encoded, PEM-formatted CA certificate
 sideEffects: None
 ---
 apiVersion: v1
 kind: Namespace
 metadata:
 name: membrane-soa
 ---
 apiVersion: v1
 kind: Service
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 spec:
 ports:
 - port: 444
 ---
 apiVersion: v1
 kind: Endpoints
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 subsets:
 - addresses:
 - ip: 192.168.0.1   # Membrane's IP
 ports:
 - port: 444
 &lt;/code&gt;
 &lt;p&gt;
 Once this setup is complete, you can enable serviceProxies like this:
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: membrane-soa.org/v1beta1
 kind: serviceproxy
 metadata:
 name: demo
 namespace: membrane-soa
 spec:
 host: demo.predic8.de
 path:
 value: /some-path/
 interceptors:
 - response:
 interceptors:
 - groovy:
 src: |
 println "Hello!"
 target:
 host: thomas-bayer.com
 &lt;/code&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setProperty">
</xsd:element>
<xsd:element ref="javascript">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Javascript. The script can access and manipulate data from the request and response.
 Use this or the Groovy plugin to extend the functions of Membrane by scripting. See the samples in examples/javascript.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="paddingHeader">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="greaser">
</xsd:element>
<xsd:element ref="soapBody">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders a SOAP body for legacy intergration&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;response&gt; plugin you can limit their application to responses only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="throttle">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The throttle feature can slow down traffic to thwart denial of service attacks.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlContentFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
 using an XPath expression.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
 match a message at all. This can improve performance significantly, as a DOM tree does probably not have
 to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
 lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
 namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
 &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
 the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
 constructed.
 &lt;/p&gt;
 &lt;p&gt;
 If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
 XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
 modified reconstituted message.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="headerFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
 The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ntlm">
</xsd:element>
<xsd:element ref="login">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
              application.
              &lt;/p&gt;
              &lt;p&gt;
              Users firstly have to authenticate themselves against a directory server using a username and password.
              Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
              token verification, access to the web application is granted for the user's session. Single Sign On can
              easily be realized using a small source code extension or modification of a web application.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
              each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
              default implementations.)
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
              cell phone number, Single Sign On data, etc.).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
              session cookie).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
              attempts for a specified amount of time.
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
              secondary channel like text messaging).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;/ul&gt;
              &lt;p&gt;
              &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
              title="login interceptor workflow"/&gt;
              &lt;/p&gt;
              &lt;p&gt;
              (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
              possible.)
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
              valid, the workflow is as follows:
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
              &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
              &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
              used. Steps 5 and 6.)&lt;/li&gt;
              &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
              &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
              was directly requested). (Step 8.)&lt;/li&gt;
              &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="sampleSoapService">
</xsd:element>
<xsd:element ref="analyser">
</xsd:element>
<xsd:element ref="validator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlRewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="regExReplacer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="abort" type="com.predic8.membrane.core.config.spring.AbortParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Plugins are usually applied to requests and responses.
 In case of errors, the flow returns and &lt;i&gt;handleAbort()&lt;/i&gt; is called on plugins
 going back the chain.
 By nesting plugins into an &lt;abort&gt; you can limit their application to abort flows only.
 On plugins nested in &lt;abort&gt; handleResponse() is called not handleAbort() in order to
 allow normal processing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiKey">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Secures APIs by validating keys stored in either files or proxies.xml. Keys can be received from clients via HTTP headers or URL query parameters. Additional permission checks are possible through scope validation - scopes are loaded into an Exchange property and can be checked using the "hasScope()" SpEL function.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="oauth2authserver">
</xsd:element>
<xsd:element ref="adminConsole">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="urlNormalizer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Replaces "/./" in the request URI's path by "/".
              &lt;/p&gt;
              &lt;p&gt;
              Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
              links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
              root). The SOA model then combines "&lt;a href="http://foo/material/ArticleService?wsdl"&gt;http://foo/material/ArticleService?wsdl&lt;/a&gt;" and
              "./ArticleService?xsd=1" to "&lt;a href="http://foo/material/./ArticleService?xsd=1"&gt;http://foo/material/./ArticleService?xsd=1&lt;/a&gt;". This URI is sent to Membrane's
              new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
              not match.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ruleMatching">
</xsd:element>
<xsd:element ref="oauth2PermissionChecker">
</xsd:element>
<xsd:element ref="for">
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element name="target" type="com.predic8.membrane.core.config.spring.TargetParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The destination where the service proxy will send messages to. Use the target element, if you want
 to send the messages to a static target. If you want to use dynamic destinations have a look at the
 &lt;a href="https://membrane-soa.org/service-proxy-doc/configuration/reference/router.htm"&gt;content based router&lt;/a&gt;.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="name" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The name as shown in the Admin Console.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; By default, a name will be automatically generated from the target host, port, etc.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="blockRequest" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;legacy attribute&lt;/i&gt; for usage by Membrane Monitor&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="blockResponse" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;legacy attribute&lt;/i&gt; for usage by Membrane Monitor&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="port" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The port Membrane listens on for incoming connections.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 8080&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 80&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="ip" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If present, binds the port only on the specified IP. Useful for hosts with multiple IP addresses.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 127.0.0.1&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;not set&lt;/i&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="host" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;A space separated list of hostnames. If set, Membrane will only consider this rule, if the "Host"
 header of incoming HTTP requests matches one of the hostnames.
 &lt;/p&gt;
 &lt;p&gt;
 The asterisk '*' can be used for basic globbing (to match any number, including zero, characters).
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; predic8.de *.predic8.de&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;not set&lt;/i&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="wsdl" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The WSDL of the SOAP service.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; &lt;a href="http://predic8.de/my.wsdl"&gt;http://predic8.de/my.wsdl&lt;/a&gt; &lt;i&gt;or&lt;/i&gt; file:my.wsdl&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="portName" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="wsdlHttpClientConfig" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="serviceName" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.InMemorySessionManagerParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="inMemorySessionManager2">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="expiresAfterSeconds" type="spel_number" >
</xsd:attribute>
<xsd:attribute name="domain" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="httpOnly" type="spel_boolean" >
</xsd:attribute>
<xsd:attribute name="sameSite" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="issuer" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="ttlExpiryRefreshOnAccess" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; controls if the expiry refreshes to expiresAfterSeconds on access (true) or if it should not refresh (false)&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="secure" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; forces secure cookie attribute even when no ssl context is present (e.g. TLS termination in front of membrane)&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="sessionCookie" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; if true removes the expire part of a set cookie header and thus makes it a session cookie&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="if">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The "if" interceptor supports conditional execution of nested plugins.
 &lt;/p&gt;
 See:
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorSpELTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorGroovyTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorJsonpathTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorXPathTest&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element ref="httpClient">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
 Server using the HTTP protocol. Usually it will be globally used
 inside the transport. However, it is also possible to use it
 inside a proxy to give the proxy an individual configuration for
 its outgoing HTTP connection that is different from the global
 configuration in the transport.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtAuth">
</xsd:element>
<xsd:element ref="interceptor">
</xsd:element>
<xsd:element ref="tcp">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="tokenValidator">
</xsd:element>
<xsd:element ref="beautifier">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Beautifies request and response bodies. Supported are the Formats: JSON, XML&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="static">
</xsd:element>
<xsd:element ref="jsonProtection">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="http2xml">
</xsd:element>
<xsd:element name="echo" type="com.predic8.membrane.core.config.spring.EchoParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Returns the flow of plugins and copies the content of the
 request into a new response. The response has a status code of 200.
 Useful for testing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xml2Json">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If enabled converts body content from xml to json.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Can be used for both request and response. Xml file assumed to be in UTF-8. If input is invalid it returns
 empty json object.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="authHead2Body">
</xsd:element>
<xsd:element ref="webServer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
 "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
 &lt;/p&gt;
 &lt;p&gt;
 The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
 HTTP response with the contents of a file, or a "404 Not Found." error.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="internalRouting">
</xsd:element>
<xsd:element ref="exchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
              might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="dispatching">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
 element to the list of destinations of the exchange object. It
 must be placed into the transport to make Service Proxies Work
 properly. It has to be placed after the ruleMatching
 interceptor. The ruleMatching interceptor looks up a service
 proxy for an incoming request and places it into the exchange
 object. The dispatching interceptor needs the service proxy to
 get information about the target.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shadowing">
</xsd:element>
<xsd:element ref="openapiPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;openapiPublisher&lt;/i&gt; serves OpenAPI documents
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessControl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
              requested resource.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="acmeHttpChallenge">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See the documentation of the &lt;code&gt;&lt;acme /&gt;&lt;/code&gt; element for usage details.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="transform">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transform feature applies an XSLT transformation to the content in the body of a message. After the
              transformation the body content is replaced with the result of the transformation.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Rewrites or redirects the path of incoming requests based on a mapping.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rest2Soap">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xenAuthentication">
</xsd:element>
<xsd:element ref="graphQLProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Check GraphQL-over-HTTP requests, enforcing several limits and/or restrictions. This effectively helps to reduce
 the attack surface.
 &lt;p&gt;
 GraphQL Specification "October2021" is used. (But GraphQL only covers formulation of Documents/Queries.)
 &lt;/p&gt;
 &lt;p&gt;
 GraphQL-over-HTTP, which specifies how to submit GraphQL queries via HTTP, has not been released/finalized yet. We
 therefore use Version
 &lt;a href="https://github.com/graphql/graphql-over-http/blob/a1e6d8ca248c9a19eb59a2eedd988c204909ee3f/spec/GraphQLOverHTTP.md"&gt;a1e6d8ca&lt;/a&gt;.
 &lt;/p&gt;
 &lt;p&gt;
 Only GraphQL documents conforming to the 'ExecutableDocument' of the grammar are allowed: This includes the usual
 'query', 'mutation', 'subscription' and 'fragment's.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapOperationExtractor">
</xsd:element>
<xsd:element ref="balancer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="reverseProxying">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
 as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
 hostnames and ports used to access Membrane  vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clamav">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Delegates virus checks to an external Virus Scanner.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="destination">
</xsd:element>
<xsd:element ref="requireAuth">
</xsd:element>
<xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;request&gt; Element you can limit their application to requests only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="cache">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Don't use, this does NOT implement valid HTTP caching.
              &lt;/p&gt;
              &lt;p&gt;
                  We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                  the Docker Registry for offline use.
                  The cache does not revalidate any responses, so machines querying the cache for Debian
                  package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                  This is - simply put - the only use case, where using this class makes any sense.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsJDBC">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
 database (one row per exchange).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="index">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
              To use this feature just add a serviceProxy containing the index
              element. Of course you can protect the service proxy by using
              SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;wsdlPublisher&lt;/i&gt; serves WSDL files (and attached XML Schema Documents), if your
 backend service does not already do so.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="webServiceExplorer">
</xsd:element>
<xsd:element ref="logContext">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="APIsJSON">
</xsd:element>
<xsd:element ref="flowInitiator">
</xsd:element>
<xsd:element ref="counter">
</xsd:element>
<xsd:element ref="rateLimiter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;rateLimiter&lt;/i&gt; plugin limits the number of requests of a client in a period of time.
 As a default the client requests are grouped by client-Ip address and then counted. There are lots of
 possibilities to group the requests using the keyExpression. The requests can even be counted from different
 clients together.&lt;/p&gt;
 &lt;p&gt;When the gateway is located behind a loadbalancer then
 the client-Ip address is not the one from the client but the address from the balancer. To get the real Ip-address loadbalancers,
 &lt;i&gt;Web Application Firewalls&lt;/i&gt; and reverse proxies set the ip from the original client into the &lt;i&gt;X-Forwarded-For&lt;/i&gt; HTTP
 header field. The limiter plugin can take the Ip-address from the header.&lt;/p&gt;
 &lt;p&gt;
 The X-Forwarded-For header can only be trusted when a trustworthy reverse proxy or load balancer is between the client and server. The gateway not should be
 reachable directly. Only activate this feature when you know what you are doing.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="call">
</xsd:element>
<xsd:element ref="oauth2Resource2">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
 authorization server as response.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="if">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The "if" interceptor supports conditional execution of nested plugins.
 &lt;/p&gt;
 See:
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorSpELTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorGroovyTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorJsonpathTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorXPathTest&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="template">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders the body content of a message from a template. The template can
 produce plain text, Json or XML. Variables in the template are substituted with values from the body,
 header, query parameters, etc. If the extension of a referenced template file is &lt;i&gt;.xml&lt;/i&gt; it will use
 &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_xmltemplateengine"&gt;XMLTemplateEngine&lt;/a&gt;
 otherwise &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_streamingtemplateengine"&gt;StreamingTemplateEngine&lt;/a&gt;.
 Have a look at the samples in &lt;a href="https://github.com/membrane/service-proxy/tree/master/distribution/examples"&gt;examples/template&lt;/a&gt;.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="groovyTemplate">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Uses the groovy template markup engine to produce HTML-based responses.
 &lt;code&gt;
 &lt;groovyTemplate&gt;&lt;![CDATA[
   html {
     head {
       title('Resource')
     }
     body {
       p('Hello from Membrane!')
     }
   }
 ]]&gt;&lt;/groovyTemplate&gt;
 &lt;/code&gt;
 &lt;p&gt;
 The word "spring" refers to the Spring ApplicationContext.
 The word "exc" refers to the Membrane Exchange being handled.
 The word "flow" refers to the current Membrane Flow (=REQUEST).
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessLog">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes exchange metrics into a Log4j appender&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Defaults to Apache Common Log pattern&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="prometheus">
</xsd:element>
<xsd:element ref="wadlRewriter">
</xsd:element>
<xsd:element ref="openTelemetry">
</xsd:element>
<xsd:element ref="limit">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Note that due to the streaming nature of Membrane, a request header may already have been passed on to
              the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
              aborted and the connection to the backend is simply closed.
              &lt;/p&gt;
              &lt;p&gt;
              To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
              &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="basicAuthentication">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="json2Xml">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts body payload from JSON to XML. The JSON must be an object other JSON documents e.g. arrays are not supported.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Resulting XML will be in UTF-8 encoding.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shutdown">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Shutdown interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                  Adds the ability to shutdown main router thread via an HTTP request.
                  Don't forget to setup security for this interceptor.
              &lt;/p&gt;
              &lt;p&gt;
                  Has undefined behavior when Membrane is &lt;b&gt;not&lt;/b&gt; started from command line
                  (=via the RouterCLI class, which &lt;tt&gt;service-proxy.ps1&lt;/tt&gt;/&lt;tt&gt;service-proxy.sh&lt;/tt&gt;
                  do use).
              &lt;/p&gt;
              &lt;p&gt;
                  Only actually terminates the running JVM, when used in the first
                  &lt;tt&gt;&lt;router&gt;&lt;/tt&gt; bean (which implicitly stands for
                  &lt;tt&gt;&lt;router id="router"&gt;&lt;/tt&gt;) called "router".
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="userFeature">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapStackTraceFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
              advised to test its functionality in combination with your SOAP service provider before deploying it in
              production.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="formValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiDocs">
</xsd:element>
<xsd:element ref="choose">
</xsd:element>
<xsd:element ref="testService">
</xsd:element>
<xsd:element ref="soap2Rest">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clusterNotification">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane API Gateway distribution.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setHeader">
</xsd:element>
<xsd:element ref="groovy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Groovy script. The script can access and manipulate data from the request and response.
 Use this or the Javascript plugin to extend the functions of Membrane by scripting.
 See: example/groovy for working samples&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtSign">
</xsd:element>
<xsd:element ref="statisticsProvider">
</xsd:element>
<xsd:element ref="replace">
</xsd:element>
<xsd:element ref="methodOverride">
</xsd:element>
<xsd:element ref="stompClient">
</xsd:element>
<xsd:element ref="webSocket">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
 attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="log">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages. The messages will appear either on the console or in
 a log file depending on the log configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="return">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Terminates the exchange flow. The returned response is determined in the following order:
 &lt;p&gt;
 1. If there is already a response in the exchange, that response is returned
 2. If there is no response in the exchange, the body and contentType of the request is copied into a new response.
 &lt;/p&gt;
 &lt;p&gt;
 The options statusCode and contentType will overwrite the values from the messages.
 &lt;/p&gt;
 &lt;p&gt;
 This plugin is useful together with the template plugin. See examples/template.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsCSV">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
              file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="openapiValidator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Validator for OpenAPI documents&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accountRegistration">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="kubernetesValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Kubernetes Integration is still experimental.
 &lt;p&gt;
 To create the CustomResourceDefinitions, apply kubernetes-config.yaml from
 core/target/classes/com/predic8/membrane/core/config/kubernetes/ or a part (e.g. the 'serviceproxies' CRD) of the file.
 &lt;/p&gt;
 &lt;p&gt;
 Create a key and certificate for TLS for &lt;a href="https://membrane-validator.membrane-soa.svc:444/"&gt;https://membrane-validator.membrane-soa.svc:444/&lt;/a&gt; and setup Membrane to serve
 this address. The configuration shown below configures Membrane on a fixed IP address outside of the Kubernetes cluster,
 but this is no requirement.
 &lt;/p&gt;
 &lt;p&gt;
 Embed the following serviceProxy and adjust the 'resources' attribute to a comma-separated list of CRDs that you applied.
 Note that while the CRDs have plural names, here you need to use the corresponding singular. Configure the "ssl" section
 using your key and certificate.
 &lt;/p&gt;
 &lt;code&gt;
 &gt;serviceProxy port="444"&gt;
 &gt;ssl&gt;
 &gt;key&gt;
 &gt;private&gt;
 -----BEGIN RSA PRIVATE KEY-----
 ...
 -----END RSA PRIVATE KEY-----
 &gt;/private&gt;
 &gt;certificate&gt;
 -----BEGIN CERTIFICATE-----
 ...
 -----END CERTIFICATE-----
 &gt;/certificate&gt;
 &gt;/key&gt;
 &gt;/ssl&gt;
 &gt;kubernetesValidation resources="serviceproxy" /&gt;
 &gt;/serviceProxy&gt;
 &lt;/code&gt;
 &lt;p&gt;
 Now register a Webhook to validate the new CRDs. (A note to the experts: Membrane's validation schemas are too
 complex to fit into the CRD, because they are highly nestable and self-referencing. We therefore use webhooks.)
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: admissionregistration.k8s.io/v1
 kind: ValidatingWebhookConfiguration
 metadata:
 name: membrane
 webhooks:
 - name: membrane.membrane-soa.org
 admissionReviewVersions: ["v1", "v1beta1"]
 failurePolicy: Fail
 rules:
 - operations: [ "*" ]
 apiGroups: [ "membrane-soa.org" ]
 apiVersions: [ "v1", "v1beta1" ]
 resources: [ "*" ]
 scope: "*"
 clientConfig:
 service:
 name: membrane-validator
 namespace: membrane-soa
 port: 444
 caBundle: LS0t...LQ0K        # base64 encoded, PEM-formatted CA certificate
 sideEffects: None
 ---
 apiVersion: v1
 kind: Namespace
 metadata:
 name: membrane-soa
 ---
 apiVersion: v1
 kind: Service
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 spec:
 ports:
 - port: 444
 ---
 apiVersion: v1
 kind: Endpoints
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 subsets:
 - addresses:
 - ip: 192.168.0.1   # Membrane's IP
 ports:
 - port: 444
 &lt;/code&gt;
 &lt;p&gt;
 Once this setup is complete, you can enable serviceProxies like this:
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: membrane-soa.org/v1beta1
 kind: serviceproxy
 metadata:
 name: demo
 namespace: membrane-soa
 spec:
 host: demo.predic8.de
 path:
 value: /some-path/
 interceptors:
 - response:
 interceptors:
 - groovy:
 src: |
 println "Hello!"
 target:
 host: thomas-bayer.com
 &lt;/code&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setProperty">
</xsd:element>
<xsd:element ref="javascript">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Javascript. The script can access and manipulate data from the request and response.
 Use this or the Groovy plugin to extend the functions of Membrane by scripting. See the samples in examples/javascript.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="paddingHeader">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="greaser">
</xsd:element>
<xsd:element ref="soapBody">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders a SOAP body for legacy intergration&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;response&gt; plugin you can limit their application to responses only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="throttle">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The throttle feature can slow down traffic to thwart denial of service attacks.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlContentFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
 using an XPath expression.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
 match a message at all. This can improve performance significantly, as a DOM tree does probably not have
 to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
 lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
 namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
 &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
 the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
 constructed.
 &lt;/p&gt;
 &lt;p&gt;
 If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
 XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
 modified reconstituted message.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="headerFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
 The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ntlm">
</xsd:element>
<xsd:element ref="login">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
              application.
              &lt;/p&gt;
              &lt;p&gt;
              Users firstly have to authenticate themselves against a directory server using a username and password.
              Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
              token verification, access to the web application is granted for the user's session. Single Sign On can
              easily be realized using a small source code extension or modification of a web application.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
              each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
              default implementations.)
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
              cell phone number, Single Sign On data, etc.).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
              session cookie).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
              attempts for a specified amount of time.
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
              secondary channel like text messaging).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;/ul&gt;
              &lt;p&gt;
              &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
              title="login interceptor workflow"/&gt;
              &lt;/p&gt;
              &lt;p&gt;
              (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
              possible.)
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
              valid, the workflow is as follows:
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
              &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
              &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
              used. Steps 5 and 6.)&lt;/li&gt;
              &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
              &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
              was directly requested). (Step 8.)&lt;/li&gt;
              &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="sampleSoapService">
</xsd:element>
<xsd:element ref="analyser">
</xsd:element>
<xsd:element ref="validator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlRewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="regExReplacer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="abort" type="com.predic8.membrane.core.config.spring.AbortParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Plugins are usually applied to requests and responses.
 In case of errors, the flow returns and &lt;i&gt;handleAbort()&lt;/i&gt; is called on plugins
 going back the chain.
 By nesting plugins into an &lt;abort&gt; you can limit their application to abort flows only.
 On plugins nested in &lt;abort&gt; handleResponse() is called not handleAbort() in order to
 allow normal processing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiKey">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Secures APIs by validating keys stored in either files or proxies.xml. Keys can be received from clients via HTTP headers or URL query parameters. Additional permission checks are possible through scope validation - scopes are loaded into an Exchange property and can be checked using the "hasScope()" SpEL function.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="oauth2authserver">
</xsd:element>
<xsd:element ref="adminConsole">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="urlNormalizer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Replaces "/./" in the request URI's path by "/".
              &lt;/p&gt;
              &lt;p&gt;
              Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
              links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
              root). The SOA model then combines "&lt;a href="http://foo/material/ArticleService?wsdl"&gt;http://foo/material/ArticleService?wsdl&lt;/a&gt;" and
              "./ArticleService?xsd=1" to "&lt;a href="http://foo/material/./ArticleService?xsd=1"&gt;http://foo/material/./ArticleService?xsd=1&lt;/a&gt;". This URI is sent to Membrane's
              new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
              not match.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ruleMatching">
</xsd:element>
<xsd:element ref="oauth2PermissionChecker">
</xsd:element>
<xsd:element ref="for">
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="language" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the language of the 'test' condition&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; SpEL, groovy, jsonpath, xpath&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; groovy&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="test" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the condition to be tested&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; exc.request.header.userAgentSupportsSNI&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="byThreadStrategy">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="maxNumberOfThreadsPerEndpoint" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Maximum number of concurrently running requests per endpoint.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="retryTimeOnBusy" type="spel_number" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="template">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders the body content of a message from a template. The template can
 produce plain text, Json or XML. Variables in the template are substituted with values from the body,
 header, query parameters, etc. If the extension of a referenced template file is &lt;i&gt;.xml&lt;/i&gt; it will use
 &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_xmltemplateengine"&gt;XMLTemplateEngine&lt;/a&gt;
 otherwise &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_streamingtemplateengine"&gt;StreamingTemplateEngine&lt;/a&gt;.
 Have a look at the samples in &lt;a href="https://github.com/membrane/service-proxy/tree/master/distribution/examples"&gt;examples/template&lt;/a&gt;.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent mixed="true">
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/></xsd:sequence>
<xsd:attribute name="location" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="contentType" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="pretty" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="groovyTemplate">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Uses the groovy template markup engine to produce HTML-based responses.
 &lt;code&gt;
 &lt;groovyTemplate&gt;&lt;![CDATA[
   html {
     head {
       title('Resource')
     }
     body {
       p('Hello from Membrane!')
     }
   }
 ]]&gt;&lt;/groovyTemplate&gt;
 &lt;/code&gt;
 &lt;p&gt;
 The word "spring" refers to the Spring ApplicationContext.
 The word "exc" refers to the Membrane Exchange being handled.
 The word "flow" refers to the current Membrane Flow (=REQUEST).
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent mixed="true">
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/></xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="accessLog">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes exchange metrics into a Log4j appender&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Defaults to Apache Common Log pattern&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element name="additionalVariable" type="com.predic8.membrane.core.config.spring.AccessLogscopeParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="defaultValue" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; - Provide a default value if the exchange property could not be found, defaults to "-"&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="dateTimePattern" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; - Provide a datetime pattern, defaults to "dd/MM/yyyy:HH:mm:ss Z"&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="excludePayloadSize" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; - Reading the payload size would disable "Streaming", defaults to false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.FormValidationfieldParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="name" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Name of the form parameter.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; age&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="regex" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Java Regular expression&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; \d+&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="prometheus">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="buckets" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.SslProxygatekeeperParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element ref="httpClientConfig">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="url" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="wadlRewriter">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="protocol" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="host" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="port" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.BearerJwtTokenjwkParser">
<xsd:complexContent mixed="true">
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/></xsd:sequence>
<xsd:attribute name="location" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See &lt;a href="https://www.membrane-soa.org/service-proxy-doc/current/configuration/location.htm"&gt;here&lt;/a&gt; for a description of the format.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:complexType name="com.predic8.membrane.core.config.spring.MemoryStorageParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:complexType name="com.predic8.membrane.core.config.spring.CachingUserDataProviderParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="1">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;user data provider&lt;/i&gt; verifying a combination of a username with a password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element ref="staticUserDataProvider">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; listing all user data in-place in the config file.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              the &lt;i&gt;staticuserdataprovider&lt;/i&gt; can be used to statically list user data within the config file.
              &lt;/p&gt;
              &lt;p&gt;
              each user must have a unique &lt;i&gt;username&lt;/i&gt; attribute as well as a &lt;i&gt;password&lt;/i&gt; attribute.
              &lt;/p&gt;
              &lt;p&gt;
              arbitrary attributes can be set on a user element. other sub-components of the &lt;i&gt;login&lt;/i&gt; interceptor
              might use those: for example, the &lt;i&gt;telekomsmstokenprovider&lt;/i&gt; uses the &lt;i&gt;sms&lt;/i&gt; property as the
              user's cell phone number. for example, the &lt;i&gt;totptokenprovider&lt;/i&gt; uses the &lt;i&gt;secret&lt;/i&gt; property to
              initialize the token sequence.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jdbcUserDataProvider">
</xsd:element>
<xsd:element name="ldapUserDataProvider" type="com.predic8.membrane.core.config.spring.LdapUserDataProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; querying an LDAP server to authorize users and retrieve attributes.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The LDAP User Data Provider performs two jobs:
              &lt;ol&gt;
              &lt;li&gt;Authentication of a &lt;i&gt;username&lt;/i&gt; and &lt;i&gt;password&lt;/i&gt;.&lt;/li&gt;
              &lt;li&gt;Retrieval of user attributes.&lt;/li&gt;
              &lt;/ol&gt;
              &lt;/p&gt;
              &lt;p&gt;
              To achieve this, it first binds to &lt;i&gt;base&lt;/i&gt; on the LDAP server &lt;i&gt;url&lt;/i&gt;. If &lt;i&gt;binddn&lt;/i&gt; is not
              present, it binds to the LDAP server anonymously, elsewise &lt;i&gt;binddn&lt;/i&gt; and &lt;i&gt;bindpw&lt;/i&gt; are used for
              authentication.
              &lt;/p&gt;
              &lt;p&gt;
              Next, a search &lt;i&gt;searchPattern&lt;/i&gt; with scope &lt;i&gt;searchScope&lt;/i&gt; is executed where "&lt;tt&gt;%LOGIN%&lt;/tt&gt;"
              is replaced by the escaped version of the &lt;i&gt;username&lt;/i&gt;.
              &lt;/p&gt;
              &lt;p&gt;
              The search returning no node or more than one node is treated as failure.
              &lt;/p&gt;
              &lt;p&gt;
              If &lt;i&gt;passwordAttribute&lt;/i&gt; is set, and the node has an attribute with this name and this attribute's
              value starts with "&lt;tt&gt;{x-plain}&lt;/tt&gt;", the password is checked against the rest of the value for
              equality. If &lt;i&gt;passwordAttribute&lt;/i&gt; is not set, a second binding is attempted on the node using the
              &lt;i&gt;password&lt;/i&gt; the user provided.
              &lt;/p&gt;
              &lt;p&gt;
              The user attribute keys specified in the mapping are then renamed according to the mapping and used for
              further processing (see the other modules of the &lt;i&gt;login&lt;/i&gt; interceptor).
              &lt;/p&gt;
              &lt;p&gt;
              &lt;/p&gt;
              &lt;p&gt;
              For the initial binding, &lt;i&gt;connectTimeout&lt;/i&gt; can be used to specify a timeout in milliseconds. For the
              search, &lt;i&gt;timeout&lt;/i&gt; can be used.
              &lt;/p&gt;
              &lt;p&gt;
              If &lt;i&gt;readAttributesAsSelf&lt;/i&gt; is not set, the user attributes are collected from the search result. If
              it is set, an additional request is made after the second successful binding to retrieve the node's
              attributes.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="fileUserDataProvider">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; utilizing htpasswd formatted files.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              the &lt;i&gt;fileuserdataprovider&lt;/i&gt; can be used to source authentication data from htpasswd files.
              &lt;/p&gt;
              &lt;p&gt;
              The files can only utilize algorithm magic strings supported by &lt;i&gt;crypt(3)&lt;/i&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="cachingUserDataProvider" type="com.predic8.membrane.core.config.spring.CachingUserDataProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Caching User Data provider caches previous successful logins in order to make authentication faster&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="customStatementJdbcUserDataProvider">
</xsd:element>
<xsd:element name="unifyingUserDataProvider" type="com.predic8.membrane.core.config.spring.UnifyingUserDataProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;unifyingUserDataProvider&lt;/i&gt; can be used to merge two or more other &lt;i&gt;user data providers&lt;/i&gt;
              into one.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;unifyingUserDataProvider&lt;/i&gt; will forward a login attempt (username and password) to each inner
              user data provider in the order they are specified. After one of the inner user data providers returned
              a successful login (and returned the user's attributes), the procedure terminates. If no inner user data
              provider could verify the user, the login attempt fails.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="expiry" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Expire time for cache in milliseconds&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 600000&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="maxSize" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Max cache size&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 10000&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:complexType name="com.predic8.membrane.core.config.spring.RewriteParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="port" type="spel_number" >
</xsd:attribute>
<xsd:attribute name="protocol" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="host" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="basePath" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="openTelemetry">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element name="otlpExporter" type="com.predic8.membrane.core.config.spring.OtlpExporterParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="logBody" type="spel_boolean" >
</xsd:attribute>
<xsd:attribute name="sampleRate" type="xsd:double" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="httpSchemaResolver">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="limit">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Note that due to the streaming nature of Membrane, a request header may already have been passed on to
              the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
              aborted and the connection to the backend is simply closed.
              &lt;/p&gt;
              &lt;p&gt;
              To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
              &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="maxBodyLength" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The maximal length of a message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 10485760&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="basicAuthentication">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;user data provider&lt;/i&gt; verifying a combination of a username with a password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element ref="staticUserDataProvider">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; listing all user data in-place in the config file.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              the &lt;i&gt;staticuserdataprovider&lt;/i&gt; can be used to statically list user data within the config file.
              &lt;/p&gt;
              &lt;p&gt;
              each user must have a unique &lt;i&gt;username&lt;/i&gt; attribute as well as a &lt;i&gt;password&lt;/i&gt; attribute.
              &lt;/p&gt;
              &lt;p&gt;
              arbitrary attributes can be set on a user element. other sub-components of the &lt;i&gt;login&lt;/i&gt; interceptor
              might use those: for example, the &lt;i&gt;telekomsmstokenprovider&lt;/i&gt; uses the &lt;i&gt;sms&lt;/i&gt; property as the
              user's cell phone number. for example, the &lt;i&gt;totptokenprovider&lt;/i&gt; uses the &lt;i&gt;secret&lt;/i&gt; property to
              initialize the token sequence.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jdbcUserDataProvider">
</xsd:element>
<xsd:element name="ldapUserDataProvider" type="com.predic8.membrane.core.config.spring.LdapUserDataProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; querying an LDAP server to authorize users and retrieve attributes.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The LDAP User Data Provider performs two jobs:
              &lt;ol&gt;
              &lt;li&gt;Authentication of a &lt;i&gt;username&lt;/i&gt; and &lt;i&gt;password&lt;/i&gt;.&lt;/li&gt;
              &lt;li&gt;Retrieval of user attributes.&lt;/li&gt;
              &lt;/ol&gt;
              &lt;/p&gt;
              &lt;p&gt;
              To achieve this, it first binds to &lt;i&gt;base&lt;/i&gt; on the LDAP server &lt;i&gt;url&lt;/i&gt;. If &lt;i&gt;binddn&lt;/i&gt; is not
              present, it binds to the LDAP server anonymously, elsewise &lt;i&gt;binddn&lt;/i&gt; and &lt;i&gt;bindpw&lt;/i&gt; are used for
              authentication.
              &lt;/p&gt;
              &lt;p&gt;
              Next, a search &lt;i&gt;searchPattern&lt;/i&gt; with scope &lt;i&gt;searchScope&lt;/i&gt; is executed where "&lt;tt&gt;%LOGIN%&lt;/tt&gt;"
              is replaced by the escaped version of the &lt;i&gt;username&lt;/i&gt;.
              &lt;/p&gt;
              &lt;p&gt;
              The search returning no node or more than one node is treated as failure.
              &lt;/p&gt;
              &lt;p&gt;
              If &lt;i&gt;passwordAttribute&lt;/i&gt; is set, and the node has an attribute with this name and this attribute's
              value starts with "&lt;tt&gt;{x-plain}&lt;/tt&gt;", the password is checked against the rest of the value for
              equality. If &lt;i&gt;passwordAttribute&lt;/i&gt; is not set, a second binding is attempted on the node using the
              &lt;i&gt;password&lt;/i&gt; the user provided.
              &lt;/p&gt;
              &lt;p&gt;
              The user attribute keys specified in the mapping are then renamed according to the mapping and used for
              further processing (see the other modules of the &lt;i&gt;login&lt;/i&gt; interceptor).
              &lt;/p&gt;
              &lt;p&gt;
              &lt;/p&gt;
              &lt;p&gt;
              For the initial binding, &lt;i&gt;connectTimeout&lt;/i&gt; can be used to specify a timeout in milliseconds. For the
              search, &lt;i&gt;timeout&lt;/i&gt; can be used.
              &lt;/p&gt;
              &lt;p&gt;
              If &lt;i&gt;readAttributesAsSelf&lt;/i&gt; is not set, the user attributes are collected from the search result. If
              it is set, an additional request is made after the second successful binding to retrieve the node's
              attributes.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="fileUserDataProvider">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; utilizing htpasswd formatted files.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              the &lt;i&gt;fileuserdataprovider&lt;/i&gt; can be used to source authentication data from htpasswd files.
              &lt;/p&gt;
              &lt;p&gt;
              The files can only utilize algorithm magic strings supported by &lt;i&gt;crypt(3)&lt;/i&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="cachingUserDataProvider" type="com.predic8.membrane.core.config.spring.CachingUserDataProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Caching User Data provider caches previous successful logins in order to make authentication faster&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="customStatementJdbcUserDataProvider">
</xsd:element>
<xsd:element name="unifyingUserDataProvider" type="com.predic8.membrane.core.config.spring.UnifyingUserDataProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;unifyingUserDataProvider&lt;/i&gt; can be used to merge two or more other &lt;i&gt;user data providers&lt;/i&gt;
              into one.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;unifyingUserDataProvider&lt;/i&gt; will forward a login attempt (username and password) to each inner
              user data provider in the order they are specified. After one of the inner user data providers returned
              a successful login (and returned the user's attributes), the procedure terminates. If no inner user data
              provider could verify the user, the login attempt fails.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A list of username/password combinations to accept.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element name="user" type="com.predic8.membrane.core.config.spring.StaticUserDataProvideruserParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="json2Xml">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts body payload from JSON to XML. The JSON must be an object other JSON documents e.g. arrays are not supported.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Resulting XML will be in UTF-8 encoding.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="root" type="xsd:string" >
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="shutdown">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Shutdown interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                  Adds the ability to shutdown main router thread via an HTTP request.
                  Don't forget to setup security for this interceptor.
              &lt;/p&gt;
              &lt;p&gt;
                  Has undefined behavior when Membrane is &lt;b&gt;not&lt;/b&gt; started from command line
                  (=via the RouterCLI class, which &lt;tt&gt;service-proxy.ps1&lt;/tt&gt;/&lt;tt&gt;service-proxy.sh&lt;/tt&gt;
                  do use).
              &lt;/p&gt;
              &lt;p&gt;
                  Only actually terminates the running JVM, when used in the first
                  &lt;tt&gt;&lt;router&gt;&lt;/tt&gt; bean (which implicitly stands for
                  &lt;tt&gt;&lt;router id="router"&gt;&lt;/tt&gt;) called "router".
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.DatabaseApiKeyStoreParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element ref="keyTable">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element ref="scopeTable">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="datasource" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="userFeature">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="proxy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Clients can send HTTP requests to a proxy that forward the request to a Web server. It acts on behalf of the client.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Configures the usage of inbound SSL (HTTPS).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element ref="ssl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element ref="httpClient">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
 Server using the HTTP protocol. Usually it will be globally used
 inside the transport. However, it is also possible to use it
 inside a proxy to give the proxy an individual configuration for
 its outgoing HTTP connection that is different from the global
 configuration in the transport.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtAuth">
</xsd:element>
<xsd:element ref="interceptor">
</xsd:element>
<xsd:element ref="tcp">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="tokenValidator">
</xsd:element>
<xsd:element ref="beautifier">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Beautifies request and response bodies. Supported are the Formats: JSON, XML&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="static">
</xsd:element>
<xsd:element ref="jsonProtection">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="http2xml">
</xsd:element>
<xsd:element name="echo" type="com.predic8.membrane.core.config.spring.EchoParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Returns the flow of plugins and copies the content of the
 request into a new response. The response has a status code of 200.
 Useful for testing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xml2Json">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If enabled converts body content from xml to json.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Can be used for both request and response. Xml file assumed to be in UTF-8. If input is invalid it returns
 empty json object.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="authHead2Body">
</xsd:element>
<xsd:element ref="webServer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
 "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
 &lt;/p&gt;
 &lt;p&gt;
 The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
 HTTP response with the contents of a file, or a "404 Not Found." error.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="internalRouting">
</xsd:element>
<xsd:element ref="exchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
              might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="dispatching">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
 element to the list of destinations of the exchange object. It
 must be placed into the transport to make Service Proxies Work
 properly. It has to be placed after the ruleMatching
 interceptor. The ruleMatching interceptor looks up a service
 proxy for an incoming request and places it into the exchange
 object. The dispatching interceptor needs the service proxy to
 get information about the target.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shadowing">
</xsd:element>
<xsd:element ref="openapiPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;openapiPublisher&lt;/i&gt; serves OpenAPI documents
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessControl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
              requested resource.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="acmeHttpChallenge">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See the documentation of the &lt;code&gt;&lt;acme /&gt;&lt;/code&gt; element for usage details.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="transform">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transform feature applies an XSLT transformation to the content in the body of a message. After the
              transformation the body content is replaced with the result of the transformation.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Rewrites or redirects the path of incoming requests based on a mapping.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rest2Soap">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xenAuthentication">
</xsd:element>
<xsd:element ref="graphQLProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Check GraphQL-over-HTTP requests, enforcing several limits and/or restrictions. This effectively helps to reduce
 the attack surface.
 &lt;p&gt;
 GraphQL Specification "October2021" is used. (But GraphQL only covers formulation of Documents/Queries.)
 &lt;/p&gt;
 &lt;p&gt;
 GraphQL-over-HTTP, which specifies how to submit GraphQL queries via HTTP, has not been released/finalized yet. We
 therefore use Version
 &lt;a href="https://github.com/graphql/graphql-over-http/blob/a1e6d8ca248c9a19eb59a2eedd988c204909ee3f/spec/GraphQLOverHTTP.md"&gt;a1e6d8ca&lt;/a&gt;.
 &lt;/p&gt;
 &lt;p&gt;
 Only GraphQL documents conforming to the 'ExecutableDocument' of the grammar are allowed: This includes the usual
 'query', 'mutation', 'subscription' and 'fragment's.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapOperationExtractor">
</xsd:element>
<xsd:element ref="balancer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="reverseProxying">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
 as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
 hostnames and ports used to access Membrane  vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clamav">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Delegates virus checks to an external Virus Scanner.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="destination">
</xsd:element>
<xsd:element ref="requireAuth">
</xsd:element>
<xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;request&gt; Element you can limit their application to requests only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="cache">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Don't use, this does NOT implement valid HTTP caching.
              &lt;/p&gt;
              &lt;p&gt;
                  We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                  the Docker Registry for offline use.
                  The cache does not revalidate any responses, so machines querying the cache for Debian
                  package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                  This is - simply put - the only use case, where using this class makes any sense.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsJDBC">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
 database (one row per exchange).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="index">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
              To use this feature just add a serviceProxy containing the index
              element. Of course you can protect the service proxy by using
              SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;wsdlPublisher&lt;/i&gt; serves WSDL files (and attached XML Schema Documents), if your
 backend service does not already do so.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="webServiceExplorer">
</xsd:element>
<xsd:element ref="logContext">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="APIsJSON">
</xsd:element>
<xsd:element ref="flowInitiator">
</xsd:element>
<xsd:element ref="counter">
</xsd:element>
<xsd:element ref="rateLimiter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;rateLimiter&lt;/i&gt; plugin limits the number of requests of a client in a period of time.
 As a default the client requests are grouped by client-Ip address and then counted. There are lots of
 possibilities to group the requests using the keyExpression. The requests can even be counted from different
 clients together.&lt;/p&gt;
 &lt;p&gt;When the gateway is located behind a loadbalancer then
 the client-Ip address is not the one from the client but the address from the balancer. To get the real Ip-address loadbalancers,
 &lt;i&gt;Web Application Firewalls&lt;/i&gt; and reverse proxies set the ip from the original client into the &lt;i&gt;X-Forwarded-For&lt;/i&gt; HTTP
 header field. The limiter plugin can take the Ip-address from the header.&lt;/p&gt;
 &lt;p&gt;
 The X-Forwarded-For header can only be trusted when a trustworthy reverse proxy or load balancer is between the client and server. The gateway not should be
 reachable directly. Only activate this feature when you know what you are doing.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="call">
</xsd:element>
<xsd:element ref="oauth2Resource2">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
 authorization server as response.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="if">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The "if" interceptor supports conditional execution of nested plugins.
 &lt;/p&gt;
 See:
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorSpELTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorGroovyTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorJsonpathTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorXPathTest&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="template">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders the body content of a message from a template. The template can
 produce plain text, Json or XML. Variables in the template are substituted with values from the body,
 header, query parameters, etc. If the extension of a referenced template file is &lt;i&gt;.xml&lt;/i&gt; it will use
 &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_xmltemplateengine"&gt;XMLTemplateEngine&lt;/a&gt;
 otherwise &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_streamingtemplateengine"&gt;StreamingTemplateEngine&lt;/a&gt;.
 Have a look at the samples in &lt;a href="https://github.com/membrane/service-proxy/tree/master/distribution/examples"&gt;examples/template&lt;/a&gt;.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="groovyTemplate">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Uses the groovy template markup engine to produce HTML-based responses.
 &lt;code&gt;
 &lt;groovyTemplate&gt;&lt;![CDATA[
   html {
     head {
       title('Resource')
     }
     body {
       p('Hello from Membrane!')
     }
   }
 ]]&gt;&lt;/groovyTemplate&gt;
 &lt;/code&gt;
 &lt;p&gt;
 The word "spring" refers to the Spring ApplicationContext.
 The word "exc" refers to the Membrane Exchange being handled.
 The word "flow" refers to the current Membrane Flow (=REQUEST).
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessLog">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes exchange metrics into a Log4j appender&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Defaults to Apache Common Log pattern&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="prometheus">
</xsd:element>
<xsd:element ref="wadlRewriter">
</xsd:element>
<xsd:element ref="openTelemetry">
</xsd:element>
<xsd:element ref="limit">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Note that due to the streaming nature of Membrane, a request header may already have been passed on to
              the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
              aborted and the connection to the backend is simply closed.
              &lt;/p&gt;
              &lt;p&gt;
              To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
              &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="basicAuthentication">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="json2Xml">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts body payload from JSON to XML. The JSON must be an object other JSON documents e.g. arrays are not supported.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Resulting XML will be in UTF-8 encoding.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shutdown">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Shutdown interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                  Adds the ability to shutdown main router thread via an HTTP request.
                  Don't forget to setup security for this interceptor.
              &lt;/p&gt;
              &lt;p&gt;
                  Has undefined behavior when Membrane is &lt;b&gt;not&lt;/b&gt; started from command line
                  (=via the RouterCLI class, which &lt;tt&gt;service-proxy.ps1&lt;/tt&gt;/&lt;tt&gt;service-proxy.sh&lt;/tt&gt;
                  do use).
              &lt;/p&gt;
              &lt;p&gt;
                  Only actually terminates the running JVM, when used in the first
                  &lt;tt&gt;&lt;router&gt;&lt;/tt&gt; bean (which implicitly stands for
                  &lt;tt&gt;&lt;router id="router"&gt;&lt;/tt&gt;) called "router".
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="userFeature">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapStackTraceFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
              advised to test its functionality in combination with your SOAP service provider before deploying it in
              production.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="formValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiDocs">
</xsd:element>
<xsd:element ref="choose">
</xsd:element>
<xsd:element ref="testService">
</xsd:element>
<xsd:element ref="soap2Rest">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clusterNotification">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane API Gateway distribution.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setHeader">
</xsd:element>
<xsd:element ref="groovy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Groovy script. The script can access and manipulate data from the request and response.
 Use this or the Javascript plugin to extend the functions of Membrane by scripting.
 See: example/groovy for working samples&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtSign">
</xsd:element>
<xsd:element ref="statisticsProvider">
</xsd:element>
<xsd:element ref="replace">
</xsd:element>
<xsd:element ref="methodOverride">
</xsd:element>
<xsd:element ref="stompClient">
</xsd:element>
<xsd:element ref="webSocket">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
 attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="log">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages. The messages will appear either on the console or in
 a log file depending on the log configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="return">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Terminates the exchange flow. The returned response is determined in the following order:
 &lt;p&gt;
 1. If there is already a response in the exchange, that response is returned
 2. If there is no response in the exchange, the body and contentType of the request is copied into a new response.
 &lt;/p&gt;
 &lt;p&gt;
 The options statusCode and contentType will overwrite the values from the messages.
 &lt;/p&gt;
 &lt;p&gt;
 This plugin is useful together with the template plugin. See examples/template.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsCSV">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
              file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="openapiValidator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Validator for OpenAPI documents&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accountRegistration">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="kubernetesValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Kubernetes Integration is still experimental.
 &lt;p&gt;
 To create the CustomResourceDefinitions, apply kubernetes-config.yaml from
 core/target/classes/com/predic8/membrane/core/config/kubernetes/ or a part (e.g. the 'serviceproxies' CRD) of the file.
 &lt;/p&gt;
 &lt;p&gt;
 Create a key and certificate for TLS for &lt;a href="https://membrane-validator.membrane-soa.svc:444/"&gt;https://membrane-validator.membrane-soa.svc:444/&lt;/a&gt; and setup Membrane to serve
 this address. The configuration shown below configures Membrane on a fixed IP address outside of the Kubernetes cluster,
 but this is no requirement.
 &lt;/p&gt;
 &lt;p&gt;
 Embed the following serviceProxy and adjust the 'resources' attribute to a comma-separated list of CRDs that you applied.
 Note that while the CRDs have plural names, here you need to use the corresponding singular. Configure the "ssl" section
 using your key and certificate.
 &lt;/p&gt;
 &lt;code&gt;
 &gt;serviceProxy port="444"&gt;
 &gt;ssl&gt;
 &gt;key&gt;
 &gt;private&gt;
 -----BEGIN RSA PRIVATE KEY-----
 ...
 -----END RSA PRIVATE KEY-----
 &gt;/private&gt;
 &gt;certificate&gt;
 -----BEGIN CERTIFICATE-----
 ...
 -----END CERTIFICATE-----
 &gt;/certificate&gt;
 &gt;/key&gt;
 &gt;/ssl&gt;
 &gt;kubernetesValidation resources="serviceproxy" /&gt;
 &gt;/serviceProxy&gt;
 &lt;/code&gt;
 &lt;p&gt;
 Now register a Webhook to validate the new CRDs. (A note to the experts: Membrane's validation schemas are too
 complex to fit into the CRD, because they are highly nestable and self-referencing. We therefore use webhooks.)
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: admissionregistration.k8s.io/v1
 kind: ValidatingWebhookConfiguration
 metadata:
 name: membrane
 webhooks:
 - name: membrane.membrane-soa.org
 admissionReviewVersions: ["v1", "v1beta1"]
 failurePolicy: Fail
 rules:
 - operations: [ "*" ]
 apiGroups: [ "membrane-soa.org" ]
 apiVersions: [ "v1", "v1beta1" ]
 resources: [ "*" ]
 scope: "*"
 clientConfig:
 service:
 name: membrane-validator
 namespace: membrane-soa
 port: 444
 caBundle: LS0t...LQ0K        # base64 encoded, PEM-formatted CA certificate
 sideEffects: None
 ---
 apiVersion: v1
 kind: Namespace
 metadata:
 name: membrane-soa
 ---
 apiVersion: v1
 kind: Service
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 spec:
 ports:
 - port: 444
 ---
 apiVersion: v1
 kind: Endpoints
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 subsets:
 - addresses:
 - ip: 192.168.0.1   # Membrane's IP
 ports:
 - port: 444
 &lt;/code&gt;
 &lt;p&gt;
 Once this setup is complete, you can enable serviceProxies like this:
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: membrane-soa.org/v1beta1
 kind: serviceproxy
 metadata:
 name: demo
 namespace: membrane-soa
 spec:
 host: demo.predic8.de
 path:
 value: /some-path/
 interceptors:
 - response:
 interceptors:
 - groovy:
 src: |
 println "Hello!"
 target:
 host: thomas-bayer.com
 &lt;/code&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setProperty">
</xsd:element>
<xsd:element ref="javascript">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Javascript. The script can access and manipulate data from the request and response.
 Use this or the Groovy plugin to extend the functions of Membrane by scripting. See the samples in examples/javascript.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="paddingHeader">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="greaser">
</xsd:element>
<xsd:element ref="soapBody">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders a SOAP body for legacy intergration&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;response&gt; plugin you can limit their application to responses only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="throttle">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The throttle feature can slow down traffic to thwart denial of service attacks.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlContentFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
 using an XPath expression.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
 match a message at all. This can improve performance significantly, as a DOM tree does probably not have
 to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
 lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
 namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
 &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
 the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
 constructed.
 &lt;/p&gt;
 &lt;p&gt;
 If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
 XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
 modified reconstituted message.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="headerFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
 The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ntlm">
</xsd:element>
<xsd:element ref="login">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
              application.
              &lt;/p&gt;
              &lt;p&gt;
              Users firstly have to authenticate themselves against a directory server using a username and password.
              Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
              token verification, access to the web application is granted for the user's session. Single Sign On can
              easily be realized using a small source code extension or modification of a web application.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
              each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
              default implementations.)
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
              cell phone number, Single Sign On data, etc.).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
              session cookie).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
              attempts for a specified amount of time.
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
              secondary channel like text messaging).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;/ul&gt;
              &lt;p&gt;
              &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
              title="login interceptor workflow"/&gt;
              &lt;/p&gt;
              &lt;p&gt;
              (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
              possible.)
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
              valid, the workflow is as follows:
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
              &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
              &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
              used. Steps 5 and 6.)&lt;/li&gt;
              &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
              &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
              was directly requested). (Step 8.)&lt;/li&gt;
              &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="sampleSoapService">
</xsd:element>
<xsd:element ref="analyser">
</xsd:element>
<xsd:element ref="validator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlRewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="regExReplacer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="abort" type="com.predic8.membrane.core.config.spring.AbortParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Plugins are usually applied to requests and responses.
 In case of errors, the flow returns and &lt;i&gt;handleAbort()&lt;/i&gt; is called on plugins
 going back the chain.
 By nesting plugins into an &lt;abort&gt; you can limit their application to abort flows only.
 On plugins nested in &lt;abort&gt; handleResponse() is called not handleAbort() in order to
 allow normal processing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiKey">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Secures APIs by validating keys stored in either files or proxies.xml. Keys can be received from clients via HTTP headers or URL query parameters. Additional permission checks are possible through scope validation - scopes are loaded into an Exchange property and can be checked using the "hasScope()" SpEL function.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="oauth2authserver">
</xsd:element>
<xsd:element ref="adminConsole">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="urlNormalizer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Replaces "/./" in the request URI's path by "/".
              &lt;/p&gt;
              &lt;p&gt;
              Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
              links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
              root). The SOA model then combines "&lt;a href="http://foo/material/ArticleService?wsdl"&gt;http://foo/material/ArticleService?wsdl&lt;/a&gt;" and
              "./ArticleService?xsd=1" to "&lt;a href="http://foo/material/./ArticleService?xsd=1"&gt;http://foo/material/./ArticleService?xsd=1&lt;/a&gt;". This URI is sent to Membrane's
              new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
              not match.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ruleMatching">
</xsd:element>
<xsd:element ref="oauth2PermissionChecker">
</xsd:element>
<xsd:element ref="for">
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="name" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The name as shown in the Admin Console.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; By default, a name will be automatically generated from the target host, port, etc.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="blockRequest" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;legacy attribute&lt;/i&gt; for usage by Membrane Monitor&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="blockResponse" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;legacy attribute&lt;/i&gt; for usage by Membrane Monitor&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="port" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The port Membrane listens on for incoming connections.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 8080&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 80&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="ip" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If present, binds the port only on the specified IP. Useful for hosts with multiple IP addresses.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 127.0.0.1&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;not set&lt;/i&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="include">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Contains a Java regex for &lt;i&gt;including&lt;/i&gt; message headers.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent mixed="true">
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/></xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.NodeParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="host" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The node's host.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; server3&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="port" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The node's port.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 8080&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 80&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="keyGenerator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Experimental.
 &lt;p&gt;Allows to dynamically generate keys/certificates for arbitrary domain names on the fly, signed by a specified
 root CA key.&lt;/p&gt;
 &lt;p&gt;This is an alternative for {@link Key} and {@link KeyStore}.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element ref="key">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Experimental.
 &lt;p&gt;Allows to insert a PEM block containing the key (as well as one or more blocks for the
 certificate(s)) directly into the proxies.xml file.&lt;/p&gt;
 &lt;p&gt;This is an alternative for {@link KeyStore}.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="soapStackTraceFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
              advised to test its functionality in combination with your SOAP service provider before deploying it in
              production.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.CaseParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element ref="httpClient">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
 Server using the HTTP protocol. Usually it will be globally used
 inside the transport. However, it is also possible to use it
 inside a proxy to give the proxy an individual configuration for
 its outgoing HTTP connection that is different from the global
 configuration in the transport.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtAuth">
</xsd:element>
<xsd:element ref="interceptor">
</xsd:element>
<xsd:element ref="tcp">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="tokenValidator">
</xsd:element>
<xsd:element ref="beautifier">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Beautifies request and response bodies. Supported are the Formats: JSON, XML&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="static">
</xsd:element>
<xsd:element ref="jsonProtection">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="http2xml">
</xsd:element>
<xsd:element name="echo" type="com.predic8.membrane.core.config.spring.EchoParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Returns the flow of plugins and copies the content of the
 request into a new response. The response has a status code of 200.
 Useful for testing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xml2Json">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If enabled converts body content from xml to json.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Can be used for both request and response. Xml file assumed to be in UTF-8. If input is invalid it returns
 empty json object.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="authHead2Body">
</xsd:element>
<xsd:element ref="webServer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
 "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
 &lt;/p&gt;
 &lt;p&gt;
 The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
 HTTP response with the contents of a file, or a "404 Not Found." error.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="internalRouting">
</xsd:element>
<xsd:element ref="exchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
              might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="dispatching">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
 element to the list of destinations of the exchange object. It
 must be placed into the transport to make Service Proxies Work
 properly. It has to be placed after the ruleMatching
 interceptor. The ruleMatching interceptor looks up a service
 proxy for an incoming request and places it into the exchange
 object. The dispatching interceptor needs the service proxy to
 get information about the target.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shadowing">
</xsd:element>
<xsd:element ref="openapiPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;openapiPublisher&lt;/i&gt; serves OpenAPI documents
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessControl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
              requested resource.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="acmeHttpChallenge">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See the documentation of the &lt;code&gt;&lt;acme /&gt;&lt;/code&gt; element for usage details.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="transform">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transform feature applies an XSLT transformation to the content in the body of a message. After the
              transformation the body content is replaced with the result of the transformation.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Rewrites or redirects the path of incoming requests based on a mapping.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rest2Soap">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xenAuthentication">
</xsd:element>
<xsd:element ref="graphQLProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Check GraphQL-over-HTTP requests, enforcing several limits and/or restrictions. This effectively helps to reduce
 the attack surface.
 &lt;p&gt;
 GraphQL Specification "October2021" is used. (But GraphQL only covers formulation of Documents/Queries.)
 &lt;/p&gt;
 &lt;p&gt;
 GraphQL-over-HTTP, which specifies how to submit GraphQL queries via HTTP, has not been released/finalized yet. We
 therefore use Version
 &lt;a href="https://github.com/graphql/graphql-over-http/blob/a1e6d8ca248c9a19eb59a2eedd988c204909ee3f/spec/GraphQLOverHTTP.md"&gt;a1e6d8ca&lt;/a&gt;.
 &lt;/p&gt;
 &lt;p&gt;
 Only GraphQL documents conforming to the 'ExecutableDocument' of the grammar are allowed: This includes the usual
 'query', 'mutation', 'subscription' and 'fragment's.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapOperationExtractor">
</xsd:element>
<xsd:element ref="balancer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="reverseProxying">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
 as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
 hostnames and ports used to access Membrane  vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clamav">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Delegates virus checks to an external Virus Scanner.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="destination">
</xsd:element>
<xsd:element ref="requireAuth">
</xsd:element>
<xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;request&gt; Element you can limit their application to requests only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="cache">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Don't use, this does NOT implement valid HTTP caching.
              &lt;/p&gt;
              &lt;p&gt;
                  We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                  the Docker Registry for offline use.
                  The cache does not revalidate any responses, so machines querying the cache for Debian
                  package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                  This is - simply put - the only use case, where using this class makes any sense.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsJDBC">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
 database (one row per exchange).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="index">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
              To use this feature just add a serviceProxy containing the index
              element. Of course you can protect the service proxy by using
              SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;wsdlPublisher&lt;/i&gt; serves WSDL files (and attached XML Schema Documents), if your
 backend service does not already do so.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="webServiceExplorer">
</xsd:element>
<xsd:element ref="logContext">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="APIsJSON">
</xsd:element>
<xsd:element ref="flowInitiator">
</xsd:element>
<xsd:element ref="counter">
</xsd:element>
<xsd:element ref="rateLimiter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;rateLimiter&lt;/i&gt; plugin limits the number of requests of a client in a period of time.
 As a default the client requests are grouped by client-Ip address and then counted. There are lots of
 possibilities to group the requests using the keyExpression. The requests can even be counted from different
 clients together.&lt;/p&gt;
 &lt;p&gt;When the gateway is located behind a loadbalancer then
 the client-Ip address is not the one from the client but the address from the balancer. To get the real Ip-address loadbalancers,
 &lt;i&gt;Web Application Firewalls&lt;/i&gt; and reverse proxies set the ip from the original client into the &lt;i&gt;X-Forwarded-For&lt;/i&gt; HTTP
 header field. The limiter plugin can take the Ip-address from the header.&lt;/p&gt;
 &lt;p&gt;
 The X-Forwarded-For header can only be trusted when a trustworthy reverse proxy or load balancer is between the client and server. The gateway not should be
 reachable directly. Only activate this feature when you know what you are doing.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="call">
</xsd:element>
<xsd:element ref="oauth2Resource2">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
 authorization server as response.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="if">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The "if" interceptor supports conditional execution of nested plugins.
 &lt;/p&gt;
 See:
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorSpELTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorGroovyTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorJsonpathTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorXPathTest&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="template">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders the body content of a message from a template. The template can
 produce plain text, Json or XML. Variables in the template are substituted with values from the body,
 header, query parameters, etc. If the extension of a referenced template file is &lt;i&gt;.xml&lt;/i&gt; it will use
 &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_xmltemplateengine"&gt;XMLTemplateEngine&lt;/a&gt;
 otherwise &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_streamingtemplateengine"&gt;StreamingTemplateEngine&lt;/a&gt;.
 Have a look at the samples in &lt;a href="https://github.com/membrane/service-proxy/tree/master/distribution/examples"&gt;examples/template&lt;/a&gt;.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="groovyTemplate">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Uses the groovy template markup engine to produce HTML-based responses.
 &lt;code&gt;
 &lt;groovyTemplate&gt;&lt;![CDATA[
   html {
     head {
       title('Resource')
     }
     body {
       p('Hello from Membrane!')
     }
   }
 ]]&gt;&lt;/groovyTemplate&gt;
 &lt;/code&gt;
 &lt;p&gt;
 The word "spring" refers to the Spring ApplicationContext.
 The word "exc" refers to the Membrane Exchange being handled.
 The word "flow" refers to the current Membrane Flow (=REQUEST).
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessLog">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes exchange metrics into a Log4j appender&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Defaults to Apache Common Log pattern&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="prometheus">
</xsd:element>
<xsd:element ref="wadlRewriter">
</xsd:element>
<xsd:element ref="openTelemetry">
</xsd:element>
<xsd:element ref="limit">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Note that due to the streaming nature of Membrane, a request header may already have been passed on to
              the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
              aborted and the connection to the backend is simply closed.
              &lt;/p&gt;
              &lt;p&gt;
              To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
              &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="basicAuthentication">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="json2Xml">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts body payload from JSON to XML. The JSON must be an object other JSON documents e.g. arrays are not supported.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Resulting XML will be in UTF-8 encoding.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shutdown">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Shutdown interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                  Adds the ability to shutdown main router thread via an HTTP request.
                  Don't forget to setup security for this interceptor.
              &lt;/p&gt;
              &lt;p&gt;
                  Has undefined behavior when Membrane is &lt;b&gt;not&lt;/b&gt; started from command line
                  (=via the RouterCLI class, which &lt;tt&gt;service-proxy.ps1&lt;/tt&gt;/&lt;tt&gt;service-proxy.sh&lt;/tt&gt;
                  do use).
              &lt;/p&gt;
              &lt;p&gt;
                  Only actually terminates the running JVM, when used in the first
                  &lt;tt&gt;&lt;router&gt;&lt;/tt&gt; bean (which implicitly stands for
                  &lt;tt&gt;&lt;router id="router"&gt;&lt;/tt&gt;) called "router".
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="userFeature">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapStackTraceFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
              advised to test its functionality in combination with your SOAP service provider before deploying it in
              production.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="formValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiDocs">
</xsd:element>
<xsd:element ref="choose">
</xsd:element>
<xsd:element ref="testService">
</xsd:element>
<xsd:element ref="soap2Rest">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clusterNotification">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane API Gateway distribution.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setHeader">
</xsd:element>
<xsd:element ref="groovy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Groovy script. The script can access and manipulate data from the request and response.
 Use this or the Javascript plugin to extend the functions of Membrane by scripting.
 See: example/groovy for working samples&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtSign">
</xsd:element>
<xsd:element ref="statisticsProvider">
</xsd:element>
<xsd:element ref="replace">
</xsd:element>
<xsd:element ref="methodOverride">
</xsd:element>
<xsd:element ref="stompClient">
</xsd:element>
<xsd:element ref="webSocket">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
 attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="log">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages. The messages will appear either on the console or in
 a log file depending on the log configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="return">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Terminates the exchange flow. The returned response is determined in the following order:
 &lt;p&gt;
 1. If there is already a response in the exchange, that response is returned
 2. If there is no response in the exchange, the body and contentType of the request is copied into a new response.
 &lt;/p&gt;
 &lt;p&gt;
 The options statusCode and contentType will overwrite the values from the messages.
 &lt;/p&gt;
 &lt;p&gt;
 This plugin is useful together with the template plugin. See examples/template.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsCSV">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
              file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="openapiValidator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Validator for OpenAPI documents&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accountRegistration">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="kubernetesValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Kubernetes Integration is still experimental.
 &lt;p&gt;
 To create the CustomResourceDefinitions, apply kubernetes-config.yaml from
 core/target/classes/com/predic8/membrane/core/config/kubernetes/ or a part (e.g. the 'serviceproxies' CRD) of the file.
 &lt;/p&gt;
 &lt;p&gt;
 Create a key and certificate for TLS for &lt;a href="https://membrane-validator.membrane-soa.svc:444/"&gt;https://membrane-validator.membrane-soa.svc:444/&lt;/a&gt; and setup Membrane to serve
 this address. The configuration shown below configures Membrane on a fixed IP address outside of the Kubernetes cluster,
 but this is no requirement.
 &lt;/p&gt;
 &lt;p&gt;
 Embed the following serviceProxy and adjust the 'resources' attribute to a comma-separated list of CRDs that you applied.
 Note that while the CRDs have plural names, here you need to use the corresponding singular. Configure the "ssl" section
 using your key and certificate.
 &lt;/p&gt;
 &lt;code&gt;
 &gt;serviceProxy port="444"&gt;
 &gt;ssl&gt;
 &gt;key&gt;
 &gt;private&gt;
 -----BEGIN RSA PRIVATE KEY-----
 ...
 -----END RSA PRIVATE KEY-----
 &gt;/private&gt;
 &gt;certificate&gt;
 -----BEGIN CERTIFICATE-----
 ...
 -----END CERTIFICATE-----
 &gt;/certificate&gt;
 &gt;/key&gt;
 &gt;/ssl&gt;
 &gt;kubernetesValidation resources="serviceproxy" /&gt;
 &gt;/serviceProxy&gt;
 &lt;/code&gt;
 &lt;p&gt;
 Now register a Webhook to validate the new CRDs. (A note to the experts: Membrane's validation schemas are too
 complex to fit into the CRD, because they are highly nestable and self-referencing. We therefore use webhooks.)
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: admissionregistration.k8s.io/v1
 kind: ValidatingWebhookConfiguration
 metadata:
 name: membrane
 webhooks:
 - name: membrane.membrane-soa.org
 admissionReviewVersions: ["v1", "v1beta1"]
 failurePolicy: Fail
 rules:
 - operations: [ "*" ]
 apiGroups: [ "membrane-soa.org" ]
 apiVersions: [ "v1", "v1beta1" ]
 resources: [ "*" ]
 scope: "*"
 clientConfig:
 service:
 name: membrane-validator
 namespace: membrane-soa
 port: 444
 caBundle: LS0t...LQ0K        # base64 encoded, PEM-formatted CA certificate
 sideEffects: None
 ---
 apiVersion: v1
 kind: Namespace
 metadata:
 name: membrane-soa
 ---
 apiVersion: v1
 kind: Service
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 spec:
 ports:
 - port: 444
 ---
 apiVersion: v1
 kind: Endpoints
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 subsets:
 - addresses:
 - ip: 192.168.0.1   # Membrane's IP
 ports:
 - port: 444
 &lt;/code&gt;
 &lt;p&gt;
 Once this setup is complete, you can enable serviceProxies like this:
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: membrane-soa.org/v1beta1
 kind: serviceproxy
 metadata:
 name: demo
 namespace: membrane-soa
 spec:
 host: demo.predic8.de
 path:
 value: /some-path/
 interceptors:
 - response:
 interceptors:
 - groovy:
 src: |
 println "Hello!"
 target:
 host: thomas-bayer.com
 &lt;/code&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setProperty">
</xsd:element>
<xsd:element ref="javascript">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Javascript. The script can access and manipulate data from the request and response.
 Use this or the Groovy plugin to extend the functions of Membrane by scripting. See the samples in examples/javascript.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="paddingHeader">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="greaser">
</xsd:element>
<xsd:element ref="soapBody">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders a SOAP body for legacy intergration&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;response&gt; plugin you can limit their application to responses only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="throttle">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The throttle feature can slow down traffic to thwart denial of service attacks.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlContentFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
 using an XPath expression.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
 match a message at all. This can improve performance significantly, as a DOM tree does probably not have
 to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
 lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
 namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
 &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
 the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
 constructed.
 &lt;/p&gt;
 &lt;p&gt;
 If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
 XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
 modified reconstituted message.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="headerFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
 The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ntlm">
</xsd:element>
<xsd:element ref="login">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
              application.
              &lt;/p&gt;
              &lt;p&gt;
              Users firstly have to authenticate themselves against a directory server using a username and password.
              Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
              token verification, access to the web application is granted for the user's session. Single Sign On can
              easily be realized using a small source code extension or modification of a web application.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
              each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
              default implementations.)
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
              cell phone number, Single Sign On data, etc.).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
              session cookie).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
              attempts for a specified amount of time.
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
              secondary channel like text messaging).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;/ul&gt;
              &lt;p&gt;
              &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
              title="login interceptor workflow"/&gt;
              &lt;/p&gt;
              &lt;p&gt;
              (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
              possible.)
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
              valid, the workflow is as follows:
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
              &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
              &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
              used. Steps 5 and 6.)&lt;/li&gt;
              &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
              &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
              was directly requested). (Step 8.)&lt;/li&gt;
              &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="sampleSoapService">
</xsd:element>
<xsd:element ref="analyser">
</xsd:element>
<xsd:element ref="validator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlRewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="regExReplacer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="abort" type="com.predic8.membrane.core.config.spring.AbortParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Plugins are usually applied to requests and responses.
 In case of errors, the flow returns and &lt;i&gt;handleAbort()&lt;/i&gt; is called on plugins
 going back the chain.
 By nesting plugins into an &lt;abort&gt; you can limit their application to abort flows only.
 On plugins nested in &lt;abort&gt; handleResponse() is called not handleAbort() in order to
 allow normal processing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiKey">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Secures APIs by validating keys stored in either files or proxies.xml. Keys can be received from clients via HTTP headers or URL query parameters. Additional permission checks are possible through scope validation - scopes are loaded into an Exchange property and can be checked using the "hasScope()" SpEL function.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="oauth2authserver">
</xsd:element>
<xsd:element ref="adminConsole">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="urlNormalizer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Replaces "/./" in the request URI's path by "/".
              &lt;/p&gt;
              &lt;p&gt;
              Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
              links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
              root). The SOA model then combines "&lt;a href="http://foo/material/ArticleService?wsdl"&gt;http://foo/material/ArticleService?wsdl&lt;/a&gt;" and
              "./ArticleService?xsd=1" to "&lt;a href="http://foo/material/./ArticleService?xsd=1"&gt;http://foo/material/./ArticleService?xsd=1&lt;/a&gt;". This URI is sent to Membrane's
              new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
              not match.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ruleMatching">
</xsd:element>
<xsd:element ref="oauth2PermissionChecker">
</xsd:element>
<xsd:element ref="for">
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="language" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the language of the 'test' condition&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; SpEL, groovy, jsonpath, xpath&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; groovy&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="test" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the condition to be tested&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; exc.request.header.userAgentSupportsSNI&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="refresh">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element ref="bearerJwtToken">
</xsd:element>
<xsd:element ref="bearerToken">
</xsd:element>
</xsd:choice>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.KubernetesStorageParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="baseURL" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="namespace" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="masterLease" type="xsd:string" use="required">
</xsd:attribute>
<xsd:attribute name="accountSecret" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="prefix" type="xsd:string" >
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:complexType name="com.predic8.membrane.core.config.spring.EmailTokenProviderParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="simulate" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; don't actually send emails, if set to true&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="recipient" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the recipient email address (templated)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="body" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the email body (templated)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="sender" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the sender email address (templated)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="subject" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the email subject (templated)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="smtpHost" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; SMTP host&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="smtpUser" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; SMTP user to use for sender authentication&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; don't authenticate&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="smtpPort" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the SMTP port to use&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 25&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="smtpPassword" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the SMTP password to use for sender authentication&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="ssl" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; whether to use SMTP over SSL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="formValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="1" maxOccurs="unbounded">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Specifies the name of the parameter and the regex to match against.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element name="field" type="com.predic8.membrane.core.config.spring.FormValidationfieldParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="apiDocs">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="stompProxy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Proxies incoming STOMP CONNECT requests. Use a &lt;stompClient&gt; to forward these requests so some other machine.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Configures the usage of inbound SSL (HTTPS).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element ref="ssl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element ref="httpClient">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
 Server using the HTTP protocol. Usually it will be globally used
 inside the transport. However, it is also possible to use it
 inside a proxy to give the proxy an individual configuration for
 its outgoing HTTP connection that is different from the global
 configuration in the transport.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtAuth">
</xsd:element>
<xsd:element ref="interceptor">
</xsd:element>
<xsd:element ref="tcp">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="tokenValidator">
</xsd:element>
<xsd:element ref="beautifier">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Beautifies request and response bodies. Supported are the Formats: JSON, XML&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="static">
</xsd:element>
<xsd:element ref="jsonProtection">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="http2xml">
</xsd:element>
<xsd:element name="echo" type="com.predic8.membrane.core.config.spring.EchoParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Returns the flow of plugins and copies the content of the
 request into a new response. The response has a status code of 200.
 Useful for testing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xml2Json">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If enabled converts body content from xml to json.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Can be used for both request and response. Xml file assumed to be in UTF-8. If input is invalid it returns
 empty json object.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="authHead2Body">
</xsd:element>
<xsd:element ref="webServer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
 "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
 &lt;/p&gt;
 &lt;p&gt;
 The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
 HTTP response with the contents of a file, or a "404 Not Found." error.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="internalRouting">
</xsd:element>
<xsd:element ref="exchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
              might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="dispatching">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
 element to the list of destinations of the exchange object. It
 must be placed into the transport to make Service Proxies Work
 properly. It has to be placed after the ruleMatching
 interceptor. The ruleMatching interceptor looks up a service
 proxy for an incoming request and places it into the exchange
 object. The dispatching interceptor needs the service proxy to
 get information about the target.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shadowing">
</xsd:element>
<xsd:element ref="openapiPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;openapiPublisher&lt;/i&gt; serves OpenAPI documents
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessControl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
              requested resource.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="acmeHttpChallenge">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See the documentation of the &lt;code&gt;&lt;acme /&gt;&lt;/code&gt; element for usage details.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="transform">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transform feature applies an XSLT transformation to the content in the body of a message. After the
              transformation the body content is replaced with the result of the transformation.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Rewrites or redirects the path of incoming requests based on a mapping.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rest2Soap">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xenAuthentication">
</xsd:element>
<xsd:element ref="graphQLProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Check GraphQL-over-HTTP requests, enforcing several limits and/or restrictions. This effectively helps to reduce
 the attack surface.
 &lt;p&gt;
 GraphQL Specification "October2021" is used. (But GraphQL only covers formulation of Documents/Queries.)
 &lt;/p&gt;
 &lt;p&gt;
 GraphQL-over-HTTP, which specifies how to submit GraphQL queries via HTTP, has not been released/finalized yet. We
 therefore use Version
 &lt;a href="https://github.com/graphql/graphql-over-http/blob/a1e6d8ca248c9a19eb59a2eedd988c204909ee3f/spec/GraphQLOverHTTP.md"&gt;a1e6d8ca&lt;/a&gt;.
 &lt;/p&gt;
 &lt;p&gt;
 Only GraphQL documents conforming to the 'ExecutableDocument' of the grammar are allowed: This includes the usual
 'query', 'mutation', 'subscription' and 'fragment's.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapOperationExtractor">
</xsd:element>
<xsd:element ref="balancer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="reverseProxying">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
 as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
 hostnames and ports used to access Membrane  vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clamav">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Delegates virus checks to an external Virus Scanner.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="destination">
</xsd:element>
<xsd:element ref="requireAuth">
</xsd:element>
<xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;request&gt; Element you can limit their application to requests only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="cache">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Don't use, this does NOT implement valid HTTP caching.
              &lt;/p&gt;
              &lt;p&gt;
                  We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                  the Docker Registry for offline use.
                  The cache does not revalidate any responses, so machines querying the cache for Debian
                  package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                  This is - simply put - the only use case, where using this class makes any sense.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsJDBC">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
 database (one row per exchange).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="index">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
              To use this feature just add a serviceProxy containing the index
              element. Of course you can protect the service proxy by using
              SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;wsdlPublisher&lt;/i&gt; serves WSDL files (and attached XML Schema Documents), if your
 backend service does not already do so.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="webServiceExplorer">
</xsd:element>
<xsd:element ref="logContext">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="APIsJSON">
</xsd:element>
<xsd:element ref="flowInitiator">
</xsd:element>
<xsd:element ref="counter">
</xsd:element>
<xsd:element ref="rateLimiter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;rateLimiter&lt;/i&gt; plugin limits the number of requests of a client in a period of time.
 As a default the client requests are grouped by client-Ip address and then counted. There are lots of
 possibilities to group the requests using the keyExpression. The requests can even be counted from different
 clients together.&lt;/p&gt;
 &lt;p&gt;When the gateway is located behind a loadbalancer then
 the client-Ip address is not the one from the client but the address from the balancer. To get the real Ip-address loadbalancers,
 &lt;i&gt;Web Application Firewalls&lt;/i&gt; and reverse proxies set the ip from the original client into the &lt;i&gt;X-Forwarded-For&lt;/i&gt; HTTP
 header field. The limiter plugin can take the Ip-address from the header.&lt;/p&gt;
 &lt;p&gt;
 The X-Forwarded-For header can only be trusted when a trustworthy reverse proxy or load balancer is between the client and server. The gateway not should be
 reachable directly. Only activate this feature when you know what you are doing.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="call">
</xsd:element>
<xsd:element ref="oauth2Resource2">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
 authorization server as response.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="if">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The "if" interceptor supports conditional execution of nested plugins.
 &lt;/p&gt;
 See:
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorSpELTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorGroovyTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorJsonpathTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorXPathTest&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="template">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders the body content of a message from a template. The template can
 produce plain text, Json or XML. Variables in the template are substituted with values from the body,
 header, query parameters, etc. If the extension of a referenced template file is &lt;i&gt;.xml&lt;/i&gt; it will use
 &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_xmltemplateengine"&gt;XMLTemplateEngine&lt;/a&gt;
 otherwise &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_streamingtemplateengine"&gt;StreamingTemplateEngine&lt;/a&gt;.
 Have a look at the samples in &lt;a href="https://github.com/membrane/service-proxy/tree/master/distribution/examples"&gt;examples/template&lt;/a&gt;.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="groovyTemplate">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Uses the groovy template markup engine to produce HTML-based responses.
 &lt;code&gt;
 &lt;groovyTemplate&gt;&lt;![CDATA[
   html {
     head {
       title('Resource')
     }
     body {
       p('Hello from Membrane!')
     }
   }
 ]]&gt;&lt;/groovyTemplate&gt;
 &lt;/code&gt;
 &lt;p&gt;
 The word "spring" refers to the Spring ApplicationContext.
 The word "exc" refers to the Membrane Exchange being handled.
 The word "flow" refers to the current Membrane Flow (=REQUEST).
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessLog">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes exchange metrics into a Log4j appender&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Defaults to Apache Common Log pattern&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="prometheus">
</xsd:element>
<xsd:element ref="wadlRewriter">
</xsd:element>
<xsd:element ref="openTelemetry">
</xsd:element>
<xsd:element ref="limit">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Note that due to the streaming nature of Membrane, a request header may already have been passed on to
              the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
              aborted and the connection to the backend is simply closed.
              &lt;/p&gt;
              &lt;p&gt;
              To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
              &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="basicAuthentication">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="json2Xml">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts body payload from JSON to XML. The JSON must be an object other JSON documents e.g. arrays are not supported.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Resulting XML will be in UTF-8 encoding.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shutdown">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Shutdown interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                  Adds the ability to shutdown main router thread via an HTTP request.
                  Don't forget to setup security for this interceptor.
              &lt;/p&gt;
              &lt;p&gt;
                  Has undefined behavior when Membrane is &lt;b&gt;not&lt;/b&gt; started from command line
                  (=via the RouterCLI class, which &lt;tt&gt;service-proxy.ps1&lt;/tt&gt;/&lt;tt&gt;service-proxy.sh&lt;/tt&gt;
                  do use).
              &lt;/p&gt;
              &lt;p&gt;
                  Only actually terminates the running JVM, when used in the first
                  &lt;tt&gt;&lt;router&gt;&lt;/tt&gt; bean (which implicitly stands for
                  &lt;tt&gt;&lt;router id="router"&gt;&lt;/tt&gt;) called "router".
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="userFeature">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapStackTraceFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
              advised to test its functionality in combination with your SOAP service provider before deploying it in
              production.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="formValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiDocs">
</xsd:element>
<xsd:element ref="choose">
</xsd:element>
<xsd:element ref="testService">
</xsd:element>
<xsd:element ref="soap2Rest">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clusterNotification">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane API Gateway distribution.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setHeader">
</xsd:element>
<xsd:element ref="groovy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Groovy script. The script can access and manipulate data from the request and response.
 Use this or the Javascript plugin to extend the functions of Membrane by scripting.
 See: example/groovy for working samples&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtSign">
</xsd:element>
<xsd:element ref="statisticsProvider">
</xsd:element>
<xsd:element ref="replace">
</xsd:element>
<xsd:element ref="methodOverride">
</xsd:element>
<xsd:element ref="stompClient">
</xsd:element>
<xsd:element ref="webSocket">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
 attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="log">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages. The messages will appear either on the console or in
 a log file depending on the log configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="return">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Terminates the exchange flow. The returned response is determined in the following order:
 &lt;p&gt;
 1. If there is already a response in the exchange, that response is returned
 2. If there is no response in the exchange, the body and contentType of the request is copied into a new response.
 &lt;/p&gt;
 &lt;p&gt;
 The options statusCode and contentType will overwrite the values from the messages.
 &lt;/p&gt;
 &lt;p&gt;
 This plugin is useful together with the template plugin. See examples/template.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsCSV">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
              file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="openapiValidator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Validator for OpenAPI documents&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accountRegistration">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="kubernetesValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Kubernetes Integration is still experimental.
 &lt;p&gt;
 To create the CustomResourceDefinitions, apply kubernetes-config.yaml from
 core/target/classes/com/predic8/membrane/core/config/kubernetes/ or a part (e.g. the 'serviceproxies' CRD) of the file.
 &lt;/p&gt;
 &lt;p&gt;
 Create a key and certificate for TLS for &lt;a href="https://membrane-validator.membrane-soa.svc:444/"&gt;https://membrane-validator.membrane-soa.svc:444/&lt;/a&gt; and setup Membrane to serve
 this address. The configuration shown below configures Membrane on a fixed IP address outside of the Kubernetes cluster,
 but this is no requirement.
 &lt;/p&gt;
 &lt;p&gt;
 Embed the following serviceProxy and adjust the 'resources' attribute to a comma-separated list of CRDs that you applied.
 Note that while the CRDs have plural names, here you need to use the corresponding singular. Configure the "ssl" section
 using your key and certificate.
 &lt;/p&gt;
 &lt;code&gt;
 &gt;serviceProxy port="444"&gt;
 &gt;ssl&gt;
 &gt;key&gt;
 &gt;private&gt;
 -----BEGIN RSA PRIVATE KEY-----
 ...
 -----END RSA PRIVATE KEY-----
 &gt;/private&gt;
 &gt;certificate&gt;
 -----BEGIN CERTIFICATE-----
 ...
 -----END CERTIFICATE-----
 &gt;/certificate&gt;
 &gt;/key&gt;
 &gt;/ssl&gt;
 &gt;kubernetesValidation resources="serviceproxy" /&gt;
 &gt;/serviceProxy&gt;
 &lt;/code&gt;
 &lt;p&gt;
 Now register a Webhook to validate the new CRDs. (A note to the experts: Membrane's validation schemas are too
 complex to fit into the CRD, because they are highly nestable and self-referencing. We therefore use webhooks.)
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: admissionregistration.k8s.io/v1
 kind: ValidatingWebhookConfiguration
 metadata:
 name: membrane
 webhooks:
 - name: membrane.membrane-soa.org
 admissionReviewVersions: ["v1", "v1beta1"]
 failurePolicy: Fail
 rules:
 - operations: [ "*" ]
 apiGroups: [ "membrane-soa.org" ]
 apiVersions: [ "v1", "v1beta1" ]
 resources: [ "*" ]
 scope: "*"
 clientConfig:
 service:
 name: membrane-validator
 namespace: membrane-soa
 port: 444
 caBundle: LS0t...LQ0K        # base64 encoded, PEM-formatted CA certificate
 sideEffects: None
 ---
 apiVersion: v1
 kind: Namespace
 metadata:
 name: membrane-soa
 ---
 apiVersion: v1
 kind: Service
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 spec:
 ports:
 - port: 444
 ---
 apiVersion: v1
 kind: Endpoints
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 subsets:
 - addresses:
 - ip: 192.168.0.1   # Membrane's IP
 ports:
 - port: 444
 &lt;/code&gt;
 &lt;p&gt;
 Once this setup is complete, you can enable serviceProxies like this:
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: membrane-soa.org/v1beta1
 kind: serviceproxy
 metadata:
 name: demo
 namespace: membrane-soa
 spec:
 host: demo.predic8.de
 path:
 value: /some-path/
 interceptors:
 - response:
 interceptors:
 - groovy:
 src: |
 println "Hello!"
 target:
 host: thomas-bayer.com
 &lt;/code&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setProperty">
</xsd:element>
<xsd:element ref="javascript">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Javascript. The script can access and manipulate data from the request and response.
 Use this or the Groovy plugin to extend the functions of Membrane by scripting. See the samples in examples/javascript.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="paddingHeader">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="greaser">
</xsd:element>
<xsd:element ref="soapBody">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders a SOAP body for legacy intergration&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;response&gt; plugin you can limit their application to responses only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="throttle">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The throttle feature can slow down traffic to thwart denial of service attacks.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlContentFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
 using an XPath expression.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
 match a message at all. This can improve performance significantly, as a DOM tree does probably not have
 to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
 lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
 namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
 &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
 the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
 constructed.
 &lt;/p&gt;
 &lt;p&gt;
 If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
 XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
 modified reconstituted message.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="headerFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
 The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ntlm">
</xsd:element>
<xsd:element ref="login">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
              application.
              &lt;/p&gt;
              &lt;p&gt;
              Users firstly have to authenticate themselves against a directory server using a username and password.
              Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
              token verification, access to the web application is granted for the user's session. Single Sign On can
              easily be realized using a small source code extension or modification of a web application.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
              each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
              default implementations.)
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
              cell phone number, Single Sign On data, etc.).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
              session cookie).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
              attempts for a specified amount of time.
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
              secondary channel like text messaging).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;/ul&gt;
              &lt;p&gt;
              &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
              title="login interceptor workflow"/&gt;
              &lt;/p&gt;
              &lt;p&gt;
              (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
              possible.)
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
              valid, the workflow is as follows:
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
              &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
              &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
              used. Steps 5 and 6.)&lt;/li&gt;
              &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
              &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
              was directly requested). (Step 8.)&lt;/li&gt;
              &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="sampleSoapService">
</xsd:element>
<xsd:element ref="analyser">
</xsd:element>
<xsd:element ref="validator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlRewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="regExReplacer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="abort" type="com.predic8.membrane.core.config.spring.AbortParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Plugins are usually applied to requests and responses.
 In case of errors, the flow returns and &lt;i&gt;handleAbort()&lt;/i&gt; is called on plugins
 going back the chain.
 By nesting plugins into an &lt;abort&gt; you can limit their application to abort flows only.
 On plugins nested in &lt;abort&gt; handleResponse() is called not handleAbort() in order to
 allow normal processing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiKey">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Secures APIs by validating keys stored in either files or proxies.xml. Keys can be received from clients via HTTP headers or URL query parameters. Additional permission checks are possible through scope validation - scopes are loaded into an Exchange property and can be checked using the "hasScope()" SpEL function.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="oauth2authserver">
</xsd:element>
<xsd:element ref="adminConsole">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="urlNormalizer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Replaces "/./" in the request URI's path by "/".
              &lt;/p&gt;
              &lt;p&gt;
              Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
              links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
              root). The SOA model then combines "&lt;a href="http://foo/material/ArticleService?wsdl"&gt;http://foo/material/ArticleService?wsdl&lt;/a&gt;" and
              "./ArticleService?xsd=1" to "&lt;a href="http://foo/material/./ArticleService?xsd=1"&gt;http://foo/material/./ArticleService?xsd=1&lt;/a&gt;". This URI is sent to Membrane's
              new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
              not match.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ruleMatching">
</xsd:element>
<xsd:element ref="oauth2PermissionChecker">
</xsd:element>
<xsd:element ref="for">
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="name" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The name as shown in the Admin Console.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; By default, a name will be automatically generated from the target host, port, etc.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="blockRequest" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;legacy attribute&lt;/i&gt; for usage by Membrane Monitor&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="blockResponse" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;legacy attribute&lt;/i&gt; for usage by Membrane Monitor&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="port" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The port Membrane listens on for incoming connections.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 8080&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 80&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="ip" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If present, binds the port only on the specified IP. Useful for hosts with multiple IP addresses.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 127.0.0.1&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;not set&lt;/i&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="choose">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element ref="httpClient">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
 Server using the HTTP protocol. Usually it will be globally used
 inside the transport. However, it is also possible to use it
 inside a proxy to give the proxy an individual configuration for
 its outgoing HTTP connection that is different from the global
 configuration in the transport.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtAuth">
</xsd:element>
<xsd:element ref="interceptor">
</xsd:element>
<xsd:element ref="tcp">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="tokenValidator">
</xsd:element>
<xsd:element ref="beautifier">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Beautifies request and response bodies. Supported are the Formats: JSON, XML&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="static">
</xsd:element>
<xsd:element ref="jsonProtection">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="http2xml">
</xsd:element>
<xsd:element name="echo" type="com.predic8.membrane.core.config.spring.EchoParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Returns the flow of plugins and copies the content of the
 request into a new response. The response has a status code of 200.
 Useful for testing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xml2Json">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If enabled converts body content from xml to json.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Can be used for both request and response. Xml file assumed to be in UTF-8. If input is invalid it returns
 empty json object.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="authHead2Body">
</xsd:element>
<xsd:element ref="webServer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
 "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
 &lt;/p&gt;
 &lt;p&gt;
 The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
 HTTP response with the contents of a file, or a "404 Not Found." error.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="internalRouting">
</xsd:element>
<xsd:element ref="exchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
              might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="dispatching">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
 element to the list of destinations of the exchange object. It
 must be placed into the transport to make Service Proxies Work
 properly. It has to be placed after the ruleMatching
 interceptor. The ruleMatching interceptor looks up a service
 proxy for an incoming request and places it into the exchange
 object. The dispatching interceptor needs the service proxy to
 get information about the target.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shadowing">
</xsd:element>
<xsd:element ref="openapiPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;openapiPublisher&lt;/i&gt; serves OpenAPI documents
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessControl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
              requested resource.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="acmeHttpChallenge">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See the documentation of the &lt;code&gt;&lt;acme /&gt;&lt;/code&gt; element for usage details.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="transform">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transform feature applies an XSLT transformation to the content in the body of a message. After the
              transformation the body content is replaced with the result of the transformation.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Rewrites or redirects the path of incoming requests based on a mapping.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rest2Soap">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xenAuthentication">
</xsd:element>
<xsd:element ref="graphQLProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Check GraphQL-over-HTTP requests, enforcing several limits and/or restrictions. This effectively helps to reduce
 the attack surface.
 &lt;p&gt;
 GraphQL Specification "October2021" is used. (But GraphQL only covers formulation of Documents/Queries.)
 &lt;/p&gt;
 &lt;p&gt;
 GraphQL-over-HTTP, which specifies how to submit GraphQL queries via HTTP, has not been released/finalized yet. We
 therefore use Version
 &lt;a href="https://github.com/graphql/graphql-over-http/blob/a1e6d8ca248c9a19eb59a2eedd988c204909ee3f/spec/GraphQLOverHTTP.md"&gt;a1e6d8ca&lt;/a&gt;.
 &lt;/p&gt;
 &lt;p&gt;
 Only GraphQL documents conforming to the 'ExecutableDocument' of the grammar are allowed: This includes the usual
 'query', 'mutation', 'subscription' and 'fragment's.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapOperationExtractor">
</xsd:element>
<xsd:element ref="balancer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="reverseProxying">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
 as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
 hostnames and ports used to access Membrane  vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clamav">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Delegates virus checks to an external Virus Scanner.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="destination">
</xsd:element>
<xsd:element ref="requireAuth">
</xsd:element>
<xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;request&gt; Element you can limit their application to requests only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="cache">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Don't use, this does NOT implement valid HTTP caching.
              &lt;/p&gt;
              &lt;p&gt;
                  We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                  the Docker Registry for offline use.
                  The cache does not revalidate any responses, so machines querying the cache for Debian
                  package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                  This is - simply put - the only use case, where using this class makes any sense.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsJDBC">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
 database (one row per exchange).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="index">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
              To use this feature just add a serviceProxy containing the index
              element. Of course you can protect the service proxy by using
              SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;wsdlPublisher&lt;/i&gt; serves WSDL files (and attached XML Schema Documents), if your
 backend service does not already do so.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="webServiceExplorer">
</xsd:element>
<xsd:element ref="logContext">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="APIsJSON">
</xsd:element>
<xsd:element ref="flowInitiator">
</xsd:element>
<xsd:element ref="counter">
</xsd:element>
<xsd:element ref="rateLimiter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;rateLimiter&lt;/i&gt; plugin limits the number of requests of a client in a period of time.
 As a default the client requests are grouped by client-Ip address and then counted. There are lots of
 possibilities to group the requests using the keyExpression. The requests can even be counted from different
 clients together.&lt;/p&gt;
 &lt;p&gt;When the gateway is located behind a loadbalancer then
 the client-Ip address is not the one from the client but the address from the balancer. To get the real Ip-address loadbalancers,
 &lt;i&gt;Web Application Firewalls&lt;/i&gt; and reverse proxies set the ip from the original client into the &lt;i&gt;X-Forwarded-For&lt;/i&gt; HTTP
 header field. The limiter plugin can take the Ip-address from the header.&lt;/p&gt;
 &lt;p&gt;
 The X-Forwarded-For header can only be trusted when a trustworthy reverse proxy or load balancer is between the client and server. The gateway not should be
 reachable directly. Only activate this feature when you know what you are doing.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="call">
</xsd:element>
<xsd:element ref="oauth2Resource2">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
 authorization server as response.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="if">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The "if" interceptor supports conditional execution of nested plugins.
 &lt;/p&gt;
 See:
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorSpELTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorGroovyTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorJsonpathTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorXPathTest&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="template">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders the body content of a message from a template. The template can
 produce plain text, Json or XML. Variables in the template are substituted with values from the body,
 header, query parameters, etc. If the extension of a referenced template file is &lt;i&gt;.xml&lt;/i&gt; it will use
 &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_xmltemplateengine"&gt;XMLTemplateEngine&lt;/a&gt;
 otherwise &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_streamingtemplateengine"&gt;StreamingTemplateEngine&lt;/a&gt;.
 Have a look at the samples in &lt;a href="https://github.com/membrane/service-proxy/tree/master/distribution/examples"&gt;examples/template&lt;/a&gt;.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="groovyTemplate">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Uses the groovy template markup engine to produce HTML-based responses.
 &lt;code&gt;
 &lt;groovyTemplate&gt;&lt;![CDATA[
   html {
     head {
       title('Resource')
     }
     body {
       p('Hello from Membrane!')
     }
   }
 ]]&gt;&lt;/groovyTemplate&gt;
 &lt;/code&gt;
 &lt;p&gt;
 The word "spring" refers to the Spring ApplicationContext.
 The word "exc" refers to the Membrane Exchange being handled.
 The word "flow" refers to the current Membrane Flow (=REQUEST).
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessLog">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes exchange metrics into a Log4j appender&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Defaults to Apache Common Log pattern&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="prometheus">
</xsd:element>
<xsd:element ref="wadlRewriter">
</xsd:element>
<xsd:element ref="openTelemetry">
</xsd:element>
<xsd:element ref="limit">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Note that due to the streaming nature of Membrane, a request header may already have been passed on to
              the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
              aborted and the connection to the backend is simply closed.
              &lt;/p&gt;
              &lt;p&gt;
              To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
              &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="basicAuthentication">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="json2Xml">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts body payload from JSON to XML. The JSON must be an object other JSON documents e.g. arrays are not supported.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Resulting XML will be in UTF-8 encoding.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shutdown">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Shutdown interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                  Adds the ability to shutdown main router thread via an HTTP request.
                  Don't forget to setup security for this interceptor.
              &lt;/p&gt;
              &lt;p&gt;
                  Has undefined behavior when Membrane is &lt;b&gt;not&lt;/b&gt; started from command line
                  (=via the RouterCLI class, which &lt;tt&gt;service-proxy.ps1&lt;/tt&gt;/&lt;tt&gt;service-proxy.sh&lt;/tt&gt;
                  do use).
              &lt;/p&gt;
              &lt;p&gt;
                  Only actually terminates the running JVM, when used in the first
                  &lt;tt&gt;&lt;router&gt;&lt;/tt&gt; bean (which implicitly stands for
                  &lt;tt&gt;&lt;router id="router"&gt;&lt;/tt&gt;) called "router".
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="userFeature">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapStackTraceFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
              advised to test its functionality in combination with your SOAP service provider before deploying it in
              production.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="formValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiDocs">
</xsd:element>
<xsd:element ref="choose">
</xsd:element>
<xsd:element ref="testService">
</xsd:element>
<xsd:element ref="soap2Rest">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clusterNotification">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane API Gateway distribution.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setHeader">
</xsd:element>
<xsd:element ref="groovy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Groovy script. The script can access and manipulate data from the request and response.
 Use this or the Javascript plugin to extend the functions of Membrane by scripting.
 See: example/groovy for working samples&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtSign">
</xsd:element>
<xsd:element ref="statisticsProvider">
</xsd:element>
<xsd:element ref="replace">
</xsd:element>
<xsd:element ref="methodOverride">
</xsd:element>
<xsd:element ref="stompClient">
</xsd:element>
<xsd:element ref="webSocket">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
 attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="log">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages. The messages will appear either on the console or in
 a log file depending on the log configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="return">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Terminates the exchange flow. The returned response is determined in the following order:
 &lt;p&gt;
 1. If there is already a response in the exchange, that response is returned
 2. If there is no response in the exchange, the body and contentType of the request is copied into a new response.
 &lt;/p&gt;
 &lt;p&gt;
 The options statusCode and contentType will overwrite the values from the messages.
 &lt;/p&gt;
 &lt;p&gt;
 This plugin is useful together with the template plugin. See examples/template.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsCSV">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
              file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="openapiValidator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Validator for OpenAPI documents&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accountRegistration">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="kubernetesValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Kubernetes Integration is still experimental.
 &lt;p&gt;
 To create the CustomResourceDefinitions, apply kubernetes-config.yaml from
 core/target/classes/com/predic8/membrane/core/config/kubernetes/ or a part (e.g. the 'serviceproxies' CRD) of the file.
 &lt;/p&gt;
 &lt;p&gt;
 Create a key and certificate for TLS for &lt;a href="https://membrane-validator.membrane-soa.svc:444/"&gt;https://membrane-validator.membrane-soa.svc:444/&lt;/a&gt; and setup Membrane to serve
 this address. The configuration shown below configures Membrane on a fixed IP address outside of the Kubernetes cluster,
 but this is no requirement.
 &lt;/p&gt;
 &lt;p&gt;
 Embed the following serviceProxy and adjust the 'resources' attribute to a comma-separated list of CRDs that you applied.
 Note that while the CRDs have plural names, here you need to use the corresponding singular. Configure the "ssl" section
 using your key and certificate.
 &lt;/p&gt;
 &lt;code&gt;
 &gt;serviceProxy port="444"&gt;
 &gt;ssl&gt;
 &gt;key&gt;
 &gt;private&gt;
 -----BEGIN RSA PRIVATE KEY-----
 ...
 -----END RSA PRIVATE KEY-----
 &gt;/private&gt;
 &gt;certificate&gt;
 -----BEGIN CERTIFICATE-----
 ...
 -----END CERTIFICATE-----
 &gt;/certificate&gt;
 &gt;/key&gt;
 &gt;/ssl&gt;
 &gt;kubernetesValidation resources="serviceproxy" /&gt;
 &gt;/serviceProxy&gt;
 &lt;/code&gt;
 &lt;p&gt;
 Now register a Webhook to validate the new CRDs. (A note to the experts: Membrane's validation schemas are too
 complex to fit into the CRD, because they are highly nestable and self-referencing. We therefore use webhooks.)
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: admissionregistration.k8s.io/v1
 kind: ValidatingWebhookConfiguration
 metadata:
 name: membrane
 webhooks:
 - name: membrane.membrane-soa.org
 admissionReviewVersions: ["v1", "v1beta1"]
 failurePolicy: Fail
 rules:
 - operations: [ "*" ]
 apiGroups: [ "membrane-soa.org" ]
 apiVersions: [ "v1", "v1beta1" ]
 resources: [ "*" ]
 scope: "*"
 clientConfig:
 service:
 name: membrane-validator
 namespace: membrane-soa
 port: 444
 caBundle: LS0t...LQ0K        # base64 encoded, PEM-formatted CA certificate
 sideEffects: None
 ---
 apiVersion: v1
 kind: Namespace
 metadata:
 name: membrane-soa
 ---
 apiVersion: v1
 kind: Service
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 spec:
 ports:
 - port: 444
 ---
 apiVersion: v1
 kind: Endpoints
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 subsets:
 - addresses:
 - ip: 192.168.0.1   # Membrane's IP
 ports:
 - port: 444
 &lt;/code&gt;
 &lt;p&gt;
 Once this setup is complete, you can enable serviceProxies like this:
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: membrane-soa.org/v1beta1
 kind: serviceproxy
 metadata:
 name: demo
 namespace: membrane-soa
 spec:
 host: demo.predic8.de
 path:
 value: /some-path/
 interceptors:
 - response:
 interceptors:
 - groovy:
 src: |
 println "Hello!"
 target:
 host: thomas-bayer.com
 &lt;/code&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setProperty">
</xsd:element>
<xsd:element ref="javascript">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Javascript. The script can access and manipulate data from the request and response.
 Use this or the Groovy plugin to extend the functions of Membrane by scripting. See the samples in examples/javascript.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="paddingHeader">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="greaser">
</xsd:element>
<xsd:element ref="soapBody">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders a SOAP body for legacy intergration&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;response&gt; plugin you can limit their application to responses only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="throttle">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The throttle feature can slow down traffic to thwart denial of service attacks.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlContentFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
 using an XPath expression.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
 match a message at all. This can improve performance significantly, as a DOM tree does probably not have
 to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
 lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
 namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
 &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
 the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
 constructed.
 &lt;/p&gt;
 &lt;p&gt;
 If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
 XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
 modified reconstituted message.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="headerFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
 The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ntlm">
</xsd:element>
<xsd:element ref="login">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
              application.
              &lt;/p&gt;
              &lt;p&gt;
              Users firstly have to authenticate themselves against a directory server using a username and password.
              Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
              token verification, access to the web application is granted for the user's session. Single Sign On can
              easily be realized using a small source code extension or modification of a web application.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
              each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
              default implementations.)
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
              cell phone number, Single Sign On data, etc.).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
              session cookie).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
              attempts for a specified amount of time.
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
              secondary channel like text messaging).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;/ul&gt;
              &lt;p&gt;
              &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
              title="login interceptor workflow"/&gt;
              &lt;/p&gt;
              &lt;p&gt;
              (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
              possible.)
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
              valid, the workflow is as follows:
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
              &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
              &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
              used. Steps 5 and 6.)&lt;/li&gt;
              &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
              &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
              was directly requested). (Step 8.)&lt;/li&gt;
              &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="sampleSoapService">
</xsd:element>
<xsd:element ref="analyser">
</xsd:element>
<xsd:element ref="validator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlRewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="regExReplacer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="abort" type="com.predic8.membrane.core.config.spring.AbortParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Plugins are usually applied to requests and responses.
 In case of errors, the flow returns and &lt;i&gt;handleAbort()&lt;/i&gt; is called on plugins
 going back the chain.
 By nesting plugins into an &lt;abort&gt; you can limit their application to abort flows only.
 On plugins nested in &lt;abort&gt; handleResponse() is called not handleAbort() in order to
 allow normal processing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiKey">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Secures APIs by validating keys stored in either files or proxies.xml. Keys can be received from clients via HTTP headers or URL query parameters. Additional permission checks are possible through scope validation - scopes are loaded into an Exchange property and can be checked using the "hasScope()" SpEL function.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="oauth2authserver">
</xsd:element>
<xsd:element ref="adminConsole">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="urlNormalizer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Replaces "/./" in the request URI's path by "/".
              &lt;/p&gt;
              &lt;p&gt;
              Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
              links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
              root). The SOA model then combines "&lt;a href="http://foo/material/ArticleService?wsdl"&gt;http://foo/material/ArticleService?wsdl&lt;/a&gt;" and
              "./ArticleService?xsd=1" to "&lt;a href="http://foo/material/./ArticleService?xsd=1"&gt;http://foo/material/./ArticleService?xsd=1&lt;/a&gt;". This URI is sent to Membrane's
              new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
              not match.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ruleMatching">
</xsd:element>
<xsd:element ref="oauth2PermissionChecker">
</xsd:element>
<xsd:element ref="for">
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element name="Otherwise" type="com.predic8.membrane.core.config.spring.OtherwiseParser">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element ref="httpClient">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
 Server using the HTTP protocol. Usually it will be globally used
 inside the transport. However, it is also possible to use it
 inside a proxy to give the proxy an individual configuration for
 its outgoing HTTP connection that is different from the global
 configuration in the transport.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtAuth">
</xsd:element>
<xsd:element ref="interceptor">
</xsd:element>
<xsd:element ref="tcp">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="tokenValidator">
</xsd:element>
<xsd:element ref="beautifier">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Beautifies request and response bodies. Supported are the Formats: JSON, XML&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="static">
</xsd:element>
<xsd:element ref="jsonProtection">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="http2xml">
</xsd:element>
<xsd:element name="echo" type="com.predic8.membrane.core.config.spring.EchoParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Returns the flow of plugins and copies the content of the
 request into a new response. The response has a status code of 200.
 Useful for testing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xml2Json">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If enabled converts body content from xml to json.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Can be used for both request and response. Xml file assumed to be in UTF-8. If input is invalid it returns
 empty json object.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="authHead2Body">
</xsd:element>
<xsd:element ref="webServer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
 "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
 &lt;/p&gt;
 &lt;p&gt;
 The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
 HTTP response with the contents of a file, or a "404 Not Found." error.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="internalRouting">
</xsd:element>
<xsd:element ref="exchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
              might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="dispatching">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
 element to the list of destinations of the exchange object. It
 must be placed into the transport to make Service Proxies Work
 properly. It has to be placed after the ruleMatching
 interceptor. The ruleMatching interceptor looks up a service
 proxy for an incoming request and places it into the exchange
 object. The dispatching interceptor needs the service proxy to
 get information about the target.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shadowing">
</xsd:element>
<xsd:element ref="openapiPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;openapiPublisher&lt;/i&gt; serves OpenAPI documents
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessControl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
              requested resource.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="acmeHttpChallenge">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See the documentation of the &lt;code&gt;&lt;acme /&gt;&lt;/code&gt; element for usage details.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="transform">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transform feature applies an XSLT transformation to the content in the body of a message. After the
              transformation the body content is replaced with the result of the transformation.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Rewrites or redirects the path of incoming requests based on a mapping.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rest2Soap">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xenAuthentication">
</xsd:element>
<xsd:element ref="graphQLProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Check GraphQL-over-HTTP requests, enforcing several limits and/or restrictions. This effectively helps to reduce
 the attack surface.
 &lt;p&gt;
 GraphQL Specification "October2021" is used. (But GraphQL only covers formulation of Documents/Queries.)
 &lt;/p&gt;
 &lt;p&gt;
 GraphQL-over-HTTP, which specifies how to submit GraphQL queries via HTTP, has not been released/finalized yet. We
 therefore use Version
 &lt;a href="https://github.com/graphql/graphql-over-http/blob/a1e6d8ca248c9a19eb59a2eedd988c204909ee3f/spec/GraphQLOverHTTP.md"&gt;a1e6d8ca&lt;/a&gt;.
 &lt;/p&gt;
 &lt;p&gt;
 Only GraphQL documents conforming to the 'ExecutableDocument' of the grammar are allowed: This includes the usual
 'query', 'mutation', 'subscription' and 'fragment's.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapOperationExtractor">
</xsd:element>
<xsd:element ref="balancer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="reverseProxying">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
 as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
 hostnames and ports used to access Membrane  vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clamav">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Delegates virus checks to an external Virus Scanner.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="destination">
</xsd:element>
<xsd:element ref="requireAuth">
</xsd:element>
<xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;request&gt; Element you can limit their application to requests only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="cache">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Don't use, this does NOT implement valid HTTP caching.
              &lt;/p&gt;
              &lt;p&gt;
                  We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                  the Docker Registry for offline use.
                  The cache does not revalidate any responses, so machines querying the cache for Debian
                  package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                  This is - simply put - the only use case, where using this class makes any sense.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsJDBC">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
 database (one row per exchange).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="index">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
              To use this feature just add a serviceProxy containing the index
              element. Of course you can protect the service proxy by using
              SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;wsdlPublisher&lt;/i&gt; serves WSDL files (and attached XML Schema Documents), if your
 backend service does not already do so.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="webServiceExplorer">
</xsd:element>
<xsd:element ref="logContext">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="APIsJSON">
</xsd:element>
<xsd:element ref="flowInitiator">
</xsd:element>
<xsd:element ref="counter">
</xsd:element>
<xsd:element ref="rateLimiter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;rateLimiter&lt;/i&gt; plugin limits the number of requests of a client in a period of time.
 As a default the client requests are grouped by client-Ip address and then counted. There are lots of
 possibilities to group the requests using the keyExpression. The requests can even be counted from different
 clients together.&lt;/p&gt;
 &lt;p&gt;When the gateway is located behind a loadbalancer then
 the client-Ip address is not the one from the client but the address from the balancer. To get the real Ip-address loadbalancers,
 &lt;i&gt;Web Application Firewalls&lt;/i&gt; and reverse proxies set the ip from the original client into the &lt;i&gt;X-Forwarded-For&lt;/i&gt; HTTP
 header field. The limiter plugin can take the Ip-address from the header.&lt;/p&gt;
 &lt;p&gt;
 The X-Forwarded-For header can only be trusted when a trustworthy reverse proxy or load balancer is between the client and server. The gateway not should be
 reachable directly. Only activate this feature when you know what you are doing.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="call">
</xsd:element>
<xsd:element ref="oauth2Resource2">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
 authorization server as response.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="if">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The "if" interceptor supports conditional execution of nested plugins.
 &lt;/p&gt;
 See:
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorSpELTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorGroovyTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorJsonpathTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorXPathTest&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="template">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders the body content of a message from a template. The template can
 produce plain text, Json or XML. Variables in the template are substituted with values from the body,
 header, query parameters, etc. If the extension of a referenced template file is &lt;i&gt;.xml&lt;/i&gt; it will use
 &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_xmltemplateengine"&gt;XMLTemplateEngine&lt;/a&gt;
 otherwise &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_streamingtemplateengine"&gt;StreamingTemplateEngine&lt;/a&gt;.
 Have a look at the samples in &lt;a href="https://github.com/membrane/service-proxy/tree/master/distribution/examples"&gt;examples/template&lt;/a&gt;.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="groovyTemplate">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Uses the groovy template markup engine to produce HTML-based responses.
 &lt;code&gt;
 &lt;groovyTemplate&gt;&lt;![CDATA[
   html {
     head {
       title('Resource')
     }
     body {
       p('Hello from Membrane!')
     }
   }
 ]]&gt;&lt;/groovyTemplate&gt;
 &lt;/code&gt;
 &lt;p&gt;
 The word "spring" refers to the Spring ApplicationContext.
 The word "exc" refers to the Membrane Exchange being handled.
 The word "flow" refers to the current Membrane Flow (=REQUEST).
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessLog">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes exchange metrics into a Log4j appender&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Defaults to Apache Common Log pattern&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="prometheus">
</xsd:element>
<xsd:element ref="wadlRewriter">
</xsd:element>
<xsd:element ref="openTelemetry">
</xsd:element>
<xsd:element ref="limit">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Note that due to the streaming nature of Membrane, a request header may already have been passed on to
              the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
              aborted and the connection to the backend is simply closed.
              &lt;/p&gt;
              &lt;p&gt;
              To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
              &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="basicAuthentication">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="json2Xml">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts body payload from JSON to XML. The JSON must be an object other JSON documents e.g. arrays are not supported.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Resulting XML will be in UTF-8 encoding.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shutdown">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Shutdown interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                  Adds the ability to shutdown main router thread via an HTTP request.
                  Don't forget to setup security for this interceptor.
              &lt;/p&gt;
              &lt;p&gt;
                  Has undefined behavior when Membrane is &lt;b&gt;not&lt;/b&gt; started from command line
                  (=via the RouterCLI class, which &lt;tt&gt;service-proxy.ps1&lt;/tt&gt;/&lt;tt&gt;service-proxy.sh&lt;/tt&gt;
                  do use).
              &lt;/p&gt;
              &lt;p&gt;
                  Only actually terminates the running JVM, when used in the first
                  &lt;tt&gt;&lt;router&gt;&lt;/tt&gt; bean (which implicitly stands for
                  &lt;tt&gt;&lt;router id="router"&gt;&lt;/tt&gt;) called "router".
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="userFeature">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapStackTraceFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
              advised to test its functionality in combination with your SOAP service provider before deploying it in
              production.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="formValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiDocs">
</xsd:element>
<xsd:element ref="choose">
</xsd:element>
<xsd:element ref="testService">
</xsd:element>
<xsd:element ref="soap2Rest">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clusterNotification">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane API Gateway distribution.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setHeader">
</xsd:element>
<xsd:element ref="groovy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Groovy script. The script can access and manipulate data from the request and response.
 Use this or the Javascript plugin to extend the functions of Membrane by scripting.
 See: example/groovy for working samples&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtSign">
</xsd:element>
<xsd:element ref="statisticsProvider">
</xsd:element>
<xsd:element ref="replace">
</xsd:element>
<xsd:element ref="methodOverride">
</xsd:element>
<xsd:element ref="stompClient">
</xsd:element>
<xsd:element ref="webSocket">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
 attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="log">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages. The messages will appear either on the console or in
 a log file depending on the log configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="return">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Terminates the exchange flow. The returned response is determined in the following order:
 &lt;p&gt;
 1. If there is already a response in the exchange, that response is returned
 2. If there is no response in the exchange, the body and contentType of the request is copied into a new response.
 &lt;/p&gt;
 &lt;p&gt;
 The options statusCode and contentType will overwrite the values from the messages.
 &lt;/p&gt;
 &lt;p&gt;
 This plugin is useful together with the template plugin. See examples/template.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsCSV">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
              file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="openapiValidator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Validator for OpenAPI documents&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accountRegistration">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="kubernetesValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Kubernetes Integration is still experimental.
 &lt;p&gt;
 To create the CustomResourceDefinitions, apply kubernetes-config.yaml from
 core/target/classes/com/predic8/membrane/core/config/kubernetes/ or a part (e.g. the 'serviceproxies' CRD) of the file.
 &lt;/p&gt;
 &lt;p&gt;
 Create a key and certificate for TLS for &lt;a href="https://membrane-validator.membrane-soa.svc:444/"&gt;https://membrane-validator.membrane-soa.svc:444/&lt;/a&gt; and setup Membrane to serve
 this address. The configuration shown below configures Membrane on a fixed IP address outside of the Kubernetes cluster,
 but this is no requirement.
 &lt;/p&gt;
 &lt;p&gt;
 Embed the following serviceProxy and adjust the 'resources' attribute to a comma-separated list of CRDs that you applied.
 Note that while the CRDs have plural names, here you need to use the corresponding singular. Configure the "ssl" section
 using your key and certificate.
 &lt;/p&gt;
 &lt;code&gt;
 &gt;serviceProxy port="444"&gt;
 &gt;ssl&gt;
 &gt;key&gt;
 &gt;private&gt;
 -----BEGIN RSA PRIVATE KEY-----
 ...
 -----END RSA PRIVATE KEY-----
 &gt;/private&gt;
 &gt;certificate&gt;
 -----BEGIN CERTIFICATE-----
 ...
 -----END CERTIFICATE-----
 &gt;/certificate&gt;
 &gt;/key&gt;
 &gt;/ssl&gt;
 &gt;kubernetesValidation resources="serviceproxy" /&gt;
 &gt;/serviceProxy&gt;
 &lt;/code&gt;
 &lt;p&gt;
 Now register a Webhook to validate the new CRDs. (A note to the experts: Membrane's validation schemas are too
 complex to fit into the CRD, because they are highly nestable and self-referencing. We therefore use webhooks.)
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: admissionregistration.k8s.io/v1
 kind: ValidatingWebhookConfiguration
 metadata:
 name: membrane
 webhooks:
 - name: membrane.membrane-soa.org
 admissionReviewVersions: ["v1", "v1beta1"]
 failurePolicy: Fail
 rules:
 - operations: [ "*" ]
 apiGroups: [ "membrane-soa.org" ]
 apiVersions: [ "v1", "v1beta1" ]
 resources: [ "*" ]
 scope: "*"
 clientConfig:
 service:
 name: membrane-validator
 namespace: membrane-soa
 port: 444
 caBundle: LS0t...LQ0K        # base64 encoded, PEM-formatted CA certificate
 sideEffects: None
 ---
 apiVersion: v1
 kind: Namespace
 metadata:
 name: membrane-soa
 ---
 apiVersion: v1
 kind: Service
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 spec:
 ports:
 - port: 444
 ---
 apiVersion: v1
 kind: Endpoints
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 subsets:
 - addresses:
 - ip: 192.168.0.1   # Membrane's IP
 ports:
 - port: 444
 &lt;/code&gt;
 &lt;p&gt;
 Once this setup is complete, you can enable serviceProxies like this:
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: membrane-soa.org/v1beta1
 kind: serviceproxy
 metadata:
 name: demo
 namespace: membrane-soa
 spec:
 host: demo.predic8.de
 path:
 value: /some-path/
 interceptors:
 - response:
 interceptors:
 - groovy:
 src: |
 println "Hello!"
 target:
 host: thomas-bayer.com
 &lt;/code&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setProperty">
</xsd:element>
<xsd:element ref="javascript">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Javascript. The script can access and manipulate data from the request and response.
 Use this or the Groovy plugin to extend the functions of Membrane by scripting. See the samples in examples/javascript.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="paddingHeader">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="greaser">
</xsd:element>
<xsd:element ref="soapBody">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders a SOAP body for legacy intergration&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;response&gt; plugin you can limit their application to responses only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="throttle">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The throttle feature can slow down traffic to thwart denial of service attacks.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlContentFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
 using an XPath expression.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
 match a message at all. This can improve performance significantly, as a DOM tree does probably not have
 to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
 lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
 namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
 &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
 the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
 constructed.
 &lt;/p&gt;
 &lt;p&gt;
 If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
 XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
 modified reconstituted message.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="headerFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
 The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ntlm">
</xsd:element>
<xsd:element ref="login">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
              application.
              &lt;/p&gt;
              &lt;p&gt;
              Users firstly have to authenticate themselves against a directory server using a username and password.
              Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
              token verification, access to the web application is granted for the user's session. Single Sign On can
              easily be realized using a small source code extension or modification of a web application.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
              each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
              default implementations.)
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
              cell phone number, Single Sign On data, etc.).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
              session cookie).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
              attempts for a specified amount of time.
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
              secondary channel like text messaging).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;/ul&gt;
              &lt;p&gt;
              &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
              title="login interceptor workflow"/&gt;
              &lt;/p&gt;
              &lt;p&gt;
              (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
              possible.)
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
              valid, the workflow is as follows:
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
              &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
              &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
              used. Steps 5 and 6.)&lt;/li&gt;
              &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
              &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
              was directly requested). (Step 8.)&lt;/li&gt;
              &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="sampleSoapService">
</xsd:element>
<xsd:element ref="analyser">
</xsd:element>
<xsd:element ref="validator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlRewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="regExReplacer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="abort" type="com.predic8.membrane.core.config.spring.AbortParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Plugins are usually applied to requests and responses.
 In case of errors, the flow returns and &lt;i&gt;handleAbort()&lt;/i&gt; is called on plugins
 going back the chain.
 By nesting plugins into an &lt;abort&gt; you can limit their application to abort flows only.
 On plugins nested in &lt;abort&gt; handleResponse() is called not handleAbort() in order to
 allow normal processing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiKey">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Secures APIs by validating keys stored in either files or proxies.xml. Keys can be received from clients via HTTP headers or URL query parameters. Additional permission checks are possible through scope validation - scopes are loaded into an Exchange property and can be checked using the "hasScope()" SpEL function.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="oauth2authserver">
</xsd:element>
<xsd:element ref="adminConsole">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="urlNormalizer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Replaces "/./" in the request URI's path by "/".
              &lt;/p&gt;
              &lt;p&gt;
              Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
              links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
              root). The SOA model then combines "&lt;a href="http://foo/material/ArticleService?wsdl"&gt;http://foo/material/ArticleService?wsdl&lt;/a&gt;" and
              "./ArticleService?xsd=1" to "&lt;a href="http://foo/material/./ArticleService?xsd=1"&gt;http://foo/material/./ArticleService?xsd=1&lt;/a&gt;". This URI is sent to Membrane's
              new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
              not match.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ruleMatching">
</xsd:element>
<xsd:element ref="oauth2PermissionChecker">
</xsd:element>
<xsd:element ref="for">
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="redisSessionManager">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="expiresAfterSeconds" type="spel_number" >
</xsd:attribute>
<xsd:attribute name="domain" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="httpOnly" type="spel_boolean" >
</xsd:attribute>
<xsd:attribute name="sameSite" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="issuer" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="ttlExpiryRefreshOnAccess" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; controls if the expiry refreshes to expiresAfterSeconds on access (true) or if it should not refresh (false)&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="secure" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; forces secure cookie attribute even when no ssl context is present (e.g. TLS termination in front of membrane)&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="sessionCookie" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; if true removes the expire part of a set cookie header and thus makes it a session cookie&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="connector" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="cookiePrefix" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; randomly chosen 8-character long string.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="testService">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="soap2Rest">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="requestXSLT" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="responseXSLT" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="clusterNotification">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane API Gateway distribution.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="validateSignature" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Set Push Interface to encrypted mode.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="timeout" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Timestamp invalidation period. (0=unlimited)&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 5000&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="keyHex" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Key used by encryption as hex string&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 6f488a642b740fb70c5250987a284dc0&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.AccessLogscopeParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="expression" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The SPEL expression to access the property on an ExchangeEvaluationContext
 Using camelCased headers like camelHeader will resolve to camel-header if the camelHeader is not present.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="name" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The key which can be used to access this value in log4j2.xml like %X{key}&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="defaultValue" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The value if the exchange property is null. Defaults to "-"&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="setHeader">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="language" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the language of the 'test' condition&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; SpEL, groovy, jsonpath, xpath&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; groovy&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="ifAbsent" type="spel_boolean" >
</xsd:attribute>
<xsd:attribute name="name" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="value" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="failOnError" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.PathParser">
<xsd:complexContent mixed="true">
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/></xsd:sequence>
<xsd:attribute name="isRegExp" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If set to true the content will be evaluated as a &lt;a href="http://docs.oracle.com/javase/1.4.2/docs/api/java/util/regex/Pattern.html"&gt;Java Regular Expression&lt;/a&gt;.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="groovy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Groovy script. The script can access and manipulate data from the request and response.
 Use this or the Javascript plugin to extend the functions of Membrane by scripting.
 See: example/groovy for working samples&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent mixed="true">
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/></xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.ClaimsscopeParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="claims" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the properties seperated by spaces&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="httpClientConfig">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element name="connection" type="com.predic8.membrane.core.config.spring.ConnectionParser">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element name="proxy" type="com.predic8.membrane.core.config.spring.ProxyconfigurationParser">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element name="authentication" type="com.predic8.membrane.core.config.spring.AuthenticationParser">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element ref="ssl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="maxRetries" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Determines how often Membrane tries to send a message to a target before it gives up and returns an
              error message to the client.
              All tries to all servers count together. For example if you have 2 targets, and a RoundRobin
              strategy, then the number 5 means it tries, in this order: one, two, one, two, one.
              NOTE: the word "retries" is used incorrectly throughout this project. The current meaning is "tries".
              The first attempt, which is semantically not a "re"-try, counts as one already.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 5&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="useExperimentalHttp2" type="spel_boolean" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="jwtSign">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element name="jwk" type="com.predic8.membrane.core.config.spring.JwtSessionManagerjwkParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="expiryTime" type="spel_number" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="jwks">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element name="jwk" type="com.predic8.membrane.core.config.spring.JwksjwkParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="jwksUris" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="authorizationService" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="statisticsProvider">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="dataSourceBeanId" type="xsd:string" use="required">
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="replace">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="jsonPath" type="xsd:string" >
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="with" type="xsd:string" >
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="claims">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element name="scope" type="com.predic8.membrane.core.config.spring.ClaimsscopeParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="value" type="xsd:string" use="required">
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="methodOverride">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="memcached">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="host" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="port" type="spel_number" >
</xsd:attribute>
<xsd:attribute name="username" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="password" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="connectTimeout" type="spel_number" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="loginParameter">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="name" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="value" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="stompClient">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Parameters for outbound STOMP connections.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element name="connection" type="com.predic8.membrane.core.config.spring.ConnectionParser">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Configures outbound SSL (STOMP via SSL).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element ref="ssl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="port" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The port to connect to.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 61613&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="host" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The host (name or IP) to connect to.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="webSocket">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element ref="wsStompReassembler">
</xsd:element>
<xsd:element ref="wsInterceptor">
</xsd:element>
<xsd:element ref="wsLog">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="url" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The URL the WebSocket connection will be forwarded to. The (host,port) pair specifies the target server.
 The (path,query) part are sent to the target server on the initial request. (For example, ActiveMQ listens on port
 61614 and expects the incoming WebSocket connection to have a path '/' and empty query.)&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; &lt;a href="http://localhost:61614/"&gt;http://localhost:61614/&lt;/a&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="xmlProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
 attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="maxAttributeCount" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If an incoming request exceeds this limit, it will be discarded.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 1000&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="maxElementNameLength" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If an incoming request exceeds this limit, it will be discarded.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 1000&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="removeDTD" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Whether to remove the DTD from incoming requests.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="log">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages. The messages will appear either on the console or in
 a log file depending on the log configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="language" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the language of the 'test' condition&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; SpEL, groovy, jsonpath, xpath&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; groovy&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="body" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; To turn off logging of message bodies set this attribute to false&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="level" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Sets the log level.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; WARN&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; INFO&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="category" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Sets the category of the logged message.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; Membrane&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; com.predic8.membrane.core.interceptor.log.LogInterceptor&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="label" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Label to find the entry in the log&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; "After Transformation"&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; ""&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="message" type="xsd:string" >
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="bearerJwtToken">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element name="jwk" type="com.predic8.membrane.core.config.spring.JwtSessionManagerjwkParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="expiration" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Token expiration in seconds (or 0 to use no token expiration).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 0&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="faultMonitoringStrategy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Monitors the outcome of requests to each node to quickly disable/re-enable faulty ones.

 &lt;h2&gt;WHY THIS CLASS&lt;/h2&gt;
 &lt;p&gt;This is a drop-in replacement for the default {@link RoundRobinStrategy}. In fact, as long as all nodes
 respond correctly, it works the same. Things only start changing once nodes fail.
 Whereas the RoundRobin keeps dispatching to faulty nodes, causing delays for the service user, this
 strategy detects the issue and favours functional nodes.
 &lt;/p&gt;

 &lt;h2&gt;FORECAST PREDICTION USING "PERSISTENCE METHOD"&lt;/h2&gt;
 &lt;p&gt;Predicting tomorrow's weather by saying it will be equal to today's works well in many areas of the
 world. Similarly, predicting that another service request to a node will succeed after a success, or fail
 after a failure, is very likely.
 That's the main concept behind the logic and algorithm used within this class.
 &lt;/p&gt;

 &lt;h2&gt;HOW IT WORKS&lt;/h2&gt;
 &lt;p&gt;Once a node returns with a failure, a fault profile for that node is created. The node is instantly
 considered to be faulty. From then on, all status (success/failure) of that node is monitored.
 If enough successive calls are successful, the node is cleared from its bad reputation.
 If the node is not used anymore (either not requests at all, or none to that node because it's
 faulty and there are enough good nodes) then the node is cleared from its bad reputation after
 a configurable amount of time.
 When there are enough functional nodes (configurable ratio), only the functional ones are used
 with the simplistic round-robin strategy. If not, then all nodes are used, and the selection is a
 weighted chance operation by recent success rate.
 &lt;/p&gt;

 &lt;h2&gt;WHAT IS A FAULT&lt;/h2&gt;
 &lt;p&gt;A fault is when the destination replied with a valid 5xx HTTP status code, or when an exception
 (such as a ConnectException) was thrown. Everything else, including 4xx codes, is considered a success.&lt;/p&gt;

 &lt;h2&gt;PER NODE, NOT PER DESTINATION&lt;/h2&gt;
 &lt;p&gt;Success status could be monitored per node (host/port) or per destination (host/port/servicename).
 In practice, most failures affect all services. Rarely only one service on a node is faulty, but it's
 also very possible. This implementation currently monitors per node. This is for technical reasons,
 per destination is currently not possible with the information that is present. If it was available,
 I'm not sure which one is better to choose. Maybe configurable would be nice.
 If monitoring happens per destination, and one service is detected to be faulty, but in fact the
 whole node is down, this information will then not be freely available for the other destinations...
 they have to figure it out independently. Unless some more complicated functionality is built in.
 &lt;/p&gt;

 &lt;h2&gt;GOALS OF THIS CLASS&lt;/h2&gt;
 &lt;p&gt;Simple super-fast, super-low memory use. The goal is to provide a great service experience to the api
 user. Over-complicating things in here and introducing possible bugs or bottlenecks must be avoided.
 &lt;/p&gt;

 &lt;h2&gt;WHAT IT'S NOT&lt;/h2&gt;
 &lt;p&gt;It does not do response time monitoring to identify slow/laggy servers, or to favour faster ones.
 There can be different kinds of services on the same hosts, simple and complex expensive ones,
 and we don't have that kind of information here. Another similar DispatchingStrategy could do
 such logic.
 &lt;/p&gt;

 &lt;h2&gt;LIMITATIONS&lt;/h2&gt;
 &lt;p&gt;No background checking of faulty nodes.
 For certain kinds of failures, including ConnectException and UnknownHostException, a background service
 could keep checking a faulty node, and only re-enable it once that works again.
 For other cases, there could be a pluggable BackgroundUptimeCheck interface. This would allow a
 service implementor to write his own check that fits his needs. For example by sending a real
 service request that does not harm.
 Automatic background retry of previous failed requests to see if the service is back online is a bad
 idea... think payment service.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="minFlawlessServerRatioForRoundRobin" type="xsd:double" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If at least this many servers in relation to the total number of servers are "flawless", then only the
 flawless servers are used with a round-robin strategy. The faulty ones are ignored.
 If too many servers had some issues, then it goes back to using all servers (faulty and flawless)
 using the weighted-chance strategy.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 0.5&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="clearFaultyProfilesByTimerAfterLastFailureSeconds" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; When this much time [milliseconds] has passed, and there was no more fault, then the node is cleared from the bad history.
 It is possible that the node served requests successfully since then, or that it was not called at all.
 If it was not called, it's very possible that the node is still faulty. But we don't know.
 What happens is that the node is used again, but if it fails it will instantly have a fault profile.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 300000&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="clearFaultyTimerIntervalSeconds" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Every this much time [milliseconds] a TimerTask runs to see if there are any fault profiles to clear.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 30000&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="trust">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Allows to insert one or more PEM blocks containing the certificates to be trusted directly into the proxies.xml
 file.&lt;/p&gt;
 &lt;p&gt;This is an alternative for {@link TrustStore}.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; List of certificates&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element ref="certificate">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="algorithm" type="xsd:string" >
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="checkRevocation" type="xsd:string" >
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="return">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Terminates the exchange flow. The returned response is determined in the following order:
 &lt;p&gt;
 1. If there is already a response in the exchange, that response is returned
 2. If there is no response in the exchange, the body and contentType of the request is copied into a new response.
 &lt;/p&gt;
 &lt;p&gt;
 The options statusCode and contentType will overwrite the values from the messages.
 &lt;/p&gt;
 &lt;p&gt;
 This plugin is useful together with the template plugin. See examples/template.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="statusCode" type="spel_number" >
</xsd:attribute>
<xsd:attribute name="contentType" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="memcachedOriginalExchangeStore">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="maxBodySize" type="spel_number" >
</xsd:attribute>
<xsd:attribute name="connector" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="statisticsCSV">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
              file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="file" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Locations of csv file to write out logs.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; stat.csv&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="transport">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transport receives messages from clients and invokes interceptors in the request and response flow.
              The interceptors that are engaged with the transport are global and are invoked for each message flowing
              through the router.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element ref="httpClient">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
 Server using the HTTP protocol. Usually it will be globally used
 inside the transport. However, it is also possible to use it
 inside a proxy to give the proxy an individual configuration for
 its outgoing HTTP connection that is different from the global
 configuration in the transport.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtAuth">
</xsd:element>
<xsd:element ref="interceptor">
</xsd:element>
<xsd:element ref="tcp">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="tokenValidator">
</xsd:element>
<xsd:element ref="beautifier">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Beautifies request and response bodies. Supported are the Formats: JSON, XML&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="static">
</xsd:element>
<xsd:element ref="jsonProtection">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="http2xml">
</xsd:element>
<xsd:element name="echo" type="com.predic8.membrane.core.config.spring.EchoParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Returns the flow of plugins and copies the content of the
 request into a new response. The response has a status code of 200.
 Useful for testing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xml2Json">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If enabled converts body content from xml to json.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Can be used for both request and response. Xml file assumed to be in UTF-8. If input is invalid it returns
 empty json object.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="authHead2Body">
</xsd:element>
<xsd:element ref="webServer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
 "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
 &lt;/p&gt;
 &lt;p&gt;
 The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
 HTTP response with the contents of a file, or a "404 Not Found." error.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="internalRouting">
</xsd:element>
<xsd:element ref="exchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
              might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="dispatching">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
 element to the list of destinations of the exchange object. It
 must be placed into the transport to make Service Proxies Work
 properly. It has to be placed after the ruleMatching
 interceptor. The ruleMatching interceptor looks up a service
 proxy for an incoming request and places it into the exchange
 object. The dispatching interceptor needs the service proxy to
 get information about the target.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shadowing">
</xsd:element>
<xsd:element ref="openapiPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;openapiPublisher&lt;/i&gt; serves OpenAPI documents
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessControl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
              requested resource.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="acmeHttpChallenge">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See the documentation of the &lt;code&gt;&lt;acme /&gt;&lt;/code&gt; element for usage details.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="transform">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transform feature applies an XSLT transformation to the content in the body of a message. After the
              transformation the body content is replaced with the result of the transformation.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Rewrites or redirects the path of incoming requests based on a mapping.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rest2Soap">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xenAuthentication">
</xsd:element>
<xsd:element ref="graphQLProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Check GraphQL-over-HTTP requests, enforcing several limits and/or restrictions. This effectively helps to reduce
 the attack surface.
 &lt;p&gt;
 GraphQL Specification "October2021" is used. (But GraphQL only covers formulation of Documents/Queries.)
 &lt;/p&gt;
 &lt;p&gt;
 GraphQL-over-HTTP, which specifies how to submit GraphQL queries via HTTP, has not been released/finalized yet. We
 therefore use Version
 &lt;a href="https://github.com/graphql/graphql-over-http/blob/a1e6d8ca248c9a19eb59a2eedd988c204909ee3f/spec/GraphQLOverHTTP.md"&gt;a1e6d8ca&lt;/a&gt;.
 &lt;/p&gt;
 &lt;p&gt;
 Only GraphQL documents conforming to the 'ExecutableDocument' of the grammar are allowed: This includes the usual
 'query', 'mutation', 'subscription' and 'fragment's.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapOperationExtractor">
</xsd:element>
<xsd:element ref="balancer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="reverseProxying">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
 as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
 hostnames and ports used to access Membrane  vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clamav">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Delegates virus checks to an external Virus Scanner.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="destination">
</xsd:element>
<xsd:element ref="requireAuth">
</xsd:element>
<xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;request&gt; Element you can limit their application to requests only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="cache">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Don't use, this does NOT implement valid HTTP caching.
              &lt;/p&gt;
              &lt;p&gt;
                  We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                  the Docker Registry for offline use.
                  The cache does not revalidate any responses, so machines querying the cache for Debian
                  package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                  This is - simply put - the only use case, where using this class makes any sense.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsJDBC">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
 database (one row per exchange).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="index">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
              To use this feature just add a serviceProxy containing the index
              element. Of course you can protect the service proxy by using
              SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;wsdlPublisher&lt;/i&gt; serves WSDL files (and attached XML Schema Documents), if your
 backend service does not already do so.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="webServiceExplorer">
</xsd:element>
<xsd:element ref="logContext">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="APIsJSON">
</xsd:element>
<xsd:element ref="flowInitiator">
</xsd:element>
<xsd:element ref="counter">
</xsd:element>
<xsd:element ref="rateLimiter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;rateLimiter&lt;/i&gt; plugin limits the number of requests of a client in a period of time.
 As a default the client requests are grouped by client-Ip address and then counted. There are lots of
 possibilities to group the requests using the keyExpression. The requests can even be counted from different
 clients together.&lt;/p&gt;
 &lt;p&gt;When the gateway is located behind a loadbalancer then
 the client-Ip address is not the one from the client but the address from the balancer. To get the real Ip-address loadbalancers,
 &lt;i&gt;Web Application Firewalls&lt;/i&gt; and reverse proxies set the ip from the original client into the &lt;i&gt;X-Forwarded-For&lt;/i&gt; HTTP
 header field. The limiter plugin can take the Ip-address from the header.&lt;/p&gt;
 &lt;p&gt;
 The X-Forwarded-For header can only be trusted when a trustworthy reverse proxy or load balancer is between the client and server. The gateway not should be
 reachable directly. Only activate this feature when you know what you are doing.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="call">
</xsd:element>
<xsd:element ref="oauth2Resource2">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
 authorization server as response.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="if">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The "if" interceptor supports conditional execution of nested plugins.
 &lt;/p&gt;
 See:
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorSpELTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorGroovyTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorJsonpathTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorXPathTest&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="template">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders the body content of a message from a template. The template can
 produce plain text, Json or XML. Variables in the template are substituted with values from the body,
 header, query parameters, etc. If the extension of a referenced template file is &lt;i&gt;.xml&lt;/i&gt; it will use
 &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_xmltemplateengine"&gt;XMLTemplateEngine&lt;/a&gt;
 otherwise &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_streamingtemplateengine"&gt;StreamingTemplateEngine&lt;/a&gt;.
 Have a look at the samples in &lt;a href="https://github.com/membrane/service-proxy/tree/master/distribution/examples"&gt;examples/template&lt;/a&gt;.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="groovyTemplate">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Uses the groovy template markup engine to produce HTML-based responses.
 &lt;code&gt;
 &lt;groovyTemplate&gt;&lt;![CDATA[
   html {
     head {
       title('Resource')
     }
     body {
       p('Hello from Membrane!')
     }
   }
 ]]&gt;&lt;/groovyTemplate&gt;
 &lt;/code&gt;
 &lt;p&gt;
 The word "spring" refers to the Spring ApplicationContext.
 The word "exc" refers to the Membrane Exchange being handled.
 The word "flow" refers to the current Membrane Flow (=REQUEST).
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessLog">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes exchange metrics into a Log4j appender&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Defaults to Apache Common Log pattern&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="prometheus">
</xsd:element>
<xsd:element ref="wadlRewriter">
</xsd:element>
<xsd:element ref="openTelemetry">
</xsd:element>
<xsd:element ref="limit">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Note that due to the streaming nature of Membrane, a request header may already have been passed on to
              the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
              aborted and the connection to the backend is simply closed.
              &lt;/p&gt;
              &lt;p&gt;
              To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
              &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="basicAuthentication">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="json2Xml">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts body payload from JSON to XML. The JSON must be an object other JSON documents e.g. arrays are not supported.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Resulting XML will be in UTF-8 encoding.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shutdown">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Shutdown interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                  Adds the ability to shutdown main router thread via an HTTP request.
                  Don't forget to setup security for this interceptor.
              &lt;/p&gt;
              &lt;p&gt;
                  Has undefined behavior when Membrane is &lt;b&gt;not&lt;/b&gt; started from command line
                  (=via the RouterCLI class, which &lt;tt&gt;service-proxy.ps1&lt;/tt&gt;/&lt;tt&gt;service-proxy.sh&lt;/tt&gt;
                  do use).
              &lt;/p&gt;
              &lt;p&gt;
                  Only actually terminates the running JVM, when used in the first
                  &lt;tt&gt;&lt;router&gt;&lt;/tt&gt; bean (which implicitly stands for
                  &lt;tt&gt;&lt;router id="router"&gt;&lt;/tt&gt;) called "router".
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="userFeature">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapStackTraceFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
              advised to test its functionality in combination with your SOAP service provider before deploying it in
              production.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="formValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiDocs">
</xsd:element>
<xsd:element ref="choose">
</xsd:element>
<xsd:element ref="testService">
</xsd:element>
<xsd:element ref="soap2Rest">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clusterNotification">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane API Gateway distribution.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setHeader">
</xsd:element>
<xsd:element ref="groovy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Groovy script. The script can access and manipulate data from the request and response.
 Use this or the Javascript plugin to extend the functions of Membrane by scripting.
 See: example/groovy for working samples&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtSign">
</xsd:element>
<xsd:element ref="statisticsProvider">
</xsd:element>
<xsd:element ref="replace">
</xsd:element>
<xsd:element ref="methodOverride">
</xsd:element>
<xsd:element ref="stompClient">
</xsd:element>
<xsd:element ref="webSocket">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
 attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="log">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages. The messages will appear either on the console or in
 a log file depending on the log configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="return">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Terminates the exchange flow. The returned response is determined in the following order:
 &lt;p&gt;
 1. If there is already a response in the exchange, that response is returned
 2. If there is no response in the exchange, the body and contentType of the request is copied into a new response.
 &lt;/p&gt;
 &lt;p&gt;
 The options statusCode and contentType will overwrite the values from the messages.
 &lt;/p&gt;
 &lt;p&gt;
 This plugin is useful together with the template plugin. See examples/template.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsCSV">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
              file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="openapiValidator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Validator for OpenAPI documents&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accountRegistration">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="kubernetesValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Kubernetes Integration is still experimental.
 &lt;p&gt;
 To create the CustomResourceDefinitions, apply kubernetes-config.yaml from
 core/target/classes/com/predic8/membrane/core/config/kubernetes/ or a part (e.g. the 'serviceproxies' CRD) of the file.
 &lt;/p&gt;
 &lt;p&gt;
 Create a key and certificate for TLS for &lt;a href="https://membrane-validator.membrane-soa.svc:444/"&gt;https://membrane-validator.membrane-soa.svc:444/&lt;/a&gt; and setup Membrane to serve
 this address. The configuration shown below configures Membrane on a fixed IP address outside of the Kubernetes cluster,
 but this is no requirement.
 &lt;/p&gt;
 &lt;p&gt;
 Embed the following serviceProxy and adjust the 'resources' attribute to a comma-separated list of CRDs that you applied.
 Note that while the CRDs have plural names, here you need to use the corresponding singular. Configure the "ssl" section
 using your key and certificate.
 &lt;/p&gt;
 &lt;code&gt;
 &gt;serviceProxy port="444"&gt;
 &gt;ssl&gt;
 &gt;key&gt;
 &gt;private&gt;
 -----BEGIN RSA PRIVATE KEY-----
 ...
 -----END RSA PRIVATE KEY-----
 &gt;/private&gt;
 &gt;certificate&gt;
 -----BEGIN CERTIFICATE-----
 ...
 -----END CERTIFICATE-----
 &gt;/certificate&gt;
 &gt;/key&gt;
 &gt;/ssl&gt;
 &gt;kubernetesValidation resources="serviceproxy" /&gt;
 &gt;/serviceProxy&gt;
 &lt;/code&gt;
 &lt;p&gt;
 Now register a Webhook to validate the new CRDs. (A note to the experts: Membrane's validation schemas are too
 complex to fit into the CRD, because they are highly nestable and self-referencing. We therefore use webhooks.)
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: admissionregistration.k8s.io/v1
 kind: ValidatingWebhookConfiguration
 metadata:
 name: membrane
 webhooks:
 - name: membrane.membrane-soa.org
 admissionReviewVersions: ["v1", "v1beta1"]
 failurePolicy: Fail
 rules:
 - operations: [ "*" ]
 apiGroups: [ "membrane-soa.org" ]
 apiVersions: [ "v1", "v1beta1" ]
 resources: [ "*" ]
 scope: "*"
 clientConfig:
 service:
 name: membrane-validator
 namespace: membrane-soa
 port: 444
 caBundle: LS0t...LQ0K        # base64 encoded, PEM-formatted CA certificate
 sideEffects: None
 ---
 apiVersion: v1
 kind: Namespace
 metadata:
 name: membrane-soa
 ---
 apiVersion: v1
 kind: Service
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 spec:
 ports:
 - port: 444
 ---
 apiVersion: v1
 kind: Endpoints
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 subsets:
 - addresses:
 - ip: 192.168.0.1   # Membrane's IP
 ports:
 - port: 444
 &lt;/code&gt;
 &lt;p&gt;
 Once this setup is complete, you can enable serviceProxies like this:
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: membrane-soa.org/v1beta1
 kind: serviceproxy
 metadata:
 name: demo
 namespace: membrane-soa
 spec:
 host: demo.predic8.de
 path:
 value: /some-path/
 interceptors:
 - response:
 interceptors:
 - groovy:
 src: |
 println "Hello!"
 target:
 host: thomas-bayer.com
 &lt;/code&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setProperty">
</xsd:element>
<xsd:element ref="javascript">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Javascript. The script can access and manipulate data from the request and response.
 Use this or the Groovy plugin to extend the functions of Membrane by scripting. See the samples in examples/javascript.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="paddingHeader">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="greaser">
</xsd:element>
<xsd:element ref="soapBody">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders a SOAP body for legacy intergration&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;response&gt; plugin you can limit their application to responses only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="throttle">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The throttle feature can slow down traffic to thwart denial of service attacks.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlContentFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
 using an XPath expression.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
 match a message at all. This can improve performance significantly, as a DOM tree does probably not have
 to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
 lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
 namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
 &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
 the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
 constructed.
 &lt;/p&gt;
 &lt;p&gt;
 If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
 XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
 modified reconstituted message.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="headerFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
 The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ntlm">
</xsd:element>
<xsd:element ref="login">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
              application.
              &lt;/p&gt;
              &lt;p&gt;
              Users firstly have to authenticate themselves against a directory server using a username and password.
              Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
              token verification, access to the web application is granted for the user's session. Single Sign On can
              easily be realized using a small source code extension or modification of a web application.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
              each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
              default implementations.)
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
              cell phone number, Single Sign On data, etc.).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
              session cookie).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
              attempts for a specified amount of time.
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
              secondary channel like text messaging).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;/ul&gt;
              &lt;p&gt;
              &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
              title="login interceptor workflow"/&gt;
              &lt;/p&gt;
              &lt;p&gt;
              (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
              possible.)
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
              valid, the workflow is as follows:
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
              &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
              &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
              used. Steps 5 and 6.)&lt;/li&gt;
              &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
              &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
              was directly requested). (Step 8.)&lt;/li&gt;
              &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="sampleSoapService">
</xsd:element>
<xsd:element ref="analyser">
</xsd:element>
<xsd:element ref="validator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlRewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="regExReplacer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="abort" type="com.predic8.membrane.core.config.spring.AbortParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Plugins are usually applied to requests and responses.
 In case of errors, the flow returns and &lt;i&gt;handleAbort()&lt;/i&gt; is called on plugins
 going back the chain.
 By nesting plugins into an &lt;abort&gt; you can limit their application to abort flows only.
 On plugins nested in &lt;abort&gt; handleResponse() is called not handleAbort() in order to
 allow normal processing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiKey">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Secures APIs by validating keys stored in either files or proxies.xml. Keys can be received from clients via HTTP headers or URL query parameters. Additional permission checks are possible through scope validation - scopes are loaded into an Exchange property and can be checked using the "hasScope()" SpEL function.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="oauth2authserver">
</xsd:element>
<xsd:element ref="adminConsole">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="urlNormalizer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Replaces "/./" in the request URI's path by "/".
              &lt;/p&gt;
              &lt;p&gt;
              Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
              links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
              root). The SOA model then combines "&lt;a href="http://foo/material/ArticleService?wsdl"&gt;http://foo/material/ArticleService?wsdl&lt;/a&gt;" and
              "./ArticleService?xsd=1" to "&lt;a href="http://foo/material/./ArticleService?xsd=1"&gt;http://foo/material/./ArticleService?xsd=1&lt;/a&gt;". This URI is sent to Membrane's
              new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
              not match.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ruleMatching">
</xsd:element>
<xsd:element ref="oauth2PermissionChecker">
</xsd:element>
<xsd:element ref="for">
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="reverseDNS" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Whether the remote address should automatically reverse-looked up for incoming connections.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="concurrentConnectionLimitPerIp" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the number of concurrent connections from one ip&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; -1 No Limit&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="coreThreadPoolSize" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Membrane uses a thread pool to allocate threads to incomming clients connections. The core thread pool size is the minimum number of threads that are created in advance to serve client requests.&lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 5&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 20&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="maxThreadPoolSize" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Maximum number of threads to handle incoming connections. (Membrane uses 1 thread per incoming connection.)&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 300&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;no limit&lt;/i&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="socketTimeout" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Socket timout in ms.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 30000&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="tcpNoDelay" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Whether to use the "TCP no delay" option. (=A TCP/IP packet should be constructed as soon as any
              data has been written to the network buffer. With "TCP no delay" set to false, the network hardware
              waits a short period of time wether the software will write more data. When the packet constructed
              from the data in the buffer would exceed the MTU in size, the packet is always constructed and sent
              immediately.)&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="forceSocketCloseOnHotDeployAfter" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; When proxies.xml is changed and &lt;router hotDeploy="true"&gt;, the Spring Context is automatically refreshed,
 which restarts the {@link Router} object (=Membrane API Gateway). Before the context refresh, all open socket connections
 have to be closed. Exchange objects which are still running might delay this process. Setting forceSocketCloseOnHotDeployAfter
 to a non-zero number of milliseconds forces connections to be closed after this time.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 30000&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="backlog" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The backlog value passed to {@link java.net.ServerSocket#ServerSocket(int, int, InetAddress)}. The
 maximum length of the queue of incoming connections.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 50&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.StaticClientListclientParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="clientId" type="xsd:string" use="required">
</xsd:attribute>
<xsd:attribute name="clientSecret" type="xsd:string" use="required">
</xsd:attribute>
<xsd:attribute name="callbackUrl" type="xsd:string" use="required">
</xsd:attribute>
<xsd:attribute name="grantTypes" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Comma separated list of grant types this client can be used with.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; authorization_code,password,client_credentials,refresh_token,implicit&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="openapiValidator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Validator for OpenAPI documents&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="internal">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Internal proxy that can only be invoked by other proxies within the gateway. An internal
 proxy does not listen on any port.&lt;/p&gt;
 &lt;p&gt;Internal proxies are useful to better structure the configuration of the gateway.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If set, Membrane will only consider this rule, if the path of incoming HTTP requests matches.
 {@link Path} supports starts-with and regex matching.
 &lt;/p&gt;
 &lt;p&gt;
 If used in a {@link SOAPProxy}, this causes path rewriting of SOAP requests and in the WSDL to
 automatically be configured.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element name="path" type="com.predic8.membrane.core.config.spring.PathParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The value of the content will be taken to match the path.
              &lt;/p&gt;

              &lt;p&gt;
              If &lt;tt&gt;isRegExp="true"&lt;/tt&gt;, the whole path has to match the given regular expression. If
              &lt;tt&gt;isRegExp="false"&lt;/tt&gt;, the path has to start with the given string.
              &lt;/p&gt;

              &lt;p&gt;
              If &lt;tt&gt;&lt;path /&gt;&lt;/tt&gt; is a child element of a &lt;tt&gt;&lt;soapProxy /&gt;&lt;/tt&gt;, the &lt;tt&gt;isRegExp&lt;/tt&gt;
              attribute must not be present.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Configures the usage of inbound SSL (HTTPS).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element ref="ssl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element ref="httpClient">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
 Server using the HTTP protocol. Usually it will be globally used
 inside the transport. However, it is also possible to use it
 inside a proxy to give the proxy an individual configuration for
 its outgoing HTTP connection that is different from the global
 configuration in the transport.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtAuth">
</xsd:element>
<xsd:element ref="interceptor">
</xsd:element>
<xsd:element ref="tcp">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="tokenValidator">
</xsd:element>
<xsd:element ref="beautifier">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Beautifies request and response bodies. Supported are the Formats: JSON, XML&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="static">
</xsd:element>
<xsd:element ref="jsonProtection">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="http2xml">
</xsd:element>
<xsd:element name="echo" type="com.predic8.membrane.core.config.spring.EchoParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Returns the flow of plugins and copies the content of the
 request into a new response. The response has a status code of 200.
 Useful for testing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xml2Json">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If enabled converts body content from xml to json.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Can be used for both request and response. Xml file assumed to be in UTF-8. If input is invalid it returns
 empty json object.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="authHead2Body">
</xsd:element>
<xsd:element ref="webServer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
 "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
 &lt;/p&gt;
 &lt;p&gt;
 The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
 HTTP response with the contents of a file, or a "404 Not Found." error.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="internalRouting">
</xsd:element>
<xsd:element ref="exchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
              might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="dispatching">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
 element to the list of destinations of the exchange object. It
 must be placed into the transport to make Service Proxies Work
 properly. It has to be placed after the ruleMatching
 interceptor. The ruleMatching interceptor looks up a service
 proxy for an incoming request and places it into the exchange
 object. The dispatching interceptor needs the service proxy to
 get information about the target.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shadowing">
</xsd:element>
<xsd:element ref="openapiPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;openapiPublisher&lt;/i&gt; serves OpenAPI documents
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessControl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
              requested resource.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="acmeHttpChallenge">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See the documentation of the &lt;code&gt;&lt;acme /&gt;&lt;/code&gt; element for usage details.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="transform">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transform feature applies an XSLT transformation to the content in the body of a message. After the
              transformation the body content is replaced with the result of the transformation.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Rewrites or redirects the path of incoming requests based on a mapping.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rest2Soap">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xenAuthentication">
</xsd:element>
<xsd:element ref="graphQLProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Check GraphQL-over-HTTP requests, enforcing several limits and/or restrictions. This effectively helps to reduce
 the attack surface.
 &lt;p&gt;
 GraphQL Specification "October2021" is used. (But GraphQL only covers formulation of Documents/Queries.)
 &lt;/p&gt;
 &lt;p&gt;
 GraphQL-over-HTTP, which specifies how to submit GraphQL queries via HTTP, has not been released/finalized yet. We
 therefore use Version
 &lt;a href="https://github.com/graphql/graphql-over-http/blob/a1e6d8ca248c9a19eb59a2eedd988c204909ee3f/spec/GraphQLOverHTTP.md"&gt;a1e6d8ca&lt;/a&gt;.
 &lt;/p&gt;
 &lt;p&gt;
 Only GraphQL documents conforming to the 'ExecutableDocument' of the grammar are allowed: This includes the usual
 'query', 'mutation', 'subscription' and 'fragment's.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapOperationExtractor">
</xsd:element>
<xsd:element ref="balancer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="reverseProxying">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
 as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
 hostnames and ports used to access Membrane  vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clamav">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Delegates virus checks to an external Virus Scanner.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="destination">
</xsd:element>
<xsd:element ref="requireAuth">
</xsd:element>
<xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;request&gt; Element you can limit their application to requests only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="cache">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Don't use, this does NOT implement valid HTTP caching.
              &lt;/p&gt;
              &lt;p&gt;
                  We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                  the Docker Registry for offline use.
                  The cache does not revalidate any responses, so machines querying the cache for Debian
                  package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                  This is - simply put - the only use case, where using this class makes any sense.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsJDBC">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
 database (one row per exchange).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="index">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
              To use this feature just add a serviceProxy containing the index
              element. Of course you can protect the service proxy by using
              SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;wsdlPublisher&lt;/i&gt; serves WSDL files (and attached XML Schema Documents), if your
 backend service does not already do so.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="webServiceExplorer">
</xsd:element>
<xsd:element ref="logContext">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="APIsJSON">
</xsd:element>
<xsd:element ref="flowInitiator">
</xsd:element>
<xsd:element ref="counter">
</xsd:element>
<xsd:element ref="rateLimiter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;rateLimiter&lt;/i&gt; plugin limits the number of requests of a client in a period of time.
 As a default the client requests are grouped by client-Ip address and then counted. There are lots of
 possibilities to group the requests using the keyExpression. The requests can even be counted from different
 clients together.&lt;/p&gt;
 &lt;p&gt;When the gateway is located behind a loadbalancer then
 the client-Ip address is not the one from the client but the address from the balancer. To get the real Ip-address loadbalancers,
 &lt;i&gt;Web Application Firewalls&lt;/i&gt; and reverse proxies set the ip from the original client into the &lt;i&gt;X-Forwarded-For&lt;/i&gt; HTTP
 header field. The limiter plugin can take the Ip-address from the header.&lt;/p&gt;
 &lt;p&gt;
 The X-Forwarded-For header can only be trusted when a trustworthy reverse proxy or load balancer is between the client and server. The gateway not should be
 reachable directly. Only activate this feature when you know what you are doing.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="call">
</xsd:element>
<xsd:element ref="oauth2Resource2">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
 authorization server as response.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="if">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The "if" interceptor supports conditional execution of nested plugins.
 &lt;/p&gt;
 See:
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorSpELTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorGroovyTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorJsonpathTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorXPathTest&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="template">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders the body content of a message from a template. The template can
 produce plain text, Json or XML. Variables in the template are substituted with values from the body,
 header, query parameters, etc. If the extension of a referenced template file is &lt;i&gt;.xml&lt;/i&gt; it will use
 &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_xmltemplateengine"&gt;XMLTemplateEngine&lt;/a&gt;
 otherwise &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_streamingtemplateengine"&gt;StreamingTemplateEngine&lt;/a&gt;.
 Have a look at the samples in &lt;a href="https://github.com/membrane/service-proxy/tree/master/distribution/examples"&gt;examples/template&lt;/a&gt;.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="groovyTemplate">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Uses the groovy template markup engine to produce HTML-based responses.
 &lt;code&gt;
 &lt;groovyTemplate&gt;&lt;![CDATA[
   html {
     head {
       title('Resource')
     }
     body {
       p('Hello from Membrane!')
     }
   }
 ]]&gt;&lt;/groovyTemplate&gt;
 &lt;/code&gt;
 &lt;p&gt;
 The word "spring" refers to the Spring ApplicationContext.
 The word "exc" refers to the Membrane Exchange being handled.
 The word "flow" refers to the current Membrane Flow (=REQUEST).
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessLog">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes exchange metrics into a Log4j appender&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Defaults to Apache Common Log pattern&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="prometheus">
</xsd:element>
<xsd:element ref="wadlRewriter">
</xsd:element>
<xsd:element ref="openTelemetry">
</xsd:element>
<xsd:element ref="limit">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Note that due to the streaming nature of Membrane, a request header may already have been passed on to
              the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
              aborted and the connection to the backend is simply closed.
              &lt;/p&gt;
              &lt;p&gt;
              To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
              &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="basicAuthentication">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="json2Xml">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts body payload from JSON to XML. The JSON must be an object other JSON documents e.g. arrays are not supported.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Resulting XML will be in UTF-8 encoding.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shutdown">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Shutdown interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                  Adds the ability to shutdown main router thread via an HTTP request.
                  Don't forget to setup security for this interceptor.
              &lt;/p&gt;
              &lt;p&gt;
                  Has undefined behavior when Membrane is &lt;b&gt;not&lt;/b&gt; started from command line
                  (=via the RouterCLI class, which &lt;tt&gt;service-proxy.ps1&lt;/tt&gt;/&lt;tt&gt;service-proxy.sh&lt;/tt&gt;
                  do use).
              &lt;/p&gt;
              &lt;p&gt;
                  Only actually terminates the running JVM, when used in the first
                  &lt;tt&gt;&lt;router&gt;&lt;/tt&gt; bean (which implicitly stands for
                  &lt;tt&gt;&lt;router id="router"&gt;&lt;/tt&gt;) called "router".
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="userFeature">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapStackTraceFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
              advised to test its functionality in combination with your SOAP service provider before deploying it in
              production.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="formValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiDocs">
</xsd:element>
<xsd:element ref="choose">
</xsd:element>
<xsd:element ref="testService">
</xsd:element>
<xsd:element ref="soap2Rest">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clusterNotification">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane API Gateway distribution.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setHeader">
</xsd:element>
<xsd:element ref="groovy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Groovy script. The script can access and manipulate data from the request and response.
 Use this or the Javascript plugin to extend the functions of Membrane by scripting.
 See: example/groovy for working samples&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtSign">
</xsd:element>
<xsd:element ref="statisticsProvider">
</xsd:element>
<xsd:element ref="replace">
</xsd:element>
<xsd:element ref="methodOverride">
</xsd:element>
<xsd:element ref="stompClient">
</xsd:element>
<xsd:element ref="webSocket">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
 attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="log">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages. The messages will appear either on the console or in
 a log file depending on the log configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="return">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Terminates the exchange flow. The returned response is determined in the following order:
 &lt;p&gt;
 1. If there is already a response in the exchange, that response is returned
 2. If there is no response in the exchange, the body and contentType of the request is copied into a new response.
 &lt;/p&gt;
 &lt;p&gt;
 The options statusCode and contentType will overwrite the values from the messages.
 &lt;/p&gt;
 &lt;p&gt;
 This plugin is useful together with the template plugin. See examples/template.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsCSV">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
              file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="openapiValidator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Validator for OpenAPI documents&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accountRegistration">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="kubernetesValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Kubernetes Integration is still experimental.
 &lt;p&gt;
 To create the CustomResourceDefinitions, apply kubernetes-config.yaml from
 core/target/classes/com/predic8/membrane/core/config/kubernetes/ or a part (e.g. the 'serviceproxies' CRD) of the file.
 &lt;/p&gt;
 &lt;p&gt;
 Create a key and certificate for TLS for &lt;a href="https://membrane-validator.membrane-soa.svc:444/"&gt;https://membrane-validator.membrane-soa.svc:444/&lt;/a&gt; and setup Membrane to serve
 this address. The configuration shown below configures Membrane on a fixed IP address outside of the Kubernetes cluster,
 but this is no requirement.
 &lt;/p&gt;
 &lt;p&gt;
 Embed the following serviceProxy and adjust the 'resources' attribute to a comma-separated list of CRDs that you applied.
 Note that while the CRDs have plural names, here you need to use the corresponding singular. Configure the "ssl" section
 using your key and certificate.
 &lt;/p&gt;
 &lt;code&gt;
 &gt;serviceProxy port="444"&gt;
 &gt;ssl&gt;
 &gt;key&gt;
 &gt;private&gt;
 -----BEGIN RSA PRIVATE KEY-----
 ...
 -----END RSA PRIVATE KEY-----
 &gt;/private&gt;
 &gt;certificate&gt;
 -----BEGIN CERTIFICATE-----
 ...
 -----END CERTIFICATE-----
 &gt;/certificate&gt;
 &gt;/key&gt;
 &gt;/ssl&gt;
 &gt;kubernetesValidation resources="serviceproxy" /&gt;
 &gt;/serviceProxy&gt;
 &lt;/code&gt;
 &lt;p&gt;
 Now register a Webhook to validate the new CRDs. (A note to the experts: Membrane's validation schemas are too
 complex to fit into the CRD, because they are highly nestable and self-referencing. We therefore use webhooks.)
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: admissionregistration.k8s.io/v1
 kind: ValidatingWebhookConfiguration
 metadata:
 name: membrane
 webhooks:
 - name: membrane.membrane-soa.org
 admissionReviewVersions: ["v1", "v1beta1"]
 failurePolicy: Fail
 rules:
 - operations: [ "*" ]
 apiGroups: [ "membrane-soa.org" ]
 apiVersions: [ "v1", "v1beta1" ]
 resources: [ "*" ]
 scope: "*"
 clientConfig:
 service:
 name: membrane-validator
 namespace: membrane-soa
 port: 444
 caBundle: LS0t...LQ0K        # base64 encoded, PEM-formatted CA certificate
 sideEffects: None
 ---
 apiVersion: v1
 kind: Namespace
 metadata:
 name: membrane-soa
 ---
 apiVersion: v1
 kind: Service
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 spec:
 ports:
 - port: 444
 ---
 apiVersion: v1
 kind: Endpoints
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 subsets:
 - addresses:
 - ip: 192.168.0.1   # Membrane's IP
 ports:
 - port: 444
 &lt;/code&gt;
 &lt;p&gt;
 Once this setup is complete, you can enable serviceProxies like this:
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: membrane-soa.org/v1beta1
 kind: serviceproxy
 metadata:
 name: demo
 namespace: membrane-soa
 spec:
 host: demo.predic8.de
 path:
 value: /some-path/
 interceptors:
 - response:
 interceptors:
 - groovy:
 src: |
 println "Hello!"
 target:
 host: thomas-bayer.com
 &lt;/code&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setProperty">
</xsd:element>
<xsd:element ref="javascript">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Javascript. The script can access and manipulate data from the request and response.
 Use this or the Groovy plugin to extend the functions of Membrane by scripting. See the samples in examples/javascript.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="paddingHeader">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="greaser">
</xsd:element>
<xsd:element ref="soapBody">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders a SOAP body for legacy intergration&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;response&gt; plugin you can limit their application to responses only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="throttle">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The throttle feature can slow down traffic to thwart denial of service attacks.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlContentFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
 using an XPath expression.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
 match a message at all. This can improve performance significantly, as a DOM tree does probably not have
 to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
 lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
 namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
 &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
 the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
 constructed.
 &lt;/p&gt;
 &lt;p&gt;
 If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
 XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
 modified reconstituted message.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="headerFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
 The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ntlm">
</xsd:element>
<xsd:element ref="login">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
              application.
              &lt;/p&gt;
              &lt;p&gt;
              Users firstly have to authenticate themselves against a directory server using a username and password.
              Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
              token verification, access to the web application is granted for the user's session. Single Sign On can
              easily be realized using a small source code extension or modification of a web application.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
              each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
              default implementations.)
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
              cell phone number, Single Sign On data, etc.).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
              session cookie).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
              attempts for a specified amount of time.
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
              secondary channel like text messaging).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;/ul&gt;
              &lt;p&gt;
              &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
              title="login interceptor workflow"/&gt;
              &lt;/p&gt;
              &lt;p&gt;
              (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
              possible.)
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
              valid, the workflow is as follows:
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
              &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
              &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
              used. Steps 5 and 6.)&lt;/li&gt;
              &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
              &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
              was directly requested). (Step 8.)&lt;/li&gt;
              &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="sampleSoapService">
</xsd:element>
<xsd:element ref="analyser">
</xsd:element>
<xsd:element ref="validator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlRewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="regExReplacer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="abort" type="com.predic8.membrane.core.config.spring.AbortParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Plugins are usually applied to requests and responses.
 In case of errors, the flow returns and &lt;i&gt;handleAbort()&lt;/i&gt; is called on plugins
 going back the chain.
 By nesting plugins into an &lt;abort&gt; you can limit their application to abort flows only.
 On plugins nested in &lt;abort&gt; handleResponse() is called not handleAbort() in order to
 allow normal processing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiKey">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Secures APIs by validating keys stored in either files or proxies.xml. Keys can be received from clients via HTTP headers or URL query parameters. Additional permission checks are possible through scope validation - scopes are loaded into an Exchange property and can be checked using the "hasScope()" SpEL function.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="oauth2authserver">
</xsd:element>
<xsd:element ref="adminConsole">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="urlNormalizer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Replaces "/./" in the request URI's path by "/".
              &lt;/p&gt;
              &lt;p&gt;
              Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
              links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
              root). The SOA model then combines "&lt;a href="http://foo/material/ArticleService?wsdl"&gt;http://foo/material/ArticleService?wsdl&lt;/a&gt;" and
              "./ArticleService?xsd=1" to "&lt;a href="http://foo/material/./ArticleService?xsd=1"&gt;http://foo/material/./ArticleService?xsd=1&lt;/a&gt;". This URI is sent to Membrane's
              new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
              not match.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ruleMatching">
</xsd:element>
<xsd:element ref="oauth2PermissionChecker">
</xsd:element>
<xsd:element ref="for">
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element name="target" type="com.predic8.membrane.core.config.spring.TargetParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The destination where the service proxy will send messages to. Use the target element, if you want
 to send the messages to a static target. If you want to use dynamic destinations have a look at the
 &lt;a href="https://membrane-soa.org/service-proxy-doc/configuration/reference/router.htm"&gt;content based router&lt;/a&gt;.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="name" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The name as shown in the Admin Console.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; By default, a name will be automatically generated from the target host, port, etc.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="blockRequest" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;legacy attribute&lt;/i&gt; for usage by Membrane Monitor&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="blockResponse" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;legacy attribute&lt;/i&gt; for usage by Membrane Monitor&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="port" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The port Membrane listens on for incoming connections.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 8080&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 80&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="ip" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If present, binds the port only on the specified IP. Useful for hosts with multiple IP addresses.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 127.0.0.1&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;not set&lt;/i&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="host" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;A space separated list of hostnames. If set, Membrane will only consider this rule, if the "Host"
 header of incoming HTTP requests matches one of the hostnames.
 &lt;/p&gt;
 &lt;p&gt;
 The asterisk '*' can be used for basic globbing (to match any number, including zero, characters).
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; predic8.de *.predic8.de&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;not set&lt;/i&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.OpenapiParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element name="rewrite" type="com.predic8.membrane.core.config.spring.RewriteParser">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="location" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Filename or URL pointing to an OpenAPI document. Relative filenames use the %MEMBRANE_HOME%/conf folder as base directory.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; openapi/fruitstore-v1.yaml, &lt;a href="https://api.predic8.de/shop/swagger"&gt;https://api.predic8.de/shop/swagger&lt;/a&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="dir" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Directory containing OpenAPI definitions to deploy.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; openapi&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="validateRequests" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Turn validation of requests on or off.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; yes&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; no&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="validateResponses" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Turn validation of responses on or off.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; yes&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; no&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="validationDetails" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Show details of the validation to the caller.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; yes&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; no&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="validateSecurity" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="accountRegistration">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="defaultConfig">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="membrane">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; defines a chain of interceptors that are run for the dynamic registration process of openid-connect&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element ref="registration">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element ref="ssl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="httpClientConfiguration" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="clientId" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="clientSecret" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="scope" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="useJWTForClientAuth" type="spel_boolean" >
</xsd:attribute>
<xsd:attribute name="subject" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="src" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="internalSrc" type="xsd:string" >
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="claims" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; claims that are requested for the userinfo endpoint&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="claimsIdt" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; claims that are requested for the id_token&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="fileExchangeStore">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="dir" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Directory where the exchanges are saved.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; logs&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="raw" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If this is true, headers will always be printed (overriding
              saveBodyOnly) and the body of the exchange won't be
              formatted nicely.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="saveBodyOnly" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If this is true, no headers will be written to the exchange
              log files.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="maxDays" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Number of days for which exchange logs are preserved. A
              value smaller than zero deactivates the deletion of old
              logs.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 60&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; -1&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.ClusterParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Specifies a node.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element name="node" type="com.predic8.membrane.core.config.spring.NodeParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="name" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Sets the name of the cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; Default&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="keyTable">
<xsd:complexType>
<xsd:complexContent mixed="true">
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/></xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.WhateverMobileSMSTokenProviderParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="prefixText" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A string that will be prepended to the token when creating the text message.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; "Token: "&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; "Token: "&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="simulate" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Don't send any text messages, only write tokens to the log.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="gatewayUserName" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Your whatevermobile.com gateway user name.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="gatewayPassword" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Your whatevermobile.com gateway password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="senderName" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The sender name of the text messages. This string is displayed as the sender on the recipient's phone.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; Your Organization Name&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; Membrane&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="backupServiceAvailable" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Specify whether the alternative gateway is available for the configured account&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="kubernetesValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Kubernetes Integration is still experimental.
 &lt;p&gt;
 To create the CustomResourceDefinitions, apply kubernetes-config.yaml from
 core/target/classes/com/predic8/membrane/core/config/kubernetes/ or a part (e.g. the 'serviceproxies' CRD) of the file.
 &lt;/p&gt;
 &lt;p&gt;
 Create a key and certificate for TLS for &lt;a href="https://membrane-validator.membrane-soa.svc:444/"&gt;https://membrane-validator.membrane-soa.svc:444/&lt;/a&gt; and setup Membrane to serve
 this address. The configuration shown below configures Membrane on a fixed IP address outside of the Kubernetes cluster,
 but this is no requirement.
 &lt;/p&gt;
 &lt;p&gt;
 Embed the following serviceProxy and adjust the 'resources' attribute to a comma-separated list of CRDs that you applied.
 Note that while the CRDs have plural names, here you need to use the corresponding singular. Configure the "ssl" section
 using your key and certificate.
 &lt;/p&gt;
 &lt;code&gt;
 &gt;serviceProxy port="444"&gt;
 &gt;ssl&gt;
 &gt;key&gt;
 &gt;private&gt;
 -----BEGIN RSA PRIVATE KEY-----
 ...
 -----END RSA PRIVATE KEY-----
 &gt;/private&gt;
 &gt;certificate&gt;
 -----BEGIN CERTIFICATE-----
 ...
 -----END CERTIFICATE-----
 &gt;/certificate&gt;
 &gt;/key&gt;
 &gt;/ssl&gt;
 &gt;kubernetesValidation resources="serviceproxy" /&gt;
 &gt;/serviceProxy&gt;
 &lt;/code&gt;
 &lt;p&gt;
 Now register a Webhook to validate the new CRDs. (A note to the experts: Membrane's validation schemas are too
 complex to fit into the CRD, because they are highly nestable and self-referencing. We therefore use webhooks.)
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: admissionregistration.k8s.io/v1
 kind: ValidatingWebhookConfiguration
 metadata:
 name: membrane
 webhooks:
 - name: membrane.membrane-soa.org
 admissionReviewVersions: ["v1", "v1beta1"]
 failurePolicy: Fail
 rules:
 - operations: [ "*" ]
 apiGroups: [ "membrane-soa.org" ]
 apiVersions: [ "v1", "v1beta1" ]
 resources: [ "*" ]
 scope: "*"
 clientConfig:
 service:
 name: membrane-validator
 namespace: membrane-soa
 port: 444
 caBundle: LS0t...LQ0K        # base64 encoded, PEM-formatted CA certificate
 sideEffects: None
 ---
 apiVersion: v1
 kind: Namespace
 metadata:
 name: membrane-soa
 ---
 apiVersion: v1
 kind: Service
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 spec:
 ports:
 - port: 444
 ---
 apiVersion: v1
 kind: Endpoints
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 subsets:
 - addresses:
 - ip: 192.168.0.1   # Membrane's IP
 ports:
 - port: 444
 &lt;/code&gt;
 &lt;p&gt;
 Once this setup is complete, you can enable serviceProxies like this:
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: membrane-soa.org/v1beta1
 kind: serviceproxy
 metadata:
 name: demo
 namespace: membrane-soa
 spec:
 host: demo.predic8.de
 path:
 value: /some-path/
 interceptors:
 - response:
 interceptors:
 - groovy:
 src: |
 println "Hello!"
 target:
 host: thomas-bayer.com
 &lt;/code&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="resources" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The resources (CustomResourceDefinition Kinds, singular) to watch in the Kubernetes API, comma separated.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; serviceproxy, ssl&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="namespaces" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The list of namespaces to watch, comma separated. A single '*' means "watch all namespaces".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; *&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; membrane-soa&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="setProperty">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="language" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the language of the 'test' condition&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; SpEL, groovy, jsonpath, xpath&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; groovy&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="ifAbsent" type="spel_boolean" >
</xsd:attribute>
<xsd:attribute name="name" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="value" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="failOnError" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="javascript">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Javascript. The script can access and manipulate data from the request and response.
 Use this or the Groovy plugin to extend the functions of Membrane by scripting. See the samples in examples/javascript.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent mixed="true">
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/></xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.GoogleParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element ref="ssl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="httpClientConfiguration" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="clientId" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="clientSecret" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="scope" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="useJWTForClientAuth" type="spel_boolean" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="paddingHeader">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="roundUp" type="spel_number" >
</xsd:attribute>
<xsd:attribute name="constant" type="spel_number" >
</xsd:attribute>
<xsd:attribute name="random" type="spel_number" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="wsLog">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="encoding" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="greaser">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element name="greaseJson" type="com.predic8.membrane.core.config.spring.GreaseJsonParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="rate" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="soapBody">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders a SOAP body for legacy intergration&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent mixed="true">
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/></xsd:sequence>
<xsd:attribute name="location" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="contentType" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="pretty" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="version" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.AzureTableStorageParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element ref="httpClientConfig">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="storageAccountName" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="storageAccountKey" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="tableName" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="partitionKey" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:complexType name="com.predic8.membrane.core.config.spring.OtherwiseParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element ref="httpClient">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
 Server using the HTTP protocol. Usually it will be globally used
 inside the transport. However, it is also possible to use it
 inside a proxy to give the proxy an individual configuration for
 its outgoing HTTP connection that is different from the global
 configuration in the transport.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtAuth">
</xsd:element>
<xsd:element ref="interceptor">
</xsd:element>
<xsd:element ref="tcp">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="tokenValidator">
</xsd:element>
<xsd:element ref="beautifier">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Beautifies request and response bodies. Supported are the Formats: JSON, XML&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="static">
</xsd:element>
<xsd:element ref="jsonProtection">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="http2xml">
</xsd:element>
<xsd:element name="echo" type="com.predic8.membrane.core.config.spring.EchoParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Returns the flow of plugins and copies the content of the
 request into a new response. The response has a status code of 200.
 Useful for testing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xml2Json">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If enabled converts body content from xml to json.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Can be used for both request and response. Xml file assumed to be in UTF-8. If input is invalid it returns
 empty json object.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="authHead2Body">
</xsd:element>
<xsd:element ref="webServer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
 "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
 &lt;/p&gt;
 &lt;p&gt;
 The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
 HTTP response with the contents of a file, or a "404 Not Found." error.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="internalRouting">
</xsd:element>
<xsd:element ref="exchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
              might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="dispatching">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
 element to the list of destinations of the exchange object. It
 must be placed into the transport to make Service Proxies Work
 properly. It has to be placed after the ruleMatching
 interceptor. The ruleMatching interceptor looks up a service
 proxy for an incoming request and places it into the exchange
 object. The dispatching interceptor needs the service proxy to
 get information about the target.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shadowing">
</xsd:element>
<xsd:element ref="openapiPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;openapiPublisher&lt;/i&gt; serves OpenAPI documents
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessControl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
              requested resource.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="acmeHttpChallenge">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See the documentation of the &lt;code&gt;&lt;acme /&gt;&lt;/code&gt; element for usage details.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="transform">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transform feature applies an XSLT transformation to the content in the body of a message. After the
              transformation the body content is replaced with the result of the transformation.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Rewrites or redirects the path of incoming requests based on a mapping.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rest2Soap">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xenAuthentication">
</xsd:element>
<xsd:element ref="graphQLProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Check GraphQL-over-HTTP requests, enforcing several limits and/or restrictions. This effectively helps to reduce
 the attack surface.
 &lt;p&gt;
 GraphQL Specification "October2021" is used. (But GraphQL only covers formulation of Documents/Queries.)
 &lt;/p&gt;
 &lt;p&gt;
 GraphQL-over-HTTP, which specifies how to submit GraphQL queries via HTTP, has not been released/finalized yet. We
 therefore use Version
 &lt;a href="https://github.com/graphql/graphql-over-http/blob/a1e6d8ca248c9a19eb59a2eedd988c204909ee3f/spec/GraphQLOverHTTP.md"&gt;a1e6d8ca&lt;/a&gt;.
 &lt;/p&gt;
 &lt;p&gt;
 Only GraphQL documents conforming to the 'ExecutableDocument' of the grammar are allowed: This includes the usual
 'query', 'mutation', 'subscription' and 'fragment's.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapOperationExtractor">
</xsd:element>
<xsd:element ref="balancer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="reverseProxying">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
 as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
 hostnames and ports used to access Membrane  vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clamav">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Delegates virus checks to an external Virus Scanner.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="destination">
</xsd:element>
<xsd:element ref="requireAuth">
</xsd:element>
<xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;request&gt; Element you can limit their application to requests only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="cache">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Don't use, this does NOT implement valid HTTP caching.
              &lt;/p&gt;
              &lt;p&gt;
                  We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                  the Docker Registry for offline use.
                  The cache does not revalidate any responses, so machines querying the cache for Debian
                  package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                  This is - simply put - the only use case, where using this class makes any sense.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsJDBC">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
 database (one row per exchange).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="index">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
              To use this feature just add a serviceProxy containing the index
              element. Of course you can protect the service proxy by using
              SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;wsdlPublisher&lt;/i&gt; serves WSDL files (and attached XML Schema Documents), if your
 backend service does not already do so.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="webServiceExplorer">
</xsd:element>
<xsd:element ref="logContext">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="APIsJSON">
</xsd:element>
<xsd:element ref="flowInitiator">
</xsd:element>
<xsd:element ref="counter">
</xsd:element>
<xsd:element ref="rateLimiter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;rateLimiter&lt;/i&gt; plugin limits the number of requests of a client in a period of time.
 As a default the client requests are grouped by client-Ip address and then counted. There are lots of
 possibilities to group the requests using the keyExpression. The requests can even be counted from different
 clients together.&lt;/p&gt;
 &lt;p&gt;When the gateway is located behind a loadbalancer then
 the client-Ip address is not the one from the client but the address from the balancer. To get the real Ip-address loadbalancers,
 &lt;i&gt;Web Application Firewalls&lt;/i&gt; and reverse proxies set the ip from the original client into the &lt;i&gt;X-Forwarded-For&lt;/i&gt; HTTP
 header field. The limiter plugin can take the Ip-address from the header.&lt;/p&gt;
 &lt;p&gt;
 The X-Forwarded-For header can only be trusted when a trustworthy reverse proxy or load balancer is between the client and server. The gateway not should be
 reachable directly. Only activate this feature when you know what you are doing.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="call">
</xsd:element>
<xsd:element ref="oauth2Resource2">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
 authorization server as response.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="if">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The "if" interceptor supports conditional execution of nested plugins.
 &lt;/p&gt;
 See:
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorSpELTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorGroovyTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorJsonpathTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorXPathTest&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="template">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders the body content of a message from a template. The template can
 produce plain text, Json or XML. Variables in the template are substituted with values from the body,
 header, query parameters, etc. If the extension of a referenced template file is &lt;i&gt;.xml&lt;/i&gt; it will use
 &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_xmltemplateengine"&gt;XMLTemplateEngine&lt;/a&gt;
 otherwise &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_streamingtemplateengine"&gt;StreamingTemplateEngine&lt;/a&gt;.
 Have a look at the samples in &lt;a href="https://github.com/membrane/service-proxy/tree/master/distribution/examples"&gt;examples/template&lt;/a&gt;.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="groovyTemplate">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Uses the groovy template markup engine to produce HTML-based responses.
 &lt;code&gt;
 &lt;groovyTemplate&gt;&lt;![CDATA[
   html {
     head {
       title('Resource')
     }
     body {
       p('Hello from Membrane!')
     }
   }
 ]]&gt;&lt;/groovyTemplate&gt;
 &lt;/code&gt;
 &lt;p&gt;
 The word "spring" refers to the Spring ApplicationContext.
 The word "exc" refers to the Membrane Exchange being handled.
 The word "flow" refers to the current Membrane Flow (=REQUEST).
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessLog">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes exchange metrics into a Log4j appender&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Defaults to Apache Common Log pattern&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="prometheus">
</xsd:element>
<xsd:element ref="wadlRewriter">
</xsd:element>
<xsd:element ref="openTelemetry">
</xsd:element>
<xsd:element ref="limit">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Note that due to the streaming nature of Membrane, a request header may already have been passed on to
              the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
              aborted and the connection to the backend is simply closed.
              &lt;/p&gt;
              &lt;p&gt;
              To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
              &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="basicAuthentication">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="json2Xml">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts body payload from JSON to XML. The JSON must be an object other JSON documents e.g. arrays are not supported.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Resulting XML will be in UTF-8 encoding.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shutdown">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Shutdown interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                  Adds the ability to shutdown main router thread via an HTTP request.
                  Don't forget to setup security for this interceptor.
              &lt;/p&gt;
              &lt;p&gt;
                  Has undefined behavior when Membrane is &lt;b&gt;not&lt;/b&gt; started from command line
                  (=via the RouterCLI class, which &lt;tt&gt;service-proxy.ps1&lt;/tt&gt;/&lt;tt&gt;service-proxy.sh&lt;/tt&gt;
                  do use).
              &lt;/p&gt;
              &lt;p&gt;
                  Only actually terminates the running JVM, when used in the first
                  &lt;tt&gt;&lt;router&gt;&lt;/tt&gt; bean (which implicitly stands for
                  &lt;tt&gt;&lt;router id="router"&gt;&lt;/tt&gt;) called "router".
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="userFeature">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapStackTraceFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
              advised to test its functionality in combination with your SOAP service provider before deploying it in
              production.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="formValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiDocs">
</xsd:element>
<xsd:element ref="choose">
</xsd:element>
<xsd:element ref="testService">
</xsd:element>
<xsd:element ref="soap2Rest">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clusterNotification">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane API Gateway distribution.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setHeader">
</xsd:element>
<xsd:element ref="groovy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Groovy script. The script can access and manipulate data from the request and response.
 Use this or the Javascript plugin to extend the functions of Membrane by scripting.
 See: example/groovy for working samples&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtSign">
</xsd:element>
<xsd:element ref="statisticsProvider">
</xsd:element>
<xsd:element ref="replace">
</xsd:element>
<xsd:element ref="methodOverride">
</xsd:element>
<xsd:element ref="stompClient">
</xsd:element>
<xsd:element ref="webSocket">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
 attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="log">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages. The messages will appear either on the console or in
 a log file depending on the log configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="return">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Terminates the exchange flow. The returned response is determined in the following order:
 &lt;p&gt;
 1. If there is already a response in the exchange, that response is returned
 2. If there is no response in the exchange, the body and contentType of the request is copied into a new response.
 &lt;/p&gt;
 &lt;p&gt;
 The options statusCode and contentType will overwrite the values from the messages.
 &lt;/p&gt;
 &lt;p&gt;
 This plugin is useful together with the template plugin. See examples/template.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsCSV">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
              file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="openapiValidator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Validator for OpenAPI documents&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accountRegistration">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="kubernetesValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Kubernetes Integration is still experimental.
 &lt;p&gt;
 To create the CustomResourceDefinitions, apply kubernetes-config.yaml from
 core/target/classes/com/predic8/membrane/core/config/kubernetes/ or a part (e.g. the 'serviceproxies' CRD) of the file.
 &lt;/p&gt;
 &lt;p&gt;
 Create a key and certificate for TLS for &lt;a href="https://membrane-validator.membrane-soa.svc:444/"&gt;https://membrane-validator.membrane-soa.svc:444/&lt;/a&gt; and setup Membrane to serve
 this address. The configuration shown below configures Membrane on a fixed IP address outside of the Kubernetes cluster,
 but this is no requirement.
 &lt;/p&gt;
 &lt;p&gt;
 Embed the following serviceProxy and adjust the 'resources' attribute to a comma-separated list of CRDs that you applied.
 Note that while the CRDs have plural names, here you need to use the corresponding singular. Configure the "ssl" section
 using your key and certificate.
 &lt;/p&gt;
 &lt;code&gt;
 &gt;serviceProxy port="444"&gt;
 &gt;ssl&gt;
 &gt;key&gt;
 &gt;private&gt;
 -----BEGIN RSA PRIVATE KEY-----
 ...
 -----END RSA PRIVATE KEY-----
 &gt;/private&gt;
 &gt;certificate&gt;
 -----BEGIN CERTIFICATE-----
 ...
 -----END CERTIFICATE-----
 &gt;/certificate&gt;
 &gt;/key&gt;
 &gt;/ssl&gt;
 &gt;kubernetesValidation resources="serviceproxy" /&gt;
 &gt;/serviceProxy&gt;
 &lt;/code&gt;
 &lt;p&gt;
 Now register a Webhook to validate the new CRDs. (A note to the experts: Membrane's validation schemas are too
 complex to fit into the CRD, because they are highly nestable and self-referencing. We therefore use webhooks.)
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: admissionregistration.k8s.io/v1
 kind: ValidatingWebhookConfiguration
 metadata:
 name: membrane
 webhooks:
 - name: membrane.membrane-soa.org
 admissionReviewVersions: ["v1", "v1beta1"]
 failurePolicy: Fail
 rules:
 - operations: [ "*" ]
 apiGroups: [ "membrane-soa.org" ]
 apiVersions: [ "v1", "v1beta1" ]
 resources: [ "*" ]
 scope: "*"
 clientConfig:
 service:
 name: membrane-validator
 namespace: membrane-soa
 port: 444
 caBundle: LS0t...LQ0K        # base64 encoded, PEM-formatted CA certificate
 sideEffects: None
 ---
 apiVersion: v1
 kind: Namespace
 metadata:
 name: membrane-soa
 ---
 apiVersion: v1
 kind: Service
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 spec:
 ports:
 - port: 444
 ---
 apiVersion: v1
 kind: Endpoints
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 subsets:
 - addresses:
 - ip: 192.168.0.1   # Membrane's IP
 ports:
 - port: 444
 &lt;/code&gt;
 &lt;p&gt;
 Once this setup is complete, you can enable serviceProxies like this:
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: membrane-soa.org/v1beta1
 kind: serviceproxy
 metadata:
 name: demo
 namespace: membrane-soa
 spec:
 host: demo.predic8.de
 path:
 value: /some-path/
 interceptors:
 - response:
 interceptors:
 - groovy:
 src: |
 println "Hello!"
 target:
 host: thomas-bayer.com
 &lt;/code&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setProperty">
</xsd:element>
<xsd:element ref="javascript">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Javascript. The script can access and manipulate data from the request and response.
 Use this or the Groovy plugin to extend the functions of Membrane by scripting. See the samples in examples/javascript.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="paddingHeader">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="greaser">
</xsd:element>
<xsd:element ref="soapBody">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders a SOAP body for legacy intergration&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;response&gt; plugin you can limit their application to responses only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="throttle">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The throttle feature can slow down traffic to thwart denial of service attacks.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlContentFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
 using an XPath expression.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
 match a message at all. This can improve performance significantly, as a DOM tree does probably not have
 to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
 lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
 namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
 &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
 the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
 constructed.
 &lt;/p&gt;
 &lt;p&gt;
 If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
 XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
 modified reconstituted message.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="headerFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
 The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ntlm">
</xsd:element>
<xsd:element ref="login">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
              application.
              &lt;/p&gt;
              &lt;p&gt;
              Users firstly have to authenticate themselves against a directory server using a username and password.
              Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
              token verification, access to the web application is granted for the user's session. Single Sign On can
              easily be realized using a small source code extension or modification of a web application.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
              each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
              default implementations.)
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
              cell phone number, Single Sign On data, etc.).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
              session cookie).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
              attempts for a specified amount of time.
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
              secondary channel like text messaging).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;/ul&gt;
              &lt;p&gt;
              &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
              title="login interceptor workflow"/&gt;
              &lt;/p&gt;
              &lt;p&gt;
              (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
              possible.)
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
              valid, the workflow is as follows:
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
              &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
              &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
              used. Steps 5 and 6.)&lt;/li&gt;
              &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
              &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
              was directly requested). (Step 8.)&lt;/li&gt;
              &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="sampleSoapService">
</xsd:element>
<xsd:element ref="analyser">
</xsd:element>
<xsd:element ref="validator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlRewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="regExReplacer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="abort" type="com.predic8.membrane.core.config.spring.AbortParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Plugins are usually applied to requests and responses.
 In case of errors, the flow returns and &lt;i&gt;handleAbort()&lt;/i&gt; is called on plugins
 going back the chain.
 By nesting plugins into an &lt;abort&gt; you can limit their application to abort flows only.
 On plugins nested in &lt;abort&gt; handleResponse() is called not handleAbort() in order to
 allow normal processing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiKey">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Secures APIs by validating keys stored in either files or proxies.xml. Keys can be received from clients via HTTP headers or URL query parameters. Additional permission checks are possible through scope validation - scopes are loaded into an Exchange property and can be checked using the "hasScope()" SpEL function.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="oauth2authserver">
</xsd:element>
<xsd:element ref="adminConsole">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="urlNormalizer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Replaces "/./" in the request URI's path by "/".
              &lt;/p&gt;
              &lt;p&gt;
              Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
              links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
              root). The SOA model then combines "&lt;a href="http://foo/material/ArticleService?wsdl"&gt;http://foo/material/ArticleService?wsdl&lt;/a&gt;" and
              "./ArticleService?xsd=1" to "&lt;a href="http://foo/material/./ArticleService?xsd=1"&gt;http://foo/material/./ArticleService?xsd=1&lt;/a&gt;". This URI is sent to Membrane's
              new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
              not match.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ruleMatching">
</xsd:element>
<xsd:element ref="oauth2PermissionChecker">
</xsd:element>
<xsd:element ref="for">
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:complexType name="com.predic8.membrane.core.config.spring.ResponseParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element ref="httpClient">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
 Server using the HTTP protocol. Usually it will be globally used
 inside the transport. However, it is also possible to use it
 inside a proxy to give the proxy an individual configuration for
 its outgoing HTTP connection that is different from the global
 configuration in the transport.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtAuth">
</xsd:element>
<xsd:element ref="interceptor">
</xsd:element>
<xsd:element ref="tcp">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="tokenValidator">
</xsd:element>
<xsd:element ref="beautifier">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Beautifies request and response bodies. Supported are the Formats: JSON, XML&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="static">
</xsd:element>
<xsd:element ref="jsonProtection">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="http2xml">
</xsd:element>
<xsd:element name="echo" type="com.predic8.membrane.core.config.spring.EchoParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Returns the flow of plugins and copies the content of the
 request into a new response. The response has a status code of 200.
 Useful for testing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xml2Json">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If enabled converts body content from xml to json.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Can be used for both request and response. Xml file assumed to be in UTF-8. If input is invalid it returns
 empty json object.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="authHead2Body">
</xsd:element>
<xsd:element ref="webServer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
 "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
 &lt;/p&gt;
 &lt;p&gt;
 The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
 HTTP response with the contents of a file, or a "404 Not Found." error.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="internalRouting">
</xsd:element>
<xsd:element ref="exchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
              might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="dispatching">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
 element to the list of destinations of the exchange object. It
 must be placed into the transport to make Service Proxies Work
 properly. It has to be placed after the ruleMatching
 interceptor. The ruleMatching interceptor looks up a service
 proxy for an incoming request and places it into the exchange
 object. The dispatching interceptor needs the service proxy to
 get information about the target.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shadowing">
</xsd:element>
<xsd:element ref="openapiPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;openapiPublisher&lt;/i&gt; serves OpenAPI documents
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessControl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
              requested resource.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="acmeHttpChallenge">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See the documentation of the &lt;code&gt;&lt;acme /&gt;&lt;/code&gt; element for usage details.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="transform">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transform feature applies an XSLT transformation to the content in the body of a message. After the
              transformation the body content is replaced with the result of the transformation.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Rewrites or redirects the path of incoming requests based on a mapping.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rest2Soap">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xenAuthentication">
</xsd:element>
<xsd:element ref="graphQLProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Check GraphQL-over-HTTP requests, enforcing several limits and/or restrictions. This effectively helps to reduce
 the attack surface.
 &lt;p&gt;
 GraphQL Specification "October2021" is used. (But GraphQL only covers formulation of Documents/Queries.)
 &lt;/p&gt;
 &lt;p&gt;
 GraphQL-over-HTTP, which specifies how to submit GraphQL queries via HTTP, has not been released/finalized yet. We
 therefore use Version
 &lt;a href="https://github.com/graphql/graphql-over-http/blob/a1e6d8ca248c9a19eb59a2eedd988c204909ee3f/spec/GraphQLOverHTTP.md"&gt;a1e6d8ca&lt;/a&gt;.
 &lt;/p&gt;
 &lt;p&gt;
 Only GraphQL documents conforming to the 'ExecutableDocument' of the grammar are allowed: This includes the usual
 'query', 'mutation', 'subscription' and 'fragment's.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapOperationExtractor">
</xsd:element>
<xsd:element ref="balancer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="reverseProxying">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
 as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
 hostnames and ports used to access Membrane  vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clamav">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Delegates virus checks to an external Virus Scanner.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="destination">
</xsd:element>
<xsd:element ref="requireAuth">
</xsd:element>
<xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;request&gt; Element you can limit their application to requests only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="cache">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Don't use, this does NOT implement valid HTTP caching.
              &lt;/p&gt;
              &lt;p&gt;
                  We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                  the Docker Registry for offline use.
                  The cache does not revalidate any responses, so machines querying the cache for Debian
                  package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                  This is - simply put - the only use case, where using this class makes any sense.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsJDBC">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
 database (one row per exchange).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="index">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
              To use this feature just add a serviceProxy containing the index
              element. Of course you can protect the service proxy by using
              SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;wsdlPublisher&lt;/i&gt; serves WSDL files (and attached XML Schema Documents), if your
 backend service does not already do so.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="webServiceExplorer">
</xsd:element>
<xsd:element ref="logContext">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="APIsJSON">
</xsd:element>
<xsd:element ref="flowInitiator">
</xsd:element>
<xsd:element ref="counter">
</xsd:element>
<xsd:element ref="rateLimiter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;rateLimiter&lt;/i&gt; plugin limits the number of requests of a client in a period of time.
 As a default the client requests are grouped by client-Ip address and then counted. There are lots of
 possibilities to group the requests using the keyExpression. The requests can even be counted from different
 clients together.&lt;/p&gt;
 &lt;p&gt;When the gateway is located behind a loadbalancer then
 the client-Ip address is not the one from the client but the address from the balancer. To get the real Ip-address loadbalancers,
 &lt;i&gt;Web Application Firewalls&lt;/i&gt; and reverse proxies set the ip from the original client into the &lt;i&gt;X-Forwarded-For&lt;/i&gt; HTTP
 header field. The limiter plugin can take the Ip-address from the header.&lt;/p&gt;
 &lt;p&gt;
 The X-Forwarded-For header can only be trusted when a trustworthy reverse proxy or load balancer is between the client and server. The gateway not should be
 reachable directly. Only activate this feature when you know what you are doing.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="call">
</xsd:element>
<xsd:element ref="oauth2Resource2">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
 authorization server as response.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="if">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The "if" interceptor supports conditional execution of nested plugins.
 &lt;/p&gt;
 See:
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorSpELTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorGroovyTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorJsonpathTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorXPathTest&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="template">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders the body content of a message from a template. The template can
 produce plain text, Json or XML. Variables in the template are substituted with values from the body,
 header, query parameters, etc. If the extension of a referenced template file is &lt;i&gt;.xml&lt;/i&gt; it will use
 &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_xmltemplateengine"&gt;XMLTemplateEngine&lt;/a&gt;
 otherwise &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_streamingtemplateengine"&gt;StreamingTemplateEngine&lt;/a&gt;.
 Have a look at the samples in &lt;a href="https://github.com/membrane/service-proxy/tree/master/distribution/examples"&gt;examples/template&lt;/a&gt;.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="groovyTemplate">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Uses the groovy template markup engine to produce HTML-based responses.
 &lt;code&gt;
 &lt;groovyTemplate&gt;&lt;![CDATA[
   html {
     head {
       title('Resource')
     }
     body {
       p('Hello from Membrane!')
     }
   }
 ]]&gt;&lt;/groovyTemplate&gt;
 &lt;/code&gt;
 &lt;p&gt;
 The word "spring" refers to the Spring ApplicationContext.
 The word "exc" refers to the Membrane Exchange being handled.
 The word "flow" refers to the current Membrane Flow (=REQUEST).
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessLog">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes exchange metrics into a Log4j appender&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Defaults to Apache Common Log pattern&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="prometheus">
</xsd:element>
<xsd:element ref="wadlRewriter">
</xsd:element>
<xsd:element ref="openTelemetry">
</xsd:element>
<xsd:element ref="limit">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Note that due to the streaming nature of Membrane, a request header may already have been passed on to
              the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
              aborted and the connection to the backend is simply closed.
              &lt;/p&gt;
              &lt;p&gt;
              To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
              &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="basicAuthentication">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="json2Xml">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts body payload from JSON to XML. The JSON must be an object other JSON documents e.g. arrays are not supported.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Resulting XML will be in UTF-8 encoding.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shutdown">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Shutdown interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                  Adds the ability to shutdown main router thread via an HTTP request.
                  Don't forget to setup security for this interceptor.
              &lt;/p&gt;
              &lt;p&gt;
                  Has undefined behavior when Membrane is &lt;b&gt;not&lt;/b&gt; started from command line
                  (=via the RouterCLI class, which &lt;tt&gt;service-proxy.ps1&lt;/tt&gt;/&lt;tt&gt;service-proxy.sh&lt;/tt&gt;
                  do use).
              &lt;/p&gt;
              &lt;p&gt;
                  Only actually terminates the running JVM, when used in the first
                  &lt;tt&gt;&lt;router&gt;&lt;/tt&gt; bean (which implicitly stands for
                  &lt;tt&gt;&lt;router id="router"&gt;&lt;/tt&gt;) called "router".
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="userFeature">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapStackTraceFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
              advised to test its functionality in combination with your SOAP service provider before deploying it in
              production.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="formValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiDocs">
</xsd:element>
<xsd:element ref="choose">
</xsd:element>
<xsd:element ref="testService">
</xsd:element>
<xsd:element ref="soap2Rest">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clusterNotification">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane API Gateway distribution.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setHeader">
</xsd:element>
<xsd:element ref="groovy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Groovy script. The script can access and manipulate data from the request and response.
 Use this or the Javascript plugin to extend the functions of Membrane by scripting.
 See: example/groovy for working samples&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtSign">
</xsd:element>
<xsd:element ref="statisticsProvider">
</xsd:element>
<xsd:element ref="replace">
</xsd:element>
<xsd:element ref="methodOverride">
</xsd:element>
<xsd:element ref="stompClient">
</xsd:element>
<xsd:element ref="webSocket">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
 attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="log">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages. The messages will appear either on the console or in
 a log file depending on the log configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="return">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Terminates the exchange flow. The returned response is determined in the following order:
 &lt;p&gt;
 1. If there is already a response in the exchange, that response is returned
 2. If there is no response in the exchange, the body and contentType of the request is copied into a new response.
 &lt;/p&gt;
 &lt;p&gt;
 The options statusCode and contentType will overwrite the values from the messages.
 &lt;/p&gt;
 &lt;p&gt;
 This plugin is useful together with the template plugin. See examples/template.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsCSV">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
              file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="openapiValidator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Validator for OpenAPI documents&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accountRegistration">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="kubernetesValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Kubernetes Integration is still experimental.
 &lt;p&gt;
 To create the CustomResourceDefinitions, apply kubernetes-config.yaml from
 core/target/classes/com/predic8/membrane/core/config/kubernetes/ or a part (e.g. the 'serviceproxies' CRD) of the file.
 &lt;/p&gt;
 &lt;p&gt;
 Create a key and certificate for TLS for &lt;a href="https://membrane-validator.membrane-soa.svc:444/"&gt;https://membrane-validator.membrane-soa.svc:444/&lt;/a&gt; and setup Membrane to serve
 this address. The configuration shown below configures Membrane on a fixed IP address outside of the Kubernetes cluster,
 but this is no requirement.
 &lt;/p&gt;
 &lt;p&gt;
 Embed the following serviceProxy and adjust the 'resources' attribute to a comma-separated list of CRDs that you applied.
 Note that while the CRDs have plural names, here you need to use the corresponding singular. Configure the "ssl" section
 using your key and certificate.
 &lt;/p&gt;
 &lt;code&gt;
 &gt;serviceProxy port="444"&gt;
 &gt;ssl&gt;
 &gt;key&gt;
 &gt;private&gt;
 -----BEGIN RSA PRIVATE KEY-----
 ...
 -----END RSA PRIVATE KEY-----
 &gt;/private&gt;
 &gt;certificate&gt;
 -----BEGIN CERTIFICATE-----
 ...
 -----END CERTIFICATE-----
 &gt;/certificate&gt;
 &gt;/key&gt;
 &gt;/ssl&gt;
 &gt;kubernetesValidation resources="serviceproxy" /&gt;
 &gt;/serviceProxy&gt;
 &lt;/code&gt;
 &lt;p&gt;
 Now register a Webhook to validate the new CRDs. (A note to the experts: Membrane's validation schemas are too
 complex to fit into the CRD, because they are highly nestable and self-referencing. We therefore use webhooks.)
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: admissionregistration.k8s.io/v1
 kind: ValidatingWebhookConfiguration
 metadata:
 name: membrane
 webhooks:
 - name: membrane.membrane-soa.org
 admissionReviewVersions: ["v1", "v1beta1"]
 failurePolicy: Fail
 rules:
 - operations: [ "*" ]
 apiGroups: [ "membrane-soa.org" ]
 apiVersions: [ "v1", "v1beta1" ]
 resources: [ "*" ]
 scope: "*"
 clientConfig:
 service:
 name: membrane-validator
 namespace: membrane-soa
 port: 444
 caBundle: LS0t...LQ0K        # base64 encoded, PEM-formatted CA certificate
 sideEffects: None
 ---
 apiVersion: v1
 kind: Namespace
 metadata:
 name: membrane-soa
 ---
 apiVersion: v1
 kind: Service
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 spec:
 ports:
 - port: 444
 ---
 apiVersion: v1
 kind: Endpoints
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 subsets:
 - addresses:
 - ip: 192.168.0.1   # Membrane's IP
 ports:
 - port: 444
 &lt;/code&gt;
 &lt;p&gt;
 Once this setup is complete, you can enable serviceProxies like this:
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: membrane-soa.org/v1beta1
 kind: serviceproxy
 metadata:
 name: demo
 namespace: membrane-soa
 spec:
 host: demo.predic8.de
 path:
 value: /some-path/
 interceptors:
 - response:
 interceptors:
 - groovy:
 src: |
 println "Hello!"
 target:
 host: thomas-bayer.com
 &lt;/code&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setProperty">
</xsd:element>
<xsd:element ref="javascript">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Javascript. The script can access and manipulate data from the request and response.
 Use this or the Groovy plugin to extend the functions of Membrane by scripting. See the samples in examples/javascript.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="paddingHeader">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="greaser">
</xsd:element>
<xsd:element ref="soapBody">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders a SOAP body for legacy intergration&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;response&gt; plugin you can limit their application to responses only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="throttle">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The throttle feature can slow down traffic to thwart denial of service attacks.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlContentFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
 using an XPath expression.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
 match a message at all. This can improve performance significantly, as a DOM tree does probably not have
 to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
 lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
 namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
 &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
 the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
 constructed.
 &lt;/p&gt;
 &lt;p&gt;
 If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
 XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
 modified reconstituted message.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="headerFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
 The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ntlm">
</xsd:element>
<xsd:element ref="login">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
              application.
              &lt;/p&gt;
              &lt;p&gt;
              Users firstly have to authenticate themselves against a directory server using a username and password.
              Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
              token verification, access to the web application is granted for the user's session. Single Sign On can
              easily be realized using a small source code extension or modification of a web application.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
              each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
              default implementations.)
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
              cell phone number, Single Sign On data, etc.).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
              session cookie).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
              attempts for a specified amount of time.
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
              secondary channel like text messaging).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;/ul&gt;
              &lt;p&gt;
              &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
              title="login interceptor workflow"/&gt;
              &lt;/p&gt;
              &lt;p&gt;
              (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
              possible.)
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
              valid, the workflow is as follows:
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
              &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
              &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
              used. Steps 5 and 6.)&lt;/li&gt;
              &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
              &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
              was directly requested). (Step 8.)&lt;/li&gt;
              &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="sampleSoapService">
</xsd:element>
<xsd:element ref="analyser">
</xsd:element>
<xsd:element ref="validator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlRewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="regExReplacer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="abort" type="com.predic8.membrane.core.config.spring.AbortParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Plugins are usually applied to requests and responses.
 In case of errors, the flow returns and &lt;i&gt;handleAbort()&lt;/i&gt; is called on plugins
 going back the chain.
 By nesting plugins into an &lt;abort&gt; you can limit their application to abort flows only.
 On plugins nested in &lt;abort&gt; handleResponse() is called not handleAbort() in order to
 allow normal processing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiKey">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Secures APIs by validating keys stored in either files or proxies.xml. Keys can be received from clients via HTTP headers or URL query parameters. Additional permission checks are possible through scope validation - scopes are loaded into an Exchange property and can be checked using the "hasScope()" SpEL function.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="oauth2authserver">
</xsd:element>
<xsd:element ref="adminConsole">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="urlNormalizer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Replaces "/./" in the request URI's path by "/".
              &lt;/p&gt;
              &lt;p&gt;
              Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
              links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
              root). The SOA model then combines "&lt;a href="http://foo/material/ArticleService?wsdl"&gt;http://foo/material/ArticleService?wsdl&lt;/a&gt;" and
              "./ArticleService?xsd=1" to "&lt;a href="http://foo/material/./ArticleService?xsd=1"&gt;http://foo/material/./ArticleService?xsd=1&lt;/a&gt;". This URI is sent to Membrane's
              new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
              not match.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ruleMatching">
</xsd:element>
<xsd:element ref="oauth2PermissionChecker">
</xsd:element>
<xsd:element ref="for">
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="throttle">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The throttle feature can slow down traffic to thwart denial of service attacks.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="delay" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If non-zero, delays requests by specified number of milliseconds.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 1000&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 0&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="maxThreads" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If non-zero, newly incoming request are aborted if the number of running requests has reached this limit.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 5&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 0&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="busyDelay" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If a newly incoming request exceeds maxThreads, the interceptor waits the specified number in
              milliseconds and retries once before aborting the request.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 3000&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 0&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="redisOriginalExchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Used for storing exchanges temporarily in Redis. Supports authentication with or without password and username&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="maxBodySize" type="spel_number" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limit for max body size. Exchanges will be truncated to max body size if they are bigger. Used unit is bytes.
 Default value is 100000.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="connector" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="jwtSessionManager">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element name="jwk" type="com.predic8.membrane.core.config.spring.JwtSessionManagerjwkParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="expiresAfterSeconds" type="spel_number" >
</xsd:attribute>
<xsd:attribute name="domain" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="httpOnly" type="spel_boolean" >
</xsd:attribute>
<xsd:attribute name="sameSite" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="issuer" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="ttlExpiryRefreshOnAccess" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; controls if the expiry refreshes to expiresAfterSeconds on access (true) or if it should not refresh (false)&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="secure" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; forces secure cookie attribute even when no ssl context is present (e.g. TLS termination in front of membrane)&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="sessionCookie" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; if true removes the expire part of a set cookie header and thus makes it a session cookie&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="verbose" type="spel_boolean" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="xmlContentFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
 using an XPath expression.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
 match a message at all. This can improve performance significantly, as a DOM tree does probably not have
 to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
 lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
 namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
 &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
 the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
 constructed.
 &lt;/p&gt;
 &lt;p&gt;
 If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
 XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
 modified reconstituted message.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="xPath" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; An XPath 1.0 expression describing the elements to be removed from message bodies.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="headerFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
 The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="1" maxOccurs="unbounded">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; List of actions to take (either allowing or removing HTTP headers).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element ref="include">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Contains a Java regex for &lt;i&gt;including&lt;/i&gt; message headers.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="exclude">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Contains a Java regex for &lt;i&gt;excluding&lt;/i&gt; message headers.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="key">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Experimental.
 &lt;p&gt;Allows to insert a PEM block containing the key (as well as one or more blocks for the
 certificate(s)) directly into the proxies.xml file.&lt;/p&gt;
 &lt;p&gt;This is an alternative for {@link KeyStore}.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="1">
<xsd:element ref="private">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="1" maxOccurs="unbounded">
<xsd:element ref="certificate">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="password" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="cookieOriginalExchangeStore">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="ntlm">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element name="headerRetriever" type="com.predic8.membrane.core.config.spring.HeaderRetrieverParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="user" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="pass" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="domain" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="workstation" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="login">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
              application.
              &lt;/p&gt;
              &lt;p&gt;
              Users firstly have to authenticate themselves against a directory server using a username and password.
              Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
              token verification, access to the web application is granted for the user's session. Single Sign On can
              easily be realized using a small source code extension or modification of a web application.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
              each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
              default implementations.)
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
              cell phone number, Single Sign On data, etc.).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
              session cookie).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
              attempts for a specified amount of time.
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
              secondary channel like text messaging).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;/ul&gt;
              &lt;p&gt;
              &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
              title="login interceptor workflow"/&gt;
              &lt;/p&gt;
              &lt;p&gt;
              (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
              possible.)
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
              valid, the workflow is as follows:
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
              &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
              &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
              used. Steps 5 and 6.)&lt;/li&gt;
              &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
              &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
              was directly requested). (Step 8.)&lt;/li&gt;
              &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="1">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;user data provider&lt;/i&gt; verifying a combination of a username with a password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element ref="staticUserDataProvider">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; listing all user data in-place in the config file.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              the &lt;i&gt;staticuserdataprovider&lt;/i&gt; can be used to statically list user data within the config file.
              &lt;/p&gt;
              &lt;p&gt;
              each user must have a unique &lt;i&gt;username&lt;/i&gt; attribute as well as a &lt;i&gt;password&lt;/i&gt; attribute.
              &lt;/p&gt;
              &lt;p&gt;
              arbitrary attributes can be set on a user element. other sub-components of the &lt;i&gt;login&lt;/i&gt; interceptor
              might use those: for example, the &lt;i&gt;telekomsmstokenprovider&lt;/i&gt; uses the &lt;i&gt;sms&lt;/i&gt; property as the
              user's cell phone number. for example, the &lt;i&gt;totptokenprovider&lt;/i&gt; uses the &lt;i&gt;secret&lt;/i&gt; property to
              initialize the token sequence.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jdbcUserDataProvider">
</xsd:element>
<xsd:element name="ldapUserDataProvider" type="com.predic8.membrane.core.config.spring.LdapUserDataProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; querying an LDAP server to authorize users and retrieve attributes.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The LDAP User Data Provider performs two jobs:
              &lt;ol&gt;
              &lt;li&gt;Authentication of a &lt;i&gt;username&lt;/i&gt; and &lt;i&gt;password&lt;/i&gt;.&lt;/li&gt;
              &lt;li&gt;Retrieval of user attributes.&lt;/li&gt;
              &lt;/ol&gt;
              &lt;/p&gt;
              &lt;p&gt;
              To achieve this, it first binds to &lt;i&gt;base&lt;/i&gt; on the LDAP server &lt;i&gt;url&lt;/i&gt;. If &lt;i&gt;binddn&lt;/i&gt; is not
              present, it binds to the LDAP server anonymously, elsewise &lt;i&gt;binddn&lt;/i&gt; and &lt;i&gt;bindpw&lt;/i&gt; are used for
              authentication.
              &lt;/p&gt;
              &lt;p&gt;
              Next, a search &lt;i&gt;searchPattern&lt;/i&gt; with scope &lt;i&gt;searchScope&lt;/i&gt; is executed where "&lt;tt&gt;%LOGIN%&lt;/tt&gt;"
              is replaced by the escaped version of the &lt;i&gt;username&lt;/i&gt;.
              &lt;/p&gt;
              &lt;p&gt;
              The search returning no node or more than one node is treated as failure.
              &lt;/p&gt;
              &lt;p&gt;
              If &lt;i&gt;passwordAttribute&lt;/i&gt; is set, and the node has an attribute with this name and this attribute's
              value starts with "&lt;tt&gt;{x-plain}&lt;/tt&gt;", the password is checked against the rest of the value for
              equality. If &lt;i&gt;passwordAttribute&lt;/i&gt; is not set, a second binding is attempted on the node using the
              &lt;i&gt;password&lt;/i&gt; the user provided.
              &lt;/p&gt;
              &lt;p&gt;
              The user attribute keys specified in the mapping are then renamed according to the mapping and used for
              further processing (see the other modules of the &lt;i&gt;login&lt;/i&gt; interceptor).
              &lt;/p&gt;
              &lt;p&gt;
              &lt;/p&gt;
              &lt;p&gt;
              For the initial binding, &lt;i&gt;connectTimeout&lt;/i&gt; can be used to specify a timeout in milliseconds. For the
              search, &lt;i&gt;timeout&lt;/i&gt; can be used.
              &lt;/p&gt;
              &lt;p&gt;
              If &lt;i&gt;readAttributesAsSelf&lt;/i&gt; is not set, the user attributes are collected from the search result. If
              it is set, an additional request is made after the second successful binding to retrieve the node's
              attributes.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="fileUserDataProvider">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; utilizing htpasswd formatted files.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              the &lt;i&gt;fileuserdataprovider&lt;/i&gt; can be used to source authentication data from htpasswd files.
              &lt;/p&gt;
              &lt;p&gt;
              The files can only utilize algorithm magic strings supported by &lt;i&gt;crypt(3)&lt;/i&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="cachingUserDataProvider" type="com.predic8.membrane.core.config.spring.CachingUserDataProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Caching User Data provider caches previous successful logins in order to make authentication faster&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="customStatementJdbcUserDataProvider">
</xsd:element>
<xsd:element name="unifyingUserDataProvider" type="com.predic8.membrane.core.config.spring.UnifyingUserDataProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;unifyingUserDataProvider&lt;/i&gt; can be used to merge two or more other &lt;i&gt;user data providers&lt;/i&gt;
              into one.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;unifyingUserDataProvider&lt;/i&gt; will forward a login attempt (username and password) to each inner
              user data provider in the order they are specified. After one of the inner user data providers returned
              a successful login (and returned the user's attributes), the procedure terminates. If no inner user data
              provider could verify the user, the login attempt fails.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;sessionManager&lt;/i&gt;. (Default values will be used, if the element is not specified.)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element name="sessionManager" type="com.predic8.membrane.core.config.spring.SessionManagerParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The Session Manager identifies users across HTTP requests using a session cookie.
              &lt;/p&gt;
              &lt;p&gt;
              The name of the session cookie can be specified using the &lt;i&gt;cookieName&lt;/i&gt; attribute. The default name
              is "&lt;tt&gt;SESSIONID&lt;/tt&gt;".
              &lt;/p&gt;
              &lt;p&gt;
              The session timeout can be specified in milliseconds using the &lt;i&gt;timeout&lt;/i&gt; attribute. The default
              timeout is 5 minutes.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;accountBlocker&lt;/i&gt;. (Default values will be used, if the element is not specified.)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element ref="accountBlocker">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Keeps track of blocked user accounts (accounts become blocked after too many failed logins).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The Account Blocker prevents password and token guessing attempts: It blocks a user (or the whole
              system) after too many failed login attempts.
              &lt;/p&gt;
              &lt;p&gt;
              When a user entered a wrong password or wrong token more than &lt;i&gt;afterFailedLogins&lt;/i&gt; times, this user
              becomes blocked: He will be prevented from logging in again within the next &lt;i&gt;blockFor&lt;/i&gt; milliseconds
              (writing 3600000 means "for 1 hour").
              &lt;/p&gt;
              &lt;p&gt;
              The failed login attempts have to occur within the last &lt;i&gt;afterFailedLoginsWithin&lt;/i&gt; milliseconds
              (writing 9223372036854775807 means "forever").
              &lt;/p&gt;
              &lt;p&gt;
              If more than &lt;i&gt;blockWholeSystemAfter&lt;/i&gt; users become blocked at a time, the &lt;i&gt;all&lt;/i&gt; users will
              become blocked. (This is necessary to limit memory usage.)
              &lt;/p&gt;
              &lt;h3&gt;Discussion&lt;/h3&gt;
              &lt;p&gt;
              Say, for example, a scripted dictionary attack tries to guess a user's password. Using the configuration
              shown above, which is the default configuration if no &lt;i&gt;accountBlocker&lt;/i&gt; is declared, this results in
              5 guesses per 3600000 milliseconds; or equivalently 42720 guesses per year.
              &lt;/p&gt;
              &lt;p&gt;
              The probability of hitting a uniformly at random chosen word of the standard German vocabulary within
              one year is therefore about 56%.
              &lt;/p&gt;
              &lt;p&gt;
              Therefore, a more secure password should be chosen, containing letters, digits and special characters.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;token provider&lt;/i&gt; computing or generating a numeric value used for &lt;a
              href="http://en.wikipedia.org/wiki/Two_Factor_Authentication"&gt;two-factor authentication&lt;/a&gt;.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element name="emailTokenProvider" type="com.predic8.membrane.core.config.spring.EmailTokenProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;emailTokenProvider&lt;/i&gt; randomly generates a 6-digit token after the user entered her correct
              password.
              &lt;/p&gt;
              &lt;p&gt;
              The token is then sent to the user via email. The user's attribute &lt;i&gt;email&lt;/i&gt; is used as the
              recipient email address. If this attribute has not been provided by the &lt;i&gt;user data provider&lt;/i&gt;, the
              login attempt fails.
              &lt;/p&gt;
              &lt;p&gt;
              The email is sent using the SMTP protocol via the &lt;i&gt;smtpHost&lt;/i&gt;. Optionally, &lt;i&gt;ssl&lt;/i&gt; and &lt;i&gt;smptPort&lt;/i&gt; can
              be set to configure the type of connection. Optionally, &lt;i&gt;smtpUser&lt;/i&gt; and &lt;i&gt;smtpPassword&lt;/i&gt; can be used to
              use sender authentification.
              &lt;/p&gt;
              &lt;p&gt;
              The email is assembled using &lt;i&gt;sender&lt;/i&gt;, &lt;i&gt;recipient&lt;/i&gt;, &lt;i&gt;subject&lt;/i&gt; and &lt;i&gt;body&lt;/i&gt;. All of these values
              may contain properties in the form of &lt;tt&gt;${propertyname}&lt;/tt&gt;.
              &lt;/p&gt;
              &lt;p&gt;
              The properties will be replaced by the corresponding user attributes set by the &lt;i&gt;user data provider&lt;/i&gt;, or &lt;tt&gt;token&lt;/tt&gt;
              will be replaced by the numeric token value.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;token provider&lt;/i&gt; sending a randomly generated numeric token
              to the user via email.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="whateverMobileSMSTokenProvider" type="com.predic8.membrane.core.config.spring.WhateverMobileSMSTokenProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;whateverMobileSMSTokenProvider&lt;/i&gt; randomly generates a
              6-digit token after the user entered her correct password.
              &lt;/p&gt;
              &lt;p&gt;
              The token is then sent to the user via text message. The user's
              attribute &lt;i&gt;sms&lt;/i&gt; is used as the recipient phone number. If
              this attribute has not been provided by the &lt;i&gt;user data
              provider&lt;/i&gt;, the login attempt fails.
              &lt;/p&gt;
              &lt;p&gt;
              The text message is sent via &lt;a
              href="https://whatevermobile.com/"&gt;WhateverMobile&lt;/a&gt; REST API.
              To use this API, a registered user account with sufficient
              balance is necessary. Membrane uses the specified user name and
              password to identify itself when connecting to the
              WhateverMobile SMS Gateway.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;token provider&lt;/i&gt; using &lt;i&gt;&lt;a
              href="https://whatevermobile.com/"&gt;WhateverMobile&lt;/a&gt;'s&lt;/i&gt; REST
              interface to send a randomly generated numeric token to the
              user's phone via text message.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="emptyTokenProvider" type="com.predic8.membrane.core.config.spring.EmptyTokenProviderParser">
</xsd:element>
<xsd:element name="telekomSMSTokenProvider" type="com.predic8.membrane.core.config.spring.TelekomSMSTokenProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; randomly generates a 6-digit token after the user entered her correct
              password.
              &lt;/p&gt;
              &lt;p&gt;
              The token is then sent to the user via text message. The user's attribute &lt;i&gt;sms&lt;/i&gt; is used as the
              recipient phone number. If this attribute has not been provided by the &lt;i&gt;user data provider&lt;/i&gt;, the
              login attempt fails.
              &lt;/p&gt;
              &lt;p&gt;
              The text message is sent via &lt;a href="http://www.developergarden.com/"&gt;Deutsche Telekom's developer
              garden&lt;/a&gt; REST API. To use this API, a registered user account with sufficient balance is necessary and
              the &lt;i&gt;Send SMS&lt;/i&gt; API has to be enabled for this account. Membrane API Gateway must be registered as an
              "application" on the developer garden website, and the "Global SMS API" must be enabled both for the user account
              as well as the registered application. Once completed, the &lt;i&gt;scope&lt;/i&gt;, &lt;i&gt;clientId&lt;/i&gt; and &lt;i&gt;clientSecret&lt;/i&gt;
              settings must be copied from the website into Membrane's proxies.xml configuration file. Membrane uses these three
              parameters to identify itself when connecting to the Telekom API Gateway.
              &lt;/p&gt;
              &lt;p&gt;
              When using a non-standard &lt;i&gt;environment&lt;/i&gt; (see https://www.developergarden.com/apis/documentation/bundle/telekom-api-rest/html/sendsms.html#environmental_infos for more information),
              the parameters &lt;i&gt;senderName&lt;/i&gt; and &lt;i&gt;senderAddress&lt;/i&gt; may be used to set the SMS sender address and name.
              &lt;/p&gt;
              &lt;p&gt;
              The token is prepended by &lt;i&gt;prefixText&lt;/i&gt; to generate the text message's text.
              &lt;/p&gt;
              &lt;p&gt;
              If &lt;i&gt;normalizeTelephoneNumber&lt;/i&gt; is set, the user's &lt;i&gt;sms&lt;/i&gt; attribute will be normalized according
              to the following rules before using it:
              &lt;ul&gt;
              &lt;li&gt;'&lt;tt&gt;+&lt;/tt&gt;' is replaced by '&lt;tt&gt;00&lt;/tt&gt;'.&lt;/li&gt;
              &lt;li&gt;Any characters within round brackets, '&lt;tt&gt;(&lt;/tt&gt;' and '&lt;tt&gt;)&lt;/tt&gt;', are removed.&lt;/li&gt;
              &lt;li&gt;'&lt;tt&gt;-&lt;/tt&gt;' and '&lt;tt&gt;&#160;&lt;/tt&gt;' are removed.&lt;/li&gt;
              &lt;/ul&gt;
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;token provider&lt;/i&gt; using &lt;i&gt;Deutsche Telekom's&lt;/i&gt; REST interface &lt;a
              href="http://www.developergarden.com/"&gt;developer garden&lt;/a&gt; to send a randomly generated numeric token
              to the user via text message.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="totpTokenProvider" type="com.predic8.membrane.core.config.spring.TotpTokenProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;token provider&lt;/i&gt; using the Time-based One-time Password (TOTP) algorithm specified in RFC 6238 to
              verify tokens using a pre-shared secret.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;totpTokenProvider&lt;/i&gt; uses the Time-based One-time Password (TOTP) algorithm specified in &lt;a
              href="http://tools.ietf.org/html/rfc6238"&gt;RFC 6238&lt;/a&gt; to verify tokens using a pre-shared secret.
              &lt;/p&gt;
              &lt;p&gt;
              The tokens consist of 6 digits.
              &lt;/p&gt;
              &lt;p&gt;
              The user's attribute &lt;i&gt;secret&lt;/i&gt; is used as the pre-shared secret. If this attribute is missing, the
              login attempt fails.
              &lt;/p&gt;
              &lt;p&gt;
              Note that the server's system time is taken into account when verifying tokens.
              &lt;/p&gt;
              &lt;p&gt;
              It is possible, for example, to use the &lt;a href="http://code.google.com/p/google-authenticator"&gt;Google
              Authenticator App&lt;/a&gt; to store the pre-shared secret and generate such tokens.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="location" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; location of the login dialog template (a directory containing the &lt;i&gt;index.html&lt;/i&gt; file as well as possibly other resources)
 See &lt;a href="https://www.membrane-soa.org/service-proxy-doc/current/configuration/location.htm"&gt;here&lt;/a&gt; for a description of the format.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; file:c:/work/login/&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="path" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; context path of the login dialog&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; /login/&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="exposeUserCredentialsToSession" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Whether the user's credentials should be copied over to the session. This means they
 will stay in memory and will be available to all Membrane components.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="message" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Set the message displayed during redirect.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="sampleSoapService">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="sessionOriginalExchangeStore">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="maxBodySize" type="spel_number" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="analyser">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.ScopeParser">
<xsd:complexContent mixed="true">
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/></xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="validator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="wsdl" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The WSDL (URL or file) to validate against.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; &lt;a href="http://predic8.com:8080/material/ArticleService?wsdl"&gt;"http://predic8.com:8080/material/ArticleService?wsdl&lt;/a&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="schema" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The XSD Schema (URL or file) to validate against.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; &lt;a href="http://www.predic8.com/schemas/order.xsd"&gt;http://www.predic8.com/schemas/order.xsd&lt;/a&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="failureHandler" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If "response", the HTTP response will include a detailled error message. If "log", the response will
 be generic and the validation error will be logged.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; log&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; response&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="jsonSchema" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The JSON Schema (URL or file) to validate against.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; examples/validation/json-schema/schema2000.json&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="schematron" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The Schematron schema (URL or file) to validate against.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; examples/validation/schematron/car-schematron.xml&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="skipFaults" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Whether to skip validation for SOAP fault messages.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="serviceName" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Optional name of a serivce element in a WSDL. If specified it will be
 checked if the SOAP element is possible for that service.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="wsdlRewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="registryWSDLRegisterURL" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="protocol" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The protocol the endpoint should be changed to.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; http&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; Don't change the endpoint's protocol.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="host" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The host the endpoint should be changed to.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; localhost&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; Don't change the endpoint's host.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="port" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The port the endpoint should be changed to.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 4000&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; Don't change the endpoint's port.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.SessionManagerParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="cookieName" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="timeout" type="spel_number" >
</xsd:attribute>
<xsd:attribute name="domain" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:complexType name="com.predic8.membrane.core.config.spring.EmptyTokenProviderParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="scopeTable">
<xsd:complexType>
<xsd:complexContent mixed="true">
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/></xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="regExReplacer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="regex" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Regex to match against the body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; Hallo&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="replace" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; String used to replace matched parts.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; Hello&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="target" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Whether the replacement should affect the message &lt;tt&gt;body&lt;/tt&gt; or the &lt;tt&gt;header&lt;/tt&gt; values.
 Possible values are body and header.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; header&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; body&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.AbortParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element ref="httpClient">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
 Server using the HTTP protocol. Usually it will be globally used
 inside the transport. However, it is also possible to use it
 inside a proxy to give the proxy an individual configuration for
 its outgoing HTTP connection that is different from the global
 configuration in the transport.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtAuth">
</xsd:element>
<xsd:element ref="interceptor">
</xsd:element>
<xsd:element ref="tcp">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="tokenValidator">
</xsd:element>
<xsd:element ref="beautifier">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Beautifies request and response bodies. Supported are the Formats: JSON, XML&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="static">
</xsd:element>
<xsd:element ref="jsonProtection">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="http2xml">
</xsd:element>
<xsd:element name="echo" type="com.predic8.membrane.core.config.spring.EchoParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Returns the flow of plugins and copies the content of the
 request into a new response. The response has a status code of 200.
 Useful for testing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xml2Json">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If enabled converts body content from xml to json.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Can be used for both request and response. Xml file assumed to be in UTF-8. If input is invalid it returns
 empty json object.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="authHead2Body">
</xsd:element>
<xsd:element ref="webServer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
 "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
 &lt;/p&gt;
 &lt;p&gt;
 The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
 HTTP response with the contents of a file, or a "404 Not Found." error.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="internalRouting">
</xsd:element>
<xsd:element ref="exchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
              might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="dispatching">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
 element to the list of destinations of the exchange object. It
 must be placed into the transport to make Service Proxies Work
 properly. It has to be placed after the ruleMatching
 interceptor. The ruleMatching interceptor looks up a service
 proxy for an incoming request and places it into the exchange
 object. The dispatching interceptor needs the service proxy to
 get information about the target.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shadowing">
</xsd:element>
<xsd:element ref="openapiPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;openapiPublisher&lt;/i&gt; serves OpenAPI documents
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessControl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
              requested resource.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="acmeHttpChallenge">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See the documentation of the &lt;code&gt;&lt;acme /&gt;&lt;/code&gt; element for usage details.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="transform">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transform feature applies an XSLT transformation to the content in the body of a message. After the
              transformation the body content is replaced with the result of the transformation.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Rewrites or redirects the path of incoming requests based on a mapping.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rest2Soap">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xenAuthentication">
</xsd:element>
<xsd:element ref="graphQLProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Check GraphQL-over-HTTP requests, enforcing several limits and/or restrictions. This effectively helps to reduce
 the attack surface.
 &lt;p&gt;
 GraphQL Specification "October2021" is used. (But GraphQL only covers formulation of Documents/Queries.)
 &lt;/p&gt;
 &lt;p&gt;
 GraphQL-over-HTTP, which specifies how to submit GraphQL queries via HTTP, has not been released/finalized yet. We
 therefore use Version
 &lt;a href="https://github.com/graphql/graphql-over-http/blob/a1e6d8ca248c9a19eb59a2eedd988c204909ee3f/spec/GraphQLOverHTTP.md"&gt;a1e6d8ca&lt;/a&gt;.
 &lt;/p&gt;
 &lt;p&gt;
 Only GraphQL documents conforming to the 'ExecutableDocument' of the grammar are allowed: This includes the usual
 'query', 'mutation', 'subscription' and 'fragment's.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapOperationExtractor">
</xsd:element>
<xsd:element ref="balancer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="reverseProxying">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
 as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
 hostnames and ports used to access Membrane  vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clamav">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Delegates virus checks to an external Virus Scanner.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="destination">
</xsd:element>
<xsd:element ref="requireAuth">
</xsd:element>
<xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;request&gt; Element you can limit their application to requests only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="cache">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Don't use, this does NOT implement valid HTTP caching.
              &lt;/p&gt;
              &lt;p&gt;
                  We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                  the Docker Registry for offline use.
                  The cache does not revalidate any responses, so machines querying the cache for Debian
                  package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                  This is - simply put - the only use case, where using this class makes any sense.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsJDBC">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
 database (one row per exchange).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="index">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
              To use this feature just add a serviceProxy containing the index
              element. Of course you can protect the service proxy by using
              SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;wsdlPublisher&lt;/i&gt; serves WSDL files (and attached XML Schema Documents), if your
 backend service does not already do so.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="webServiceExplorer">
</xsd:element>
<xsd:element ref="logContext">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="APIsJSON">
</xsd:element>
<xsd:element ref="flowInitiator">
</xsd:element>
<xsd:element ref="counter">
</xsd:element>
<xsd:element ref="rateLimiter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;rateLimiter&lt;/i&gt; plugin limits the number of requests of a client in a period of time.
 As a default the client requests are grouped by client-Ip address and then counted. There are lots of
 possibilities to group the requests using the keyExpression. The requests can even be counted from different
 clients together.&lt;/p&gt;
 &lt;p&gt;When the gateway is located behind a loadbalancer then
 the client-Ip address is not the one from the client but the address from the balancer. To get the real Ip-address loadbalancers,
 &lt;i&gt;Web Application Firewalls&lt;/i&gt; and reverse proxies set the ip from the original client into the &lt;i&gt;X-Forwarded-For&lt;/i&gt; HTTP
 header field. The limiter plugin can take the Ip-address from the header.&lt;/p&gt;
 &lt;p&gt;
 The X-Forwarded-For header can only be trusted when a trustworthy reverse proxy or load balancer is between the client and server. The gateway not should be
 reachable directly. Only activate this feature when you know what you are doing.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="call">
</xsd:element>
<xsd:element ref="oauth2Resource2">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
 authorization server as response.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="if">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The "if" interceptor supports conditional execution of nested plugins.
 &lt;/p&gt;
 See:
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorSpELTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorGroovyTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorJsonpathTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorXPathTest&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="template">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders the body content of a message from a template. The template can
 produce plain text, Json or XML. Variables in the template are substituted with values from the body,
 header, query parameters, etc. If the extension of a referenced template file is &lt;i&gt;.xml&lt;/i&gt; it will use
 &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_xmltemplateengine"&gt;XMLTemplateEngine&lt;/a&gt;
 otherwise &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_streamingtemplateengine"&gt;StreamingTemplateEngine&lt;/a&gt;.
 Have a look at the samples in &lt;a href="https://github.com/membrane/service-proxy/tree/master/distribution/examples"&gt;examples/template&lt;/a&gt;.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="groovyTemplate">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Uses the groovy template markup engine to produce HTML-based responses.
 &lt;code&gt;
 &lt;groovyTemplate&gt;&lt;![CDATA[
   html {
     head {
       title('Resource')
     }
     body {
       p('Hello from Membrane!')
     }
   }
 ]]&gt;&lt;/groovyTemplate&gt;
 &lt;/code&gt;
 &lt;p&gt;
 The word "spring" refers to the Spring ApplicationContext.
 The word "exc" refers to the Membrane Exchange being handled.
 The word "flow" refers to the current Membrane Flow (=REQUEST).
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessLog">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes exchange metrics into a Log4j appender&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Defaults to Apache Common Log pattern&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="prometheus">
</xsd:element>
<xsd:element ref="wadlRewriter">
</xsd:element>
<xsd:element ref="openTelemetry">
</xsd:element>
<xsd:element ref="limit">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Note that due to the streaming nature of Membrane, a request header may already have been passed on to
              the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
              aborted and the connection to the backend is simply closed.
              &lt;/p&gt;
              &lt;p&gt;
              To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
              &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="basicAuthentication">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="json2Xml">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts body payload from JSON to XML. The JSON must be an object other JSON documents e.g. arrays are not supported.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Resulting XML will be in UTF-8 encoding.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shutdown">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Shutdown interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                  Adds the ability to shutdown main router thread via an HTTP request.
                  Don't forget to setup security for this interceptor.
              &lt;/p&gt;
              &lt;p&gt;
                  Has undefined behavior when Membrane is &lt;b&gt;not&lt;/b&gt; started from command line
                  (=via the RouterCLI class, which &lt;tt&gt;service-proxy.ps1&lt;/tt&gt;/&lt;tt&gt;service-proxy.sh&lt;/tt&gt;
                  do use).
              &lt;/p&gt;
              &lt;p&gt;
                  Only actually terminates the running JVM, when used in the first
                  &lt;tt&gt;&lt;router&gt;&lt;/tt&gt; bean (which implicitly stands for
                  &lt;tt&gt;&lt;router id="router"&gt;&lt;/tt&gt;) called "router".
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="userFeature">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapStackTraceFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
              advised to test its functionality in combination with your SOAP service provider before deploying it in
              production.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="formValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiDocs">
</xsd:element>
<xsd:element ref="choose">
</xsd:element>
<xsd:element ref="testService">
</xsd:element>
<xsd:element ref="soap2Rest">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clusterNotification">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane API Gateway distribution.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setHeader">
</xsd:element>
<xsd:element ref="groovy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Groovy script. The script can access and manipulate data from the request and response.
 Use this or the Javascript plugin to extend the functions of Membrane by scripting.
 See: example/groovy for working samples&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtSign">
</xsd:element>
<xsd:element ref="statisticsProvider">
</xsd:element>
<xsd:element ref="replace">
</xsd:element>
<xsd:element ref="methodOverride">
</xsd:element>
<xsd:element ref="stompClient">
</xsd:element>
<xsd:element ref="webSocket">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
 attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="log">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages. The messages will appear either on the console or in
 a log file depending on the log configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="return">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Terminates the exchange flow. The returned response is determined in the following order:
 &lt;p&gt;
 1. If there is already a response in the exchange, that response is returned
 2. If there is no response in the exchange, the body and contentType of the request is copied into a new response.
 &lt;/p&gt;
 &lt;p&gt;
 The options statusCode and contentType will overwrite the values from the messages.
 &lt;/p&gt;
 &lt;p&gt;
 This plugin is useful together with the template plugin. See examples/template.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsCSV">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
              file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="openapiValidator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Validator for OpenAPI documents&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accountRegistration">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="kubernetesValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Kubernetes Integration is still experimental.
 &lt;p&gt;
 To create the CustomResourceDefinitions, apply kubernetes-config.yaml from
 core/target/classes/com/predic8/membrane/core/config/kubernetes/ or a part (e.g. the 'serviceproxies' CRD) of the file.
 &lt;/p&gt;
 &lt;p&gt;
 Create a key and certificate for TLS for &lt;a href="https://membrane-validator.membrane-soa.svc:444/"&gt;https://membrane-validator.membrane-soa.svc:444/&lt;/a&gt; and setup Membrane to serve
 this address. The configuration shown below configures Membrane on a fixed IP address outside of the Kubernetes cluster,
 but this is no requirement.
 &lt;/p&gt;
 &lt;p&gt;
 Embed the following serviceProxy and adjust the 'resources' attribute to a comma-separated list of CRDs that you applied.
 Note that while the CRDs have plural names, here you need to use the corresponding singular. Configure the "ssl" section
 using your key and certificate.
 &lt;/p&gt;
 &lt;code&gt;
 &gt;serviceProxy port="444"&gt;
 &gt;ssl&gt;
 &gt;key&gt;
 &gt;private&gt;
 -----BEGIN RSA PRIVATE KEY-----
 ...
 -----END RSA PRIVATE KEY-----
 &gt;/private&gt;
 &gt;certificate&gt;
 -----BEGIN CERTIFICATE-----
 ...
 -----END CERTIFICATE-----
 &gt;/certificate&gt;
 &gt;/key&gt;
 &gt;/ssl&gt;
 &gt;kubernetesValidation resources="serviceproxy" /&gt;
 &gt;/serviceProxy&gt;
 &lt;/code&gt;
 &lt;p&gt;
 Now register a Webhook to validate the new CRDs. (A note to the experts: Membrane's validation schemas are too
 complex to fit into the CRD, because they are highly nestable and self-referencing. We therefore use webhooks.)
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: admissionregistration.k8s.io/v1
 kind: ValidatingWebhookConfiguration
 metadata:
 name: membrane
 webhooks:
 - name: membrane.membrane-soa.org
 admissionReviewVersions: ["v1", "v1beta1"]
 failurePolicy: Fail
 rules:
 - operations: [ "*" ]
 apiGroups: [ "membrane-soa.org" ]
 apiVersions: [ "v1", "v1beta1" ]
 resources: [ "*" ]
 scope: "*"
 clientConfig:
 service:
 name: membrane-validator
 namespace: membrane-soa
 port: 444
 caBundle: LS0t...LQ0K        # base64 encoded, PEM-formatted CA certificate
 sideEffects: None
 ---
 apiVersion: v1
 kind: Namespace
 metadata:
 name: membrane-soa
 ---
 apiVersion: v1
 kind: Service
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 spec:
 ports:
 - port: 444
 ---
 apiVersion: v1
 kind: Endpoints
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 subsets:
 - addresses:
 - ip: 192.168.0.1   # Membrane's IP
 ports:
 - port: 444
 &lt;/code&gt;
 &lt;p&gt;
 Once this setup is complete, you can enable serviceProxies like this:
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: membrane-soa.org/v1beta1
 kind: serviceproxy
 metadata:
 name: demo
 namespace: membrane-soa
 spec:
 host: demo.predic8.de
 path:
 value: /some-path/
 interceptors:
 - response:
 interceptors:
 - groovy:
 src: |
 println "Hello!"
 target:
 host: thomas-bayer.com
 &lt;/code&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setProperty">
</xsd:element>
<xsd:element ref="javascript">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Javascript. The script can access and manipulate data from the request and response.
 Use this or the Groovy plugin to extend the functions of Membrane by scripting. See the samples in examples/javascript.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="paddingHeader">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="greaser">
</xsd:element>
<xsd:element ref="soapBody">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders a SOAP body for legacy intergration&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;response&gt; plugin you can limit their application to responses only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="throttle">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The throttle feature can slow down traffic to thwart denial of service attacks.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlContentFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
 using an XPath expression.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
 match a message at all. This can improve performance significantly, as a DOM tree does probably not have
 to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
 lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
 namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
 &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
 the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
 constructed.
 &lt;/p&gt;
 &lt;p&gt;
 If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
 XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
 modified reconstituted message.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="headerFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
 The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ntlm">
</xsd:element>
<xsd:element ref="login">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
              application.
              &lt;/p&gt;
              &lt;p&gt;
              Users firstly have to authenticate themselves against a directory server using a username and password.
              Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
              token verification, access to the web application is granted for the user's session. Single Sign On can
              easily be realized using a small source code extension or modification of a web application.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
              each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
              default implementations.)
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
              cell phone number, Single Sign On data, etc.).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
              session cookie).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
              attempts for a specified amount of time.
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
              secondary channel like text messaging).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;/ul&gt;
              &lt;p&gt;
              &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
              title="login interceptor workflow"/&gt;
              &lt;/p&gt;
              &lt;p&gt;
              (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
              possible.)
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
              valid, the workflow is as follows:
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
              &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
              &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
              used. Steps 5 and 6.)&lt;/li&gt;
              &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
              &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
              was directly requested). (Step 8.)&lt;/li&gt;
              &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="sampleSoapService">
</xsd:element>
<xsd:element ref="analyser">
</xsd:element>
<xsd:element ref="validator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlRewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="regExReplacer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="abort" type="com.predic8.membrane.core.config.spring.AbortParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Plugins are usually applied to requests and responses.
 In case of errors, the flow returns and &lt;i&gt;handleAbort()&lt;/i&gt; is called on plugins
 going back the chain.
 By nesting plugins into an &lt;abort&gt; you can limit their application to abort flows only.
 On plugins nested in &lt;abort&gt; handleResponse() is called not handleAbort() in order to
 allow normal processing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiKey">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Secures APIs by validating keys stored in either files or proxies.xml. Keys can be received from clients via HTTP headers or URL query parameters. Additional permission checks are possible through scope validation - scopes are loaded into an Exchange property and can be checked using the "hasScope()" SpEL function.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="oauth2authserver">
</xsd:element>
<xsd:element ref="adminConsole">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="urlNormalizer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Replaces "/./" in the request URI's path by "/".
              &lt;/p&gt;
              &lt;p&gt;
              Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
              links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
              root). The SOA model then combines "&lt;a href="http://foo/material/ArticleService?wsdl"&gt;http://foo/material/ArticleService?wsdl&lt;/a&gt;" and
              "./ArticleService?xsd=1" to "&lt;a href="http://foo/material/./ArticleService?xsd=1"&gt;http://foo/material/./ArticleService?xsd=1&lt;/a&gt;". This URI is sent to Membrane's
              new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
              not match.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ruleMatching">
</xsd:element>
<xsd:element ref="oauth2PermissionChecker">
</xsd:element>
<xsd:element ref="for">
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="apiKey">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Secures APIs by validating keys stored in either files or proxies.xml. Keys can be received from clients via HTTP headers or URL query parameters. Additional permission checks are possible through scope validation - scopes are loaded into an Exchange property and can be checked using the "hasScope()" SpEL function.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; API key stores to validate keys against&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element name="keys" type="com.predic8.membrane.core.config.spring.KeysParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Stores api keys inline as XML.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiKeyFileStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Loads api keys from a file. File has to be one key per line, blank lines for formatting are allowed. Optionally, a comma separated list of scopes after the key and a colon in between the two. Hash symbol can be used for comments at the end of each line, including empty lines.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; See: https://github.com/membrane/api-gateway/blob/master/distribution/examples/security/api-key/simple/demo-keys.txt&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="databaseApiKeyStore" type="com.predic8.membrane.core.config.spring.DatabaseApiKeyStoreParser">
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Extractors that define where and how to extract API keys from requests&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;headerExtractor /&gt; (Using default header "X-Api-Key")&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:element name="headerExtractor" type="com.predic8.membrane.core.config.spring.HeaderExtractorParser">
</xsd:element>
<xsd:element name="queryParamExtractor" type="com.predic8.membrane.core.config.spring.QueryParamExtractorParser">
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="required" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Controls whether API key validation is enforced or optional. Optional will still load scopes and make them available for checking through SpEL function "hasScope()".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="oauth2authserver">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="1">
<xsd:element ref="staticUserDataProvider">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; listing all user data in-place in the config file.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              the &lt;i&gt;staticuserdataprovider&lt;/i&gt; can be used to statically list user data within the config file.
              &lt;/p&gt;
              &lt;p&gt;
              each user must have a unique &lt;i&gt;username&lt;/i&gt; attribute as well as a &lt;i&gt;password&lt;/i&gt; attribute.
              &lt;/p&gt;
              &lt;p&gt;
              arbitrary attributes can be set on a user element. other sub-components of the &lt;i&gt;login&lt;/i&gt; interceptor
              might use those: for example, the &lt;i&gt;telekomsmstokenprovider&lt;/i&gt; uses the &lt;i&gt;sms&lt;/i&gt; property as the
              user's cell phone number. for example, the &lt;i&gt;totptokenprovider&lt;/i&gt; uses the &lt;i&gt;secret&lt;/i&gt; property to
              initialize the token sequence.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jdbcUserDataProvider">
</xsd:element>
<xsd:element name="ldapUserDataProvider" type="com.predic8.membrane.core.config.spring.LdapUserDataProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; querying an LDAP server to authorize users and retrieve attributes.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The LDAP User Data Provider performs two jobs:
              &lt;ol&gt;
              &lt;li&gt;Authentication of a &lt;i&gt;username&lt;/i&gt; and &lt;i&gt;password&lt;/i&gt;.&lt;/li&gt;
              &lt;li&gt;Retrieval of user attributes.&lt;/li&gt;
              &lt;/ol&gt;
              &lt;/p&gt;
              &lt;p&gt;
              To achieve this, it first binds to &lt;i&gt;base&lt;/i&gt; on the LDAP server &lt;i&gt;url&lt;/i&gt;. If &lt;i&gt;binddn&lt;/i&gt; is not
              present, it binds to the LDAP server anonymously, elsewise &lt;i&gt;binddn&lt;/i&gt; and &lt;i&gt;bindpw&lt;/i&gt; are used for
              authentication.
              &lt;/p&gt;
              &lt;p&gt;
              Next, a search &lt;i&gt;searchPattern&lt;/i&gt; with scope &lt;i&gt;searchScope&lt;/i&gt; is executed where "&lt;tt&gt;%LOGIN%&lt;/tt&gt;"
              is replaced by the escaped version of the &lt;i&gt;username&lt;/i&gt;.
              &lt;/p&gt;
              &lt;p&gt;
              The search returning no node or more than one node is treated as failure.
              &lt;/p&gt;
              &lt;p&gt;
              If &lt;i&gt;passwordAttribute&lt;/i&gt; is set, and the node has an attribute with this name and this attribute's
              value starts with "&lt;tt&gt;{x-plain}&lt;/tt&gt;", the password is checked against the rest of the value for
              equality. If &lt;i&gt;passwordAttribute&lt;/i&gt; is not set, a second binding is attempted on the node using the
              &lt;i&gt;password&lt;/i&gt; the user provided.
              &lt;/p&gt;
              &lt;p&gt;
              The user attribute keys specified in the mapping are then renamed according to the mapping and used for
              further processing (see the other modules of the &lt;i&gt;login&lt;/i&gt; interceptor).
              &lt;/p&gt;
              &lt;p&gt;
              &lt;/p&gt;
              &lt;p&gt;
              For the initial binding, &lt;i&gt;connectTimeout&lt;/i&gt; can be used to specify a timeout in milliseconds. For the
              search, &lt;i&gt;timeout&lt;/i&gt; can be used.
              &lt;/p&gt;
              &lt;p&gt;
              If &lt;i&gt;readAttributesAsSelf&lt;/i&gt; is not set, the user attributes are collected from the search result. If
              it is set, an additional request is made after the second successful binding to retrieve the node's
              attributes.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="fileUserDataProvider">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; utilizing htpasswd formatted files.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              the &lt;i&gt;fileuserdataprovider&lt;/i&gt; can be used to source authentication data from htpasswd files.
              &lt;/p&gt;
              &lt;p&gt;
              The files can only utilize algorithm magic strings supported by &lt;i&gt;crypt(3)&lt;/i&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="cachingUserDataProvider" type="com.predic8.membrane.core.config.spring.CachingUserDataProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Caching User Data provider caches previous successful logins in order to make authentication faster&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="customStatementJdbcUserDataProvider">
</xsd:element>
<xsd:element name="unifyingUserDataProvider" type="com.predic8.membrane.core.config.spring.UnifyingUserDataProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;unifyingUserDataProvider&lt;/i&gt; can be used to merge two or more other &lt;i&gt;user data providers&lt;/i&gt;
              into one.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;unifyingUserDataProvider&lt;/i&gt; will forward a login attempt (username and password) to each inner
              user data provider in the order they are specified. After one of the inner user data providers returned
              a successful login (and returned the user's attributes), the procedure terminates. If no inner user data
              provider could verify the user, the login attempt fails.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element name="sessionManager" type="com.predic8.membrane.core.config.spring.SessionManagerParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The Session Manager identifies users across HTTP requests using a session cookie.
              &lt;/p&gt;
              &lt;p&gt;
              The name of the session cookie can be specified using the &lt;i&gt;cookieName&lt;/i&gt; attribute. The default name
              is "&lt;tt&gt;SESSIONID&lt;/tt&gt;".
              &lt;/p&gt;
              &lt;p&gt;
              The session timeout can be specified in milliseconds using the &lt;i&gt;timeout&lt;/i&gt; attribute. The default
              timeout is 5 minutes.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element ref="accountBlocker">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Keeps track of blocked user accounts (accounts become blocked after too many failed logins).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The Account Blocker prevents password and token guessing attempts: It blocks a user (or the whole
              system) after too many failed login attempts.
              &lt;/p&gt;
              &lt;p&gt;
              When a user entered a wrong password or wrong token more than &lt;i&gt;afterFailedLogins&lt;/i&gt; times, this user
              becomes blocked: He will be prevented from logging in again within the next &lt;i&gt;blockFor&lt;/i&gt; milliseconds
              (writing 3600000 means "for 1 hour").
              &lt;/p&gt;
              &lt;p&gt;
              The failed login attempts have to occur within the last &lt;i&gt;afterFailedLoginsWithin&lt;/i&gt; milliseconds
              (writing 9223372036854775807 means "forever").
              &lt;/p&gt;
              &lt;p&gt;
              If more than &lt;i&gt;blockWholeSystemAfter&lt;/i&gt; users become blocked at a time, the &lt;i&gt;all&lt;/i&gt; users will
              become blocked. (This is necessary to limit memory usage.)
              &lt;/p&gt;
              &lt;h3&gt;Discussion&lt;/h3&gt;
              &lt;p&gt;
              Say, for example, a scripted dictionary attack tries to guess a user's password. Using the configuration
              shown above, which is the default configuration if no &lt;i&gt;accountBlocker&lt;/i&gt; is declared, this results in
              5 guesses per 3600000 milliseconds; or equivalently 42720 guesses per year.
              &lt;/p&gt;
              &lt;p&gt;
              The probability of hitting a uniformly at random chosen word of the standard German vocabulary within
              one year is therefore about 56%.
              &lt;/p&gt;
              &lt;p&gt;
              Therefore, a more secure password should be chosen, containing letters, digits and special characters.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="1">
<xsd:element ref="staticClientList">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element ref="bearerJwtToken">
</xsd:element>
<xsd:element ref="bearerToken">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="0">
<xsd:element ref="refresh">
</xsd:element>
</xsd:choice>
<xsd:choice minOccurs="1">
<xsd:element ref="claims">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="location" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Base path under which the login dialog will be served.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; logindialog&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="path" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="message" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="exposeUserCredentialsToSession" type="spel_boolean" >
</xsd:attribute>
<xsd:attribute name="issuer" type="xsd:string" use="required">
</xsd:attribute>
<xsd:attribute name="consentFile" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="issueNonSpecIdTokens" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Issue id-tokens also in credentials-flow and password-flow . The OIDC specification, which brings in id-tokens, does not handle those flows, which is why the default value is false.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="issueNonSpecRefreshTokens" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Issue refresh-tokens also in credentials-flow. The OAuth2 specification does not issue refresh tokens in the credentials-flow, which is why the default value is false.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="bearerToken">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.TelekomSMSTokenProviderParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="prefixText" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A string that will be prepended to the token when creating the text message.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; "Token: "&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; "Token: "&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="simulate" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Don't send any text messages, only write tokens to the log.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="scope" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;scope&lt;/i&gt; assigned to you by developergarden.com .&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="clientId" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;clientId&lt;/i&gt; assigned to you by developergarden.com .&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="clientSecret" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;clientSecret&lt;/i&gt; assigned to you by developergarden.com .&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="senderName" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The sender name of the text messages. May only be set, if you are a member of the &lt;i&gt;premium&lt;/i&gt; program on developergarded.com .&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="senderAddress" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The sender address (telephone number) of the text messages. May only be set, if you are a member of the &lt;i&gt;premium&lt;/i&gt; program on developergarded.com .&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="environment" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;environment&lt;/i&gt; (program name) you are paying for on developergarden.com .&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; premium&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; budget&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="customStatementJdbcUserDataProvider">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="checkPasswordSql" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="sqlResultAttribute" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="userNameAttribute" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="datasource" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="tableName" type="xsd:string" use="required">
</xsd:attribute>
<xsd:attribute name="userColumnName" type="xsd:string" use="required">
</xsd:attribute>
<xsd:attribute name="passwordColumnName" type="xsd:string" use="required">
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="adminConsole">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="readOnly" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Whether runtime changes to Membrane's configuration can be committed in the admin console.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="useXForwardedForAsClientAddr" type="spel_boolean" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; whether to show the value of the first "X-Forwarded-For" header instead of the client IP address&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="exclude">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Contains a Java regex for &lt;i&gt;excluding&lt;/i&gt; message headers.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent mixed="true">
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/></xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="jwtSessionManager2">
<xsd:complexType>
<xsd:complexContent mixed="true">
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/></xsd:sequence>
<xsd:attribute name="cookieName" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="timeout" type="spel_number" >
</xsd:attribute>
<xsd:attribute name="domain" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.TotpTokenProviderParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="urlNormalizer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Replaces "/./" in the request URI's path by "/".
              &lt;/p&gt;
              &lt;p&gt;
              Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
              links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
              root). The SOA model then combines "&lt;a href="http://foo/material/ArticleService?wsdl"&gt;http://foo/material/ArticleService?wsdl&lt;/a&gt;" and
              "./ArticleService?xsd=1" to "&lt;a href="http://foo/material/./ArticleService?xsd=1"&gt;http://foo/material/./ArticleService?xsd=1&lt;/a&gt;". This URI is sent to Membrane's
              new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
              not match.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="ruleMatching">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="xForwardedForEnabled" type="spel_boolean" >
</xsd:attribute>
<xsd:attribute name="maxXForwardedForHeaders" type="spel_number" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.OtlpExporterParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element name="addHeader" type="com.predic8.membrane.core.config.spring.AddHeaderParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="transport" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="secured" type="spel_boolean" >
</xsd:attribute>
<xsd:attribute name="path" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="host" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="port" type="spel_number" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:complexType name="com.predic8.membrane.core.config.spring.AddHeaderParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="name" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="value" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="truststore">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="location" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A file/resource containing the PKCS#12 keystore (*.p12).
 See &lt;a href="https://www.membrane-soa.org/service-proxy-doc/current/configuration/location.htm"&gt;here&lt;/a&gt; for a description of the format.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="password" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="type" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="provider" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="algorithm" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="checkRevocation" type="xsd:string" >
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:element name="oauth2PermissionChecker">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0">
<xsd:element name="userInfo" type="com.predic8.membrane.core.config.spring.UserInfoParser">
</xsd:element>
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="expression" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.AzureDnsParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="dnsZoneName" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="subscriptionId" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="tenantId" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="resourceGroup" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="resource" type="xsd:string" >
</xsd:attribute>
<xsd:attribute name="identity" type="xsd:string" >
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:complexType name="com.predic8.membrane.core.config.spring.UnifyingUserDataProviderParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="1" maxOccurs="unbounded">
<xsd:element ref="staticUserDataProvider">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; listing all user data in-place in the config file.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              the &lt;i&gt;staticuserdataprovider&lt;/i&gt; can be used to statically list user data within the config file.
              &lt;/p&gt;
              &lt;p&gt;
              each user must have a unique &lt;i&gt;username&lt;/i&gt; attribute as well as a &lt;i&gt;password&lt;/i&gt; attribute.
              &lt;/p&gt;
              &lt;p&gt;
              arbitrary attributes can be set on a user element. other sub-components of the &lt;i&gt;login&lt;/i&gt; interceptor
              might use those: for example, the &lt;i&gt;telekomsmstokenprovider&lt;/i&gt; uses the &lt;i&gt;sms&lt;/i&gt; property as the
              user's cell phone number. for example, the &lt;i&gt;totptokenprovider&lt;/i&gt; uses the &lt;i&gt;secret&lt;/i&gt; property to
              initialize the token sequence.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jdbcUserDataProvider">
</xsd:element>
<xsd:element name="ldapUserDataProvider" type="com.predic8.membrane.core.config.spring.LdapUserDataProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; querying an LDAP server to authorize users and retrieve attributes.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The LDAP User Data Provider performs two jobs:
              &lt;ol&gt;
              &lt;li&gt;Authentication of a &lt;i&gt;username&lt;/i&gt; and &lt;i&gt;password&lt;/i&gt;.&lt;/li&gt;
              &lt;li&gt;Retrieval of user attributes.&lt;/li&gt;
              &lt;/ol&gt;
              &lt;/p&gt;
              &lt;p&gt;
              To achieve this, it first binds to &lt;i&gt;base&lt;/i&gt; on the LDAP server &lt;i&gt;url&lt;/i&gt;. If &lt;i&gt;binddn&lt;/i&gt; is not
              present, it binds to the LDAP server anonymously, elsewise &lt;i&gt;binddn&lt;/i&gt; and &lt;i&gt;bindpw&lt;/i&gt; are used for
              authentication.
              &lt;/p&gt;
              &lt;p&gt;
              Next, a search &lt;i&gt;searchPattern&lt;/i&gt; with scope &lt;i&gt;searchScope&lt;/i&gt; is executed where "&lt;tt&gt;%LOGIN%&lt;/tt&gt;"
              is replaced by the escaped version of the &lt;i&gt;username&lt;/i&gt;.
              &lt;/p&gt;
              &lt;p&gt;
              The search returning no node or more than one node is treated as failure.
              &lt;/p&gt;
              &lt;p&gt;
              If &lt;i&gt;passwordAttribute&lt;/i&gt; is set, and the node has an attribute with this name and this attribute's
              value starts with "&lt;tt&gt;{x-plain}&lt;/tt&gt;", the password is checked against the rest of the value for
              equality. If &lt;i&gt;passwordAttribute&lt;/i&gt; is not set, a second binding is attempted on the node using the
              &lt;i&gt;password&lt;/i&gt; the user provided.
              &lt;/p&gt;
              &lt;p&gt;
              The user attribute keys specified in the mapping are then renamed according to the mapping and used for
              further processing (see the other modules of the &lt;i&gt;login&lt;/i&gt; interceptor).
              &lt;/p&gt;
              &lt;p&gt;
              &lt;/p&gt;
              &lt;p&gt;
              For the initial binding, &lt;i&gt;connectTimeout&lt;/i&gt; can be used to specify a timeout in milliseconds. For the
              search, &lt;i&gt;timeout&lt;/i&gt; can be used.
              &lt;/p&gt;
              &lt;p&gt;
              If &lt;i&gt;readAttributesAsSelf&lt;/i&gt; is not set, the user attributes are collected from the search result. If
              it is set, an additional request is made after the second successful binding to retrieve the node's
              attributes.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="fileUserDataProvider">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; utilizing htpasswd formatted files.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              the &lt;i&gt;fileuserdataprovider&lt;/i&gt; can be used to source authentication data from htpasswd files.
              &lt;/p&gt;
              &lt;p&gt;
              The files can only utilize algorithm magic strings supported by &lt;i&gt;crypt(3)&lt;/i&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="cachingUserDataProvider" type="com.predic8.membrane.core.config.spring.CachingUserDataProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Caching User Data provider caches previous successful logins in order to make authentication faster&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="customStatementJdbcUserDataProvider">
</xsd:element>
<xsd:element name="unifyingUserDataProvider" type="com.predic8.membrane.core.config.spring.UnifyingUserDataProviderParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;unifyingUserDataProvider&lt;/i&gt; can be used to merge two or more other &lt;i&gt;user data providers&lt;/i&gt;
              into one.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;unifyingUserDataProvider&lt;/i&gt; will forward a login attempt (username and password) to each inner
              user data provider in the order they are specified. After one of the inner user data providers returned
              a successful login (and returned the user's attributes), the procedure terminates. If no inner user data
              provider could verify the user, the login attempt fails.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
</xsd:choice>
</xsd:sequence>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
<xsd:element name="for">
<xsd:complexType>
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element ref="httpClient">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
 Server using the HTTP protocol. Usually it will be globally used
 inside the transport. However, it is also possible to use it
 inside a proxy to give the proxy an individual configuration for
 its outgoing HTTP connection that is different from the global
 configuration in the transport.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtAuth">
</xsd:element>
<xsd:element ref="interceptor">
</xsd:element>
<xsd:element ref="tcp">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="tokenValidator">
</xsd:element>
<xsd:element ref="beautifier">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Beautifies request and response bodies. Supported are the Formats: JSON, XML&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="static">
</xsd:element>
<xsd:element ref="jsonProtection">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="http2xml">
</xsd:element>
<xsd:element name="echo" type="com.predic8.membrane.core.config.spring.EchoParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Returns the flow of plugins and copies the content of the
 request into a new response. The response has a status code of 200.
 Useful for testing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xml2Json">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If enabled converts body content from xml to json.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Can be used for both request and response. Xml file assumed to be in UTF-8. If input is invalid it returns
 empty json object.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="authHead2Body">
</xsd:element>
<xsd:element ref="webServer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
 "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
 &lt;/p&gt;
 &lt;p&gt;
 The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
 HTTP response with the contents of a file, or a "404 Not Found." error.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="internalRouting">
</xsd:element>
<xsd:element ref="exchangeStore">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
              might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="dispatching">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
 element to the list of destinations of the exchange object. It
 must be placed into the transport to make Service Proxies Work
 properly. It has to be placed after the ruleMatching
 interceptor. The ruleMatching interceptor looks up a service
 proxy for an incoming request and places it into the exchange
 object. The dispatching interceptor needs the service proxy to
 get information about the target.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shadowing">
</xsd:element>
<xsd:element ref="openapiPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;openapiPublisher&lt;/i&gt; serves OpenAPI documents
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessControl">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
              requested resource.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="acmeHttpChallenge">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See the documentation of the &lt;code&gt;&lt;acme /&gt;&lt;/code&gt; element for usage details.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="transform">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The transform feature applies an XSLT transformation to the content in the body of a message. After the
              transformation the body content is replaced with the result of the transformation.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 Rewrites or redirects the path of incoming requests based on a mapping.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="rest2Soap">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xenAuthentication">
</xsd:element>
<xsd:element ref="graphQLProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Check GraphQL-over-HTTP requests, enforcing several limits and/or restrictions. This effectively helps to reduce
 the attack surface.
 &lt;p&gt;
 GraphQL Specification "October2021" is used. (But GraphQL only covers formulation of Documents/Queries.)
 &lt;/p&gt;
 &lt;p&gt;
 GraphQL-over-HTTP, which specifies how to submit GraphQL queries via HTTP, has not been released/finalized yet. We
 therefore use Version
 &lt;a href="https://github.com/graphql/graphql-over-http/blob/a1e6d8ca248c9a19eb59a2eedd988c204909ee3f/spec/GraphQLOverHTTP.md"&gt;a1e6d8ca&lt;/a&gt;.
 &lt;/p&gt;
 &lt;p&gt;
 Only GraphQL documents conforming to the 'ExecutableDocument' of the grammar are allowed: This includes the usual
 'query', 'mutation', 'subscription' and 'fragment's.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapOperationExtractor">
</xsd:element>
<xsd:element ref="balancer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="reverseProxying">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
 as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
 hostnames and ports used to access Membrane  vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clamav">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Delegates virus checks to an external Virus Scanner.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="destination">
</xsd:element>
<xsd:element ref="requireAuth">
</xsd:element>
<xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;request&gt; Element you can limit their application to requests only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="cache">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Don't use, this does NOT implement valid HTTP caching.
              &lt;/p&gt;
              &lt;p&gt;
                  We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                  the Docker Registry for offline use.
                  The cache does not revalidate any responses, so machines querying the cache for Debian
                  package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                  This is - simply put - the only use case, where using this class makes any sense.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsJDBC">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
 database (one row per exchange).&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="index">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
              To use this feature just add a serviceProxy containing the index
              element. Of course you can protect the service proxy by using
              SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlPublisher">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;wsdlPublisher&lt;/i&gt; serves WSDL files (and attached XML Schema Documents), if your
 backend service does not already do so.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="webServiceExplorer">
</xsd:element>
<xsd:element ref="logContext">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="APIsJSON">
</xsd:element>
<xsd:element ref="flowInitiator">
</xsd:element>
<xsd:element ref="counter">
</xsd:element>
<xsd:element ref="rateLimiter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;rateLimiter&lt;/i&gt; plugin limits the number of requests of a client in a period of time.
 As a default the client requests are grouped by client-Ip address and then counted. There are lots of
 possibilities to group the requests using the keyExpression. The requests can even be counted from different
 clients together.&lt;/p&gt;
 &lt;p&gt;When the gateway is located behind a loadbalancer then
 the client-Ip address is not the one from the client but the address from the balancer. To get the real Ip-address loadbalancers,
 &lt;i&gt;Web Application Firewalls&lt;/i&gt; and reverse proxies set the ip from the original client into the &lt;i&gt;X-Forwarded-For&lt;/i&gt; HTTP
 header field. The limiter plugin can take the Ip-address from the header.&lt;/p&gt;
 &lt;p&gt;
 The X-Forwarded-For header can only be trusted when a trustworthy reverse proxy or load balancer is between the client and server. The gateway not should be
 reachable directly. Only activate this feature when you know what you are doing.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="call">
</xsd:element>
<xsd:element ref="oauth2Resource2">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
 authorization server as response.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="if">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The "if" interceptor supports conditional execution of nested plugins.
 &lt;/p&gt;
 See:
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorSpELTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorGroovyTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorJsonpathTest
 - com.predic8.membrane.core.interceptor.flow.IfInterceptorXPathTest&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="template">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders the body content of a message from a template. The template can
 produce plain text, Json or XML. Variables in the template are substituted with values from the body,
 header, query parameters, etc. If the extension of a referenced template file is &lt;i&gt;.xml&lt;/i&gt; it will use
 &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_xmltemplateengine"&gt;XMLTemplateEngine&lt;/a&gt;
 otherwise &lt;a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_streamingtemplateengine"&gt;StreamingTemplateEngine&lt;/a&gt;.
 Have a look at the samples in &lt;a href="https://github.com/membrane/service-proxy/tree/master/distribution/examples"&gt;examples/template&lt;/a&gt;.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="groovyTemplate">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Uses the groovy template markup engine to produce HTML-based responses.
 &lt;code&gt;
 &lt;groovyTemplate&gt;&lt;![CDATA[
   html {
     head {
       title('Resource')
     }
     body {
       p('Hello from Membrane!')
     }
   }
 ]]&gt;&lt;/groovyTemplate&gt;
 &lt;/code&gt;
 &lt;p&gt;
 The word "spring" refers to the Spring ApplicationContext.
 The word "exc" refers to the Membrane Exchange being handled.
 The word "flow" refers to the current Membrane Flow (=REQUEST).
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accessLog">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes exchange metrics into a Log4j appender&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Defaults to Apache Common Log pattern&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="prometheus">
</xsd:element>
<xsd:element ref="wadlRewriter">
</xsd:element>
<xsd:element ref="openTelemetry">
</xsd:element>
<xsd:element ref="limit">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Note that due to the streaming nature of Membrane, a request header may already have been passed on to
              the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
              aborted and the connection to the backend is simply closed.
              &lt;/p&gt;
              &lt;p&gt;
              To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
              &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="basicAuthentication">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="json2Xml">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts body payload from JSON to XML. The JSON must be an object other JSON documents e.g. arrays are not supported.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Resulting XML will be in UTF-8 encoding.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="shutdown">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Shutdown interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                  Adds the ability to shutdown main router thread via an HTTP request.
                  Don't forget to setup security for this interceptor.
              &lt;/p&gt;
              &lt;p&gt;
                  Has undefined behavior when Membrane is &lt;b&gt;not&lt;/b&gt; started from command line
                  (=via the RouterCLI class, which &lt;tt&gt;service-proxy.ps1&lt;/tt&gt;/&lt;tt&gt;service-proxy.sh&lt;/tt&gt;
                  do use).
              &lt;/p&gt;
              &lt;p&gt;
                  Only actually terminates the running JVM, when used in the first
                  &lt;tt&gt;&lt;router&gt;&lt;/tt&gt; bean (which implicitly stands for
                  &lt;tt&gt;&lt;router id="router"&gt;&lt;/tt&gt;) called "router".
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="userFeature">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="soapStackTraceFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
              advised to test its functionality in combination with your SOAP service provider before deploying it in
              production.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="formValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiDocs">
</xsd:element>
<xsd:element ref="choose">
</xsd:element>
<xsd:element ref="testService">
</xsd:element>
<xsd:element ref="soap2Rest">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="clusterNotification">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane API Gateway distribution.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setHeader">
</xsd:element>
<xsd:element ref="groovy">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Groovy script. The script can access and manipulate data from the request and response.
 Use this or the Javascript plugin to extend the functions of Membrane by scripting.
 See: example/groovy for working samples&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="jwtSign">
</xsd:element>
<xsd:element ref="statisticsProvider">
</xsd:element>
<xsd:element ref="replace">
</xsd:element>
<xsd:element ref="methodOverride">
</xsd:element>
<xsd:element ref="stompClient">
</xsd:element>
<xsd:element ref="webSocket">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
              href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
              After the upgrade, the connection's data packets are simply forwarded
              and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlProtection">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
 attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="log">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages. The messages will appear either on the console or in
 a log file depending on the log configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="return">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Terminates the exchange flow. The returned response is determined in the following order:
 &lt;p&gt;
 1. If there is already a response in the exchange, that response is returned
 2. If there is no response in the exchange, the body and contentType of the request is copied into a new response.
 &lt;/p&gt;
 &lt;p&gt;
 The options statusCode and contentType will overwrite the values from the messages.
 &lt;/p&gt;
 &lt;p&gt;
 This plugin is useful together with the template plugin. See examples/template.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="statisticsCSV">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
              file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="openapiValidator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. OpenAPI&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Validator for OpenAPI documents&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="accountRegistration">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="kubernetesValidation">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Kubernetes Integration is still experimental.
 &lt;p&gt;
 To create the CustomResourceDefinitions, apply kubernetes-config.yaml from
 core/target/classes/com/predic8/membrane/core/config/kubernetes/ or a part (e.g. the 'serviceproxies' CRD) of the file.
 &lt;/p&gt;
 &lt;p&gt;
 Create a key and certificate for TLS for &lt;a href="https://membrane-validator.membrane-soa.svc:444/"&gt;https://membrane-validator.membrane-soa.svc:444/&lt;/a&gt; and setup Membrane to serve
 this address. The configuration shown below configures Membrane on a fixed IP address outside of the Kubernetes cluster,
 but this is no requirement.
 &lt;/p&gt;
 &lt;p&gt;
 Embed the following serviceProxy and adjust the 'resources' attribute to a comma-separated list of CRDs that you applied.
 Note that while the CRDs have plural names, here you need to use the corresponding singular. Configure the "ssl" section
 using your key and certificate.
 &lt;/p&gt;
 &lt;code&gt;
 &gt;serviceProxy port="444"&gt;
 &gt;ssl&gt;
 &gt;key&gt;
 &gt;private&gt;
 -----BEGIN RSA PRIVATE KEY-----
 ...
 -----END RSA PRIVATE KEY-----
 &gt;/private&gt;
 &gt;certificate&gt;
 -----BEGIN CERTIFICATE-----
 ...
 -----END CERTIFICATE-----
 &gt;/certificate&gt;
 &gt;/key&gt;
 &gt;/ssl&gt;
 &gt;kubernetesValidation resources="serviceproxy" /&gt;
 &gt;/serviceProxy&gt;
 &lt;/code&gt;
 &lt;p&gt;
 Now register a Webhook to validate the new CRDs. (A note to the experts: Membrane's validation schemas are too
 complex to fit into the CRD, because they are highly nestable and self-referencing. We therefore use webhooks.)
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: admissionregistration.k8s.io/v1
 kind: ValidatingWebhookConfiguration
 metadata:
 name: membrane
 webhooks:
 - name: membrane.membrane-soa.org
 admissionReviewVersions: ["v1", "v1beta1"]
 failurePolicy: Fail
 rules:
 - operations: [ "*" ]
 apiGroups: [ "membrane-soa.org" ]
 apiVersions: [ "v1", "v1beta1" ]
 resources: [ "*" ]
 scope: "*"
 clientConfig:
 service:
 name: membrane-validator
 namespace: membrane-soa
 port: 444
 caBundle: LS0t...LQ0K        # base64 encoded, PEM-formatted CA certificate
 sideEffects: None
 ---
 apiVersion: v1
 kind: Namespace
 metadata:
 name: membrane-soa
 ---
 apiVersion: v1
 kind: Service
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 spec:
 ports:
 - port: 444
 ---
 apiVersion: v1
 kind: Endpoints
 metadata:
 namespace: membrane-soa
 name: membrane-validator
 subsets:
 - addresses:
 - ip: 192.168.0.1   # Membrane's IP
 ports:
 - port: 444
 &lt;/code&gt;
 &lt;p&gt;
 Once this setup is complete, you can enable serviceProxies like this:
 &lt;/p&gt;
 &lt;code&gt;
 apiVersion: membrane-soa.org/v1beta1
 kind: serviceproxy
 metadata:
 name: demo
 namespace: membrane-soa
 spec:
 host: demo.predic8.de
 path:
 value: /some-path/
 interceptors:
 - response:
 interceptors:
 - groovy:
 src: |
 println "Hello!"
 target:
 host: thomas-bayer.com
 &lt;/code&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="setProperty">
</xsd:element>
<xsd:element ref="javascript">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Executes a Javascript. The script can access and manipulate data from the request and response.
 Use this or the Groovy plugin to extend the functions of Membrane by scripting. See the samples in examples/javascript.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="paddingHeader">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="greaser">
</xsd:element>
<xsd:element ref="soapBody">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Renders a SOAP body for legacy intergration&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
 &lt;response&gt; plugin you can limit their application to responses only.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="throttle">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The throttle feature can slow down traffic to thwart denial of service attacks.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="xmlContentFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
 using an XPath expression.
 &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
 If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
 match a message at all. This can improve performance significantly, as a DOM tree does probably not have
 to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
 lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
 namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
 &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
 the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
 constructed.
 &lt;/p&gt;
 &lt;p&gt;
 If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
 XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
 modified reconstituted message.
 &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="headerFilter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
 The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ntlm">
</xsd:element>
<xsd:element ref="login">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
              application.
              &lt;/p&gt;
              &lt;p&gt;
              Users firstly have to authenticate themselves against a directory server using a username and password.
              Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
              token verification, access to the web application is granted for the user's session. Single Sign On can
              easily be realized using a small source code extension or modification of a web application.
              &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
              each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
              default implementations.)
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
              cell phone number, Single Sign On data, etc.).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
              session cookie).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
              attempts for a specified amount of time.
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
              &lt;p&gt;
              The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
              secondary channel like text messaging).
              &lt;/p&gt;
              &lt;/li&gt;
              &lt;/ul&gt;
              &lt;p&gt;
              &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
              title="login interceptor workflow"/&gt;
              &lt;/p&gt;
              &lt;p&gt;
              (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
              possible.)
              &lt;/p&gt;
              &lt;p&gt;
              The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
              valid, the workflow is as follows:
              &lt;/p&gt;
              &lt;ul&gt;
              &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
              &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
              &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
              used. Steps 5 and 6.)&lt;/li&gt;
              &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
              &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
              was directly requested). (Step 8.)&lt;/li&gt;
              &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="sampleSoapService">
</xsd:element>
<xsd:element ref="analyser">
</xsd:element>
<xsd:element ref="validator">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="wsdlRewriter">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Web Services with SOAP and WSDL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="regExReplacer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element name="abort" type="com.predic8.membrane.core.config.spring.AbortParser">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Proxies and Flow&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Plugins are usually applied to requests and responses.
 In case of errors, the flow returns and &lt;i&gt;handleAbort()&lt;/i&gt; is called on plugins
 going back the chain.
 By nesting plugins into an &lt;abort&gt; you can limit their application to abort flows only.
 On plugins nested in &lt;abort&gt; handleResponse() is called not handleAbort() in order to
 allow normal processing.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="apiKey">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Security and Validation&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Secures APIs by validating keys stored in either files or proxies.xml. Keys can be received from clients via HTTP headers or URL query parameters. Additional permission checks are possible through scope validation - scopes are loaded into an Exchange property and can be checked using the "hasScope()" SpEL function.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="oauth2authserver">
</xsd:element>
<xsd:element ref="adminConsole">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="urlNormalizer">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Misc&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
              Replaces "/./" in the request URI's path by "/".
              &lt;/p&gt;
              &lt;p&gt;
              Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
              links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
              root). The SOA model then combines "&lt;a href="http://foo/material/ArticleService?wsdl"&gt;http://foo/material/ArticleService?wsdl&lt;/a&gt;" and
              "./ArticleService?xsd=1" to "&lt;a href="http://foo/material/./ArticleService?xsd=1"&gt;http://foo/material/./ArticleService?xsd=1&lt;/a&gt;". This URI is sent to Membrane's
              new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
              not match.
              &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:element>
<xsd:element ref="ruleMatching">
</xsd:element>
<xsd:element ref="oauth2PermissionChecker">
</xsd:element>
<xsd:element ref="for">
</xsd:element>
<xsd:any namespace="##other" processContents="strict" />
</xsd:choice>
</xsd:sequence>
<xsd:attribute name="language" type="xsd:string" >
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the language of the 'test' condition&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; SpEL, groovy, jsonpath, xpath&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; groovy&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="in" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation></xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>
<xsd:complexType name="com.predic8.membrane.core.config.spring.Rest2SoapmappingParser">
<xsd:complexContent >
<xsd:extension base="beans:identifiedType">
<xsd:sequence>
</xsd:sequence>
<xsd:attribute name="regex" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Java Regular expression&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; /bank/.*&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="soapAction" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Value of the soapAction header field.&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="soapURI" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Endpoint address of the SOAP service.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; /axis2/$1&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="requestXSLT" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Transformation that will be applied to the request.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; blz-request.xsl&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="responseXSLT" type="xsd:string" use="required">
<xsd:annotation>
<xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Transformation that will be applied to the response.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; shop-request.xsl&lt;br/&gt;</xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:schema>