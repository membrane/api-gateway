/* Copyright 2022 predic8 GmbH, www.predic8.com

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License. */
package com.predic8.membrane.core.kubernetes;

import com.google.common.collect.ImmutableMap;
import com.predic8.membrane.annot.MCAttribute;
import com.predic8.membrane.annot.MCChildElement;
import com.predic8.membrane.annot.MCElement;
import com.predic8.membrane.annot.MCOtherAttributes;
import com.predic8.membrane.core.config.spring.K8sHelperGeneratorAutoGenerated;
import org.jetbrains.annotations.NotNull;
import org.yaml.snakeyaml.error.*;
import org.yaml.snakeyaml.events.*;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.*;

import static com.google.api.client.util.Types.newInstance;
import static com.predic8.membrane.core.config.spring.k8s.YamlLoader.readString;
import static com.predic8.membrane.core.kubernetes.ParserHelper.*;
import static org.springframework.core.annotation.AnnotationUtils.findAnnotation;

public class GenericYamlParser {

    @SuppressWarnings({"rawtypes"})
    public static <T> T parse(String context, Class<T> clazz, Iterator<Event> events, BeanRegistry registry) {
        Event event = null;
        Mark lastContextMark = null;
        try {
            T obj = newInstance(clazz);
            event = events.next();
            if (event instanceof SequenceStartEvent) {
                // when this is a list, we are on a @MCElement(..., noEnvelope=true)
                List value = parseListExcludingStartEvent(context, events, registry);
                Method setter = getSingleChildSetter(clazz);
                setSetter(obj, setter, value);
                return obj;
            }
            ensureMappingStart(event);
            if (clazz.getAnnotation(MCElement.class) != null && clazz.getAnnotation(MCElement.class).noEnvelope())
                throw new RuntimeException("Class " + clazz.getName() + " is annotated with @MCElement(noEnvelope=true), but the YAML/JSON structure does not contain a list.");

            while(true) {
                event = events.next();

                if (event instanceof MappingEndEvent) break;

                String key = getScalarKey(event);
                lastContextMark = event.getStartMark();

                if ("$ref".equals(key)) {
                    handleTopLevelRefs(clazz, events, registry, obj);
                    continue;
                }

                Method setter = getSetter(clazz, key);
                Class clazz2 = null;
                if (setter == null) {
                    try {
                        clazz2 = K8sHelperGeneratorAutoGenerated.getLocal(context, key);
                        if (clazz2 == null)
                            clazz2 = K8sHelperGeneratorAutoGenerated.elementMapping.get(key);
                        if (clazz2 != null)
                            setter = getChildSetter(clazz, clazz2);
                    } catch (Exception e) {
                        throw new RuntimeException("Can't find method or bean for key: " + key + " in " + clazz.getName(), e);
                    }
                    if (setter == null)
                        setter = getAnySetter(clazz);
                    if (clazz2 == null && setter == null)
                        throw new RuntimeException("Can't find method or bean for key: " + key + " in " + clazz.getName());
                }

                setSetter(obj, setter, resolveSetterValue((Class) setter.getParameterTypes()[0], setter, context, events, registry, key, clazz2, event));
            }
            return obj;
        } catch (Throwable cause) {
            Mark problemMark = event != null ? event.getStartMark() : null;
            // Fall back if we don't have marks
            if (problemMark == null && lastContextMark == null) {
                throw new RuntimeException("YAML parse error: " + cause.getMessage(), cause);
            }
            // This exception type prints a caret + snippet automatically
            throw new PublicMarkedYAMLException(
                    "while parsing " + clazz.getSimpleName(),
                    lastContextMark,
                    cause.getMessage(),
                    problemMark,
                    cause.getMessage()
            );
//            throw new RuntimeException(e);
        }

    }

    private static <T> Method getSingleChildSetter(Class<T> clazz) {
        MCElement annotation = clazz.getAnnotation(MCElement.class);
        if (annotation == null || !annotation.noEnvelope()) {
            throw new RuntimeException("Class " + clazz.getName() + " has properties, and is not a list.");
        }
        if (Arrays.stream(clazz.getMethods())
                .filter(ParserHelper::isSetter)
                .anyMatch(method -> findAnnotation(method, MCAttribute.class) != null)) {
            throw new RuntimeException("Class " + clazz.getName() + " should not have any @MCAttribute setters, because it is a @MCElement with noEnvelope=true .");
        }
        List<Method> childSetters = Arrays.stream(clazz.getMethods())
                .filter(ParserHelper::isSetter)
                .filter(method -> findAnnotation(method, MCChildElement.class) != null)
                .toList();
        if (childSetters.isEmpty()) {
            throw new RuntimeException("No @MCChildElement setter found in " + clazz.getName());
        }
        if (childSetters.size() > 1) {
            throw new RuntimeException("Multiple @MCChildElement setters found in " + clazz.getName() + ". Only one is allowed when noEnvelope=true.");
        }
        Method setter = childSetters.get(0);
        Class<?> paramType = setter.getParameterTypes()[0];
        if (!java.util.Collection.class.isAssignableFrom(paramType)) {
            throw new RuntimeException("The single @MCChildElement setter in " + clazz.getName() +
                 " must accept a Collection/List when noEnvelope=true, but found: " + paramType.getName());
        }
        return setter;
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    private static Object resolveSetterValue(Class<?> wanted, Method setter, String context, Iterator<Event> events, BeanRegistry registry, String key, Class clazz2, Event event) {
        if (wanted.equals(List.class) || wanted.equals(Collection.class)) {
            return parseListIncludingStartEvent(context, events, registry);
        }
        if (wanted.isEnum()) {
           return Enum.valueOf((Class<Enum>) wanted, readString(events).toUpperCase(Locale.ROOT));
        }
        if (wanted.equals(String.class)) {
            return readString(events);
        }
        if (wanted.equals(Integer.TYPE)) {
            return Integer.parseInt(readString(events));
        }
        if (wanted.equals(Long.TYPE)) {
            return Long.parseLong(readString(events));
        }
        if (wanted.equals(Boolean.TYPE)) {
            return Boolean.parseBoolean(readString(events));
        }
        if (wanted.equals(Map.class) && findAnnotation(setter, MCOtherAttributes.class) != null) {
            return ImmutableMap.of(key, readString(events));
        }
        if (isStructured(setter)) {
            if (clazz2 != null)
                return parseMapToObj(context, events, event, registry);
            else
               return parse(context, wanted, events, registry);
        }
        if (findAnnotation(setter, MCAttribute.class) != null && findAnnotation(setter.getParameterTypes()[0], MCElement.class) != null) {
            return registry.resolveReference(readString(events));
        }
        throw new RuntimeException("Not implemented setter type " + wanted);
    }

    private static <T> void handleTopLevelRefs(Class<T> clazz, Iterator<Event> events, BeanRegistry registry, T obj) throws InvocationTargetException, IllegalAccessException {
        Event event = events.next();
        if (!(event instanceof ScalarEvent))
            throw new IllegalStateException("Expected a string after the '$ref' key.");
        Object o = registry.resolveReference(((ScalarEvent) event).getValue());
        Method setter = getChildSetter(clazz, o.getClass());
        setSetter(obj, setter, o);
    }

    private static String getScalarKey(Event event) {
        if (!(event instanceof ScalarEvent)) {
            throw new IllegalStateException("Expected scalar or end-of-map in line " + event.getStartMark().getLine() + " column " + event.getStartMark().getColumn());
        }
        return ((ScalarEvent)event).getValue();
    }

    private static void ensureMappingStart(Event event) {
        if (!(event instanceof MappingStartEvent)) {
            throw new IllegalStateException("Expected start-of-map in line " + event.getStartMark().getLine() + " column " + event.getStartMark().getColumn());
        }
    }

    private static List parseListIncludingStartEvent(String context, Iterator<Event> events, BeanRegistry registry) {
        Event event = events.next();
        if (!(event instanceof SequenceStartEvent)) {
            throw new IllegalStateException("Expected start-of-sequence in line " + event.getStartMark().getLine() + " column " + event.getStartMark().getColumn());
        }
        return parseListExcludingStartEvent(context, events, registry);
    }

    private static @NotNull ArrayList parseListExcludingStartEvent(String context, Iterator<Event> events, BeanRegistry registry) {
        Event event;
        ArrayList res = new ArrayList();
        while (true) {
            event = events.next();
            if (event instanceof SequenceEndEvent)
                break;
            else if (!(event instanceof MappingStartEvent))
                throw new IllegalStateException("Expected end-of-sequence or begin-of-map in line " + event.getStartMark().getLine() + " column " + event.getStartMark().getColumn());
            Object o = parseMapToObj(context, events, registry);
            res.add(o);
        }

        return res;
    }

    private static Object parseMapToObj(String context, Iterator<Event> events, BeanRegistry registry) {
        Event event = events.next();
        if (!(event instanceof ScalarEvent))
            throw new IllegalStateException("Expected scalar in line " + event.getStartMark().getLine() + " column " + event.getStartMark().getColumn());
        Object o = parseMapToObj(context, events, event, registry);
        event = events.next();
        if (!(event instanceof MappingEndEvent))
            throw new IllegalStateException("Expected end-of-map or begin-of-map in line " + event.getStartMark().getLine() + " column " + event.getStartMark().getColumn());
        return o;
    }

    private static Object parseMapToObj(String context, Iterator<Event> events, Event event, BeanRegistry registry) {
        String key = ((ScalarEvent) event).getValue();
        if ("$ref".equals(key)) {
            event = events.next();
            if (!(event instanceof ScalarEvent))
                throw new IllegalStateException("Expected a string after the '$ref' key.");
            return registry.resolveReference(((ScalarEvent)event).getValue());
        }
        Class<?> clazz = K8sHelperGeneratorAutoGenerated.getLocal(context, key);
        if (clazz == null)
            clazz = K8sHelperGeneratorAutoGenerated.elementMapping.get(key);
        if (clazz == null)
            throw new RuntimeException("Did not find java class for key '" + key + "'.");
        return GenericYamlParser.parse(key, clazz, events, registry);
    }

    private static <T> Method getSetter(Class<T> clazz, String key) {
        return Arrays.stream(clazz.getMethods())
                .filter(ParserHelper::isSetter)
                .filter(method -> matchesJsonKey(method, key))
                .findFirst()
                .orElse(null);
    }

    private static <T> Method getAnySetter(Class<T> clazz) {
        return Arrays.stream(clazz.getMethods())
                .filter(ParserHelper::isSetter)
                .filter(method -> findAnnotation(method, MCOtherAttributes.class) != null)
                .findFirst()
                .orElse(null);
    }

    private static <T> Method getChildSetter(Class<T> clazz, Class<?> valueClass) {
        return Arrays.stream(clazz.getMethods())
                .filter(ParserHelper::isSetter)
                .filter(method -> method.getParameterTypes().length == 1)
                .filter(method -> method.getParameterTypes()[0].isAssignableFrom(valueClass))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Could not find child setter on " + clazz.getName() + " for value of type " + valueClass.getName()));
    }

}