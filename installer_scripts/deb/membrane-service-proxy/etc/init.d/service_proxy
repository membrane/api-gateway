#!/bin/bash
#
# chkconfig: 345 99 05
# description: Membrane Service Proxy deamon script
#

### BEGIN INIT INFO
# Provides:          service_proxy 
# Required-Start:    
# Required-Stop:
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Membrane Service Proxy Service
# Description: Lightweight Web Services Monitoring and Governance 
#	daemon service.  We want it to be active in runlevels 3
#	and 5, as these are the runlevels with the network
#	available.
### END INIT INFO 

# Set this to your Java installation


serviceNameLo="membrane_service_proxy"
serviceName="service_proxy"
#user can bind port under 1024 if you want 80 port or 443 to bind change here 
# membrane to root
serviceUser="membrane"
serviceGroup="membrane"
applDir="/opt/$serviceNameLo"
serviceLogFile="$applDir/$serviceNameLo.log"
maxShutdownTime=15

####-----
export MEMBRANE_HOME="$applDir"
CLASSPATH="$MEMBRANE_HOME/conf"
CLASSPATH="$CLASSPATH:$MEMBRANE_HOME/starter.jar"
export CLASSPATH

####*****
pidFile="/var/run/$serviceNameLo.pid"
javaCommand="java"
javaExe="/usr/bin/java"
javaArgs="-classpath "$CLASSPATH" -Dsun.net.client.defaultReadTimeout=20000 -Dsun.net.client.defaultConnectTimeout=2000 com.predic8.membrane.core.Starter \"$@\" "
memCommandLine="$javaExe $javaArgs"
memCommandLineKeyword="com.predic8.membrane.core.Starter"



# Makes the file $1 writable by the group $serviceGroup.
function makeFileWritable {
	local filename="$1"
	touch $filename || return 1
	chgrp root $filename || return 1
	chmod g+w $filename || return 1
	return 0; }

# Returns 0 if the process with PID $1 is running.
function checkProcessIsRunning {
	local pid="$1"
	if [ -z "$pid" -o "$pid" == " " ]; then return 1; fi
	if [ ! -e /proc/$pid ]; then return 1; fi
	return 0; }

# Returns 0 if the process with PID $1 is our Java service process.
function checkProcessIsOurService {
	local pid="$1"
	if [ "$(ps -p $pid --no-headers -o comm)" != "$javaCommand" ]; then return 1; fi
	grep -q --binary -F "$memCommandLineKeyword" /proc/$pid/cmdline
	if [ $? -ne 0 ]; then return 1; fi
	return 0; }

# Returns 0 when the service is running and sets the variable $pid to the PID.
function getServicePID {
	if [ ! -f $pidFile ]; then return 1; fi
	pid="$(<$pidFile)"
	checkProcessIsRunning $pid || return 1
	checkProcessIsOurService $pid || return 1
	return 0; }

function startServiceProcess {
	cd "$MEMBRANE_HOME" || return 1
	#cd $applDir || return 1
	rm -f $pidFile
	makeFileWritable $pidFile || return 1
	makeFileWritable $serviceLogFile || return 1
	cmd="nohup $memCommandLine >>$serviceLogFile 2>&1 & echo \$! >$pidFile"

	su -m root -s $SHELL -c "$cmd" || return 1
	sleep 0.1
	pid="$(<$pidFile)"

	if checkProcessIsRunning $pid; then :; else
	   echo -ne "\n$serviceName start failed, see logfile."
	   return 1
	fi
	
	return 0; }





function stopServiceProcess {
	kill $pid || return 1
	for ((i=0; i<maxShutdownTime*10; i++)); do
		checkProcessIsRunning $pid
		if [ $? -ne 0 ]; then
			rm -f $pidFile
			return 0
		fi
		sleep 0.1
	done
	echo -e "\n$serviceName did not terminate within $maxShutdownTime seconds, sending SIGKILL..."
	kill -s KILL $pid || return 1
	local killWaitTime=15
	for ((i=0; i<killWaitTime*10; i++)); do
		checkProcessIsRunning $pid
	   if [ $? -ne 0 ]; then
		rm -f $pidFile
		return 0
	   fi
		sleep 0.1
	   done
	echo "Error: $serviceName could not be stopped within $maxShutdownTime+$killWaitTime seconds!"
	return 1; }

function startService {
	getServicePID
	if [ $? -eq 0 ]; then echo -n "$serviceName is already running"; RETVAL=0; return 0; fi
	echo -n "Starting $serviceName   "
	startServiceProcess
	if [ $? -ne 0 ]; then RETVAL=1; echo "failed";  return 1; fi
	echo "started PID=$pid"
	RETVAL=0
	return 0; }

function stopService {
	getServicePID
	#if [ $? -ne 0 ]; then echo -n "$serviceName is not running"; RETVAL=0; echo ""; return 0; fi
	#if [ $? -eq 0 ]; then echo -n "$serviceName is locked"; RETVAL=1; echo ""; return 1; fi
	echo -n "Stopping $serviceName   "
	stopServiceProcess
	if [ $? -ne 0 ]; then RETVAL=1; echo "failed"; return 1; fi
	echo "stopped PID=$pid"
	RETVAL=0
	return 0; }

function checkServiceStatus {
	echo -n "Checking for $serviceName:   "
	if getServicePID; then
		echo "running PID=$pid"
		RETVAL=0
	else
		echo "stopped"
		RETVAL=3
	fi
	return 0; }

function main {
	RETVAL=0
	case "$1" in
		start)
			startService
			;;
		stop)
			stopService
			;;
		restart)
			stopService && startService
			;;
		status)
			checkServiceStatus;;
		*)
			echo "Usage: $0 {start|stop|restart|status}"
			exit 1
			;;
	esac
	exit $RETVAL
}

main $1
